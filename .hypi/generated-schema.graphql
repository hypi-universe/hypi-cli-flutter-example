"""This directive allows results to be deferred during execution"""
directive @defer on FIELD

directive @embedded on FIELD_DEFINITION

"""
Allows every type and function to be marked with the app and release where it was defined. This helps to identify where dependent types and functions came from in a schema
"""
directive @src(releaseId: String) on SCHEMA | SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | UNION | ENUM | INPUT_OBJECT

"""
check if the string or array is not null nor empty (for strings verifies its not all whitespace).
"""
directive @notEmpty on FIELD_DEFINITION

"""
Added to any field which should be store encrypted and not allowed to be returned to clients via GraphQL
PKCS5 is decrypted and can be passed to other functions but will not be returned through the generated APIs.
Note that only PKCS5 is reversible. Other encrypted formats are ONE WAY meaning you can compare new values against the
encrypted hash but you cannot get or compare to the original directly.
"""
directive @secret(hash: HashAlgorithm) on FIELD_DEFINITION

directive @computed(query: String, type: String, limit: Int, postQueryFn: String) on FIELD | FIELD_DEFINITION

"""If present on an object, no aggregation is possible on that type"""
directive @noagg on OBJECT

"""
Used by core to mark a type as being one of the generated TAgg types. Not for general use!
"""
directive @isagg(type: String!) on OBJECT | ENUM

"""
Indicates that the field cannot be changed after it is initially created
"""
directive @immutable on FIELD_DEFINITION

"""check if the date is in the future"""
directive @future on FIELD_DEFINITION

"""Added by Hypi to objects and fields it generates"""
directive @generated on SCALAR | OBJECT | FIELD_DEFINITION | UNION | ENUM | INPUT_OBJECT

"""
Valid on String, Object and Array fields.
Check if the string or array length matches the range.
Checks if the object's list of non-null fields matches the range
"""
directive @length(min: Long, max: Long) on FIELD_DEFINITION

"""
check whether the string is conform to the email address specification
Matches RFC 5322 regex, probably most relevant https://tools.ietf.org/html/rfc5322#section-3.4.1
pattern available at https://stackoverflow.com/a/201378/400048
"""
directive @email on FIELD_DEFINITION

"""
Adding this to any keyword indexed field ensures that no duplicates can be inserted for that field
"""
directive @unique on FIELD_DEFINITION

""" directive which allows any GraphQL definition's field to be provided by a Hypi Arc Tan function.
"""
directive @tan(type: TanType!, name: String, handler: String, inline: String, saveAs: String) on FIELD_DEFINITION

directive @computedCount(field: String, distinct: Boolean = false) on FIELD_DEFINITION

"""
check if the field's value matches the regular expression given a match flag (see https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  )
if allMustMatch is true (default) then all regex must pass
"""
directive @pattern(regex: [String!]!, allMustMatch: Boolean = true) on FIELD_DEFINITION

"""check if the value is not null"""
directive @notNull on FIELD_DEFINITION

"""Trigger the execution of the workflow with the given name"""
directive @workflow(name: String, inline: WorkflowInput) on FIELD_DEFINITION

"""
When applied causes the value of the field it is applied to to be resolved using an HTTP query configured with the given parameters
Each argument (url, body, query and headers) is a valid Velocity template).

The following may be referenced "vars", "settings"
vars refers to any arguments on the field the directive is applied to so ${vars.firstName} refers to the firstName arg of the field
settings refers to any instance settings provided in the app

Utilities:
JSON and Map utilities are available for use in all templates.
JsonNode JSON.parseJSON(String)
Map<String, Object> JSON.parse(String)

are available. Map is the standard Java Map interface containing static util methods e.g. Map.of(...)
"""
directive @http(method: HttpMethod! = GET, url: String!, headers: String, requestTemplate: String, inline: InlineHttpRequestTemplate, saveAs: String) on FIELD_DEFINITION

"""check if the date is in the past"""
directive @past on FIELD_DEFINITION

"""
Tells Hypi not to generate a table internally for the type this is attached to.
"""
directive @notable on OBJECT

"""
A trigger allows dynamically triggering functions before and after events on any Query or Mutation function
Triggers must be defined in schema because dynamic definitions at runtime would have a negative performance impact
Since it would require the platform to lookup and keep track of triggers per instance.
A trigger can be applied to inherited functions by redefining the function with exactly the same arguments, return type and directives + adding the trigger
If applied to an object the before and after triggers are executed before and after any upsert of that type
"""
directive @trigger(config: Trigger!) on OBJECT | FIELD_DEFINITION

"""If present on an object no input type will be generated from that type"""
directive @noinput on OBJECT

"""
Used internally to mark that a field in the schema should be resolve as an OpenAPI impl.
"""
directive @openapi_namespace on FIELD_DEFINITION

directive @indices(sets: [[String]]) on OBJECT | INTERFACE

"""
When added to an Int or Float field, the math arguments will not be added to that field
"""
directive @nomath on OBJECT | FIELD_DEFINITION

"""Add to any field which should not have a relay API generated"""
directive @norelay on FIELD | FIELD_DEFINITION

type AggregatedPolicyAggs {
  decisionStrategy: AggOtherScalar
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input WorkflowExecutableAsInputOpt {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInputOpt
  repeatN: Int
  steps: [WorkflowStepInputOpt]
  cronSchedule: String
  repeatIf: GraphQLRefInputOpt
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInputOpt
  evaluateIf: GraphQLRefInputOpt
  order: Int
}

type StripeOrder {
  hypi: Hypi
  id: String
  object: String
}

input AddressInput {
  hypi: HypiInput
  door: String
  street: String
  town: String
  county: String
  city: String
  country: CountryInput
  postCode: String
  from: DateTime
  to: DateTime
}

"""All fields defined by PersonName"""
enum PersonNameFields {
  hypi
  title
  firstName
  lastName
  from
  to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeAddressInput {
  hypi: HypiInput
  line1: String
  line2: String
  city: String
  country: String
  state: String
  postal_code: String
}

input RecommendationModelInput {
  hypi: HypiInput
  env: LearningEnvironmentInput
  trainer: RecommendationTrainerInput!
  type: String!
  ratingFieldName: String!
  subjectFieldName: String
  objectFieldName: String
  arcql: String
  name: String!
  description: String
  label: String
}

"""
input ComputedAggField {
  field: String! #The name of the field in the GraphQL type
  projectTo: String #The name of the field that should receive the aggregated value - if null, the value is projected to the same field IFF the type is Int or Float
  agg: ComputedAggType #Defaults to COUNT
}
"""
enum ComputedAggType {
  COUNT
  SUM
  AVG
  MAX
  MIN
}

type PredictionDataAggs {
  modelName: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type NotificationCtx {
  hypi: Hypi

  """The type that the notification applies to"""
  type: String
  targetAccount: ID
}

enum Gender {
  MALE
  FEMALE
  OTHER
  RATHER_NOT_SAY
}

enum AuthenticationMethod {
  header
  form
  query
}

input StripePauseCollectionMaths {
  resumes_at: MathInputInt
}

enum UserNameAttributeName {
  iss
  sub
  aud
  exp
  iat
  auth_time
  nonce
  acr
  amr
  azp
  at_hash
  c_hash
}

input GroupInputOpt {
  hypi: HypiInputOpt
  name: String
  accounts: [AccountInputOpt]
  children: [GroupInputOpt]
  organisations: [OrganisationInputOpt]
}

type StripeNextActionAggs {
  type: AggOtherScalar
  id: AggOtherScalar
  use_stripe_sdk: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type PhoneAggs {
  number: AggOtherScalar
  code: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input GroupPolicyInputOpt {
  hypi: HypiInputOpt
  groups: [GroupInputOpt]
  name: String
  logic: AuthLogic
}

"""
To reset an Account's password, create a `PasswordReminder`.

This will generate a code in the `code` field that can be referenced using $!{parent.code} in the `htmlMessage` or `plainTextMessage` fields.

This will send an email to the email in the `to` field. In the message you should provide a link to a URL where the user can enter their new password.
Include the code in this URL e.g. https://my-app.com/reset-password?code=$!{parent.code}.

When the user gets to this page, you will have the password reset code in the URL query string. Get this code from the URL
and when the user enter their new password, make a POST request to the Hypi API e.g.
POST <hypi-domain>/email/reset/<domain> - where <domain> is app instance domain.

In the body of the request send a JSON like this:
{"code": "<the-code-from-the-URL>", "password": "<the-user's-new-password>"}

Hypi will change the user's password and return HTTP status 200.
"""
type PasswordReminder {
  hypi: Hypi

  """If true the reset code has not yet been used."""
  valid: Boolean

  """
  The verification code that is included in the email sent. Generated by the server, if provided the provided value is ignored
  """
  code: String

  """The Account email that needs to be changed"""
  to: Email!

  """
  Optionally, the email from which the email will be sent. You MUST have a Hypi email app configured to send from this address
  """
  from: String

  """
  Optionally, the subject of the email, this is a velocity template - Hypi provides a default such as "Please verify your email to <realm>"
  """
  subject: String

  """
   The HTML contents of the email. This is a Velocity template that will be rendered before being sent.
   The available variables and their types are:
   instance: AppId - You app instance ID
   parent - a map representing the current EmailVerification object
   value - the value of the htmlMessage field
   env: HypiEnv
   
  """
  htmlMessage: String

  """
  A plain text version of the email - see this is a velocity template, see htmlMessage for available variables
  """
  plainTextMessage: String
}

type StripePriceAggs {
  id: AggOtherScalar
  active: AggOtherScalar
  currency: AggOtherScalar
  metadata: AggOtherScalar
  nickname: AggOtherScalar
  type: AggOtherScalar
  unit_amount: AggInt
  object: AggOtherScalar
  billing_scheme: AggOtherScalar
  created: AggInt
  live_mode: AggOtherScalar
  lookup_key: AggOtherScalar
  tiers_mode: AggOtherScalar
  unit_amount_decimal: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeSubscriptionUpdate"""
enum StripeSubscriptionUpdateScalarFields {
  billing_cycle_anchor
  expires_at
  trial_end
  trial_from_plan
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All numeric fields defined by LearningEnvironment"""
enum LearningEnvironmentNumericFields {
  rngSeed
  parallelism
  dataTtl
}

input EmailSendingAttemptGroupByOptions {
  """The field by which to to group the matching data"""
  field: EmailSendingAttemptScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePeriodInputOpt {
  hypi: HypiInputOpt
  start: Int
  end: Int
}

"""Scalar fields defined by AccountPolicy"""
enum AccountPolicyScalarFields {
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripePriceRecurrence"""
enum StripePriceRecurrenceFields {
  hypi

  """
  Specifies a usage aggregation strategy for prices of usage_type=metered
  """
  aggregate_usage

  """The frequency at which a subscription is billed."""
  interval

  """
  The number of intervals (specified in the interval attribute) between subscription billings. For example, interval=month and interval_count=3 bills every 3 months.
  """
  interval_count

  """
  Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
  """
  usage_type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeTaxAmountGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTaxAmountScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeBankAccount"""
enum StripeBankAccountFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeReview {
  hypi: Hypi
  id: String
  object: String
}

"""
If the query or mutation functions in the Webhook definition returns this then it controls what the server responds with
For example, the GraphQL function can return a 301 or 302 status and a Location header to an external URL to cause a redirect.
"""
type WebhookResponse {
  hypi: Hypi
  status: Int
  headers: Json
  body: Json
}

type StripeSourceAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  client_secret: AggOtherScalar
  reusable: AggOtherScalar
  livemode: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
A union of all types in the app which can be created or updated directly
"""
union HypiRootAggregate = Product | PageInfo | HypiResultEdge | HypiFilterConnection | HypiEnv | Pair | AggInt | AggFloat | AggOtherScalar | Script | RequestTemplate | NotificationCtx | Notification | URL | Currency | Coordinate | GeoEnvelope | Language | Address | PersonName | Phone | Email | Password | RemoteLogin | LoginAttempt | BruteForceDetectionOptions | OAuth2AuthorizedClient | AuthClient | ABACPolicy | ABACTag | Image | EmailVerification | EmailTemplate | EmailSendingAttempt | PasswordReminder | Webhook | WebhookResponse | LogMessage | GraphQLRef | WorkflowStepData | WorkflowStep | AccessToken | StorageCounter | PermissionDescription | Hypi | Country | Account | Person | Organisation | OAuthProvider | Realm | Group | Role | RolePolicy | ClientPolicy | TimePolicy | AggregatedPolicy | GroupPolicy | AccountPolicy | RealmPolicy | RealmLink | Permission | File | Video | EmailMessage | Workflow | WorkflowSession | Counter | Gauge | ServerlessResponse | LearningEnvironment | RecommendationModel | KMeanCLusteringModel | RecommendationTrainer | ObjectSubjectRatingTriplet | PredictionData | TrainingInstance | InvoiceItem | PricePlanInclusion | StripeOrder | StripeReview | StripeTransfer | StripeTransferData | StripeFraudDetails | StripeShippingInfo | StripeBillingDetails | StripeAddress | StripeDispute | StripeEvent | StripeMandate | StripePaymentMethodDetails | StripeCustomerAcceptance | StripePayout | StripePackageDimensions | StripeTransformQuantity | StripeTier | StripePriceRecurrence | StripeRefund | StripePaymentMethod | StripeSebaDebit | StripeIdeal | StripeFpx | StripeCardPresent | StripeReceipt | StripeBacsDebit | StripeAuBecsDebit | StripeBankAccount | StripeSource | StripeCoupon | StripeCreditNote | StripeCustomerBalanceTransaction | StripeCustomerPortal | StripeTaxId | StripeDiscount | StripeTaxAmount | StripeDiscountAmount | StripeStatusTransitions | StripeInvoiceLineItem | StripePeriod | StripePromotionCode | StripeIntervalObject | StripePauseCollection | StripePlan | StripeBillingThreshold | StripeSubscriptionScheduleSettings | StripeInvoiceSettings | StripeTaxRate | StripeUsageRecord | StripeCheckoutSession | StripeError | StripeNextAction | StripeAliPayHandleRedirect | StripeOxxoDisplayDetails | StripeRedirectToUrl | StripeSofort | StripeReference | Invoice | PricePlanAllowance | PricePlan | StripeCharge | StripeChargeOutcome | StripeCustomer | StripeProduct | StripePrice | StripeInvoice | StripeThesholdReason | StripeItemReason | StripeInvoiceItem | StripeSubscription | StripeSubscriptionUpdate | StripeSubscriptionItem | StripeSubscriptionSchedule | StripeSubscriptionPhase | StripePaymentIntent | StripeSetupIntent

"""
PaymentMethod objects represent your customer's payment instruments. They can be used with PaymentIntents to collect payments or saved to Customer objects to store instrument details for future payments.
https://stripe.com/docs/api/payment_methods
"""
type StripePaymentMethod {
  hypi: Hypi
  id: String
  object: String
  billing_details: StripeBillingDetails
  customer: StripeCustomer
  metadata: Json
  type: StripePaymentMethds
  alipay: String
  au_becs_debit: StripeAuBecsDebit
  bacs_debit: StripeBacsDebit
  bancontact: String
  card: String
  card_present: StripeCardPresent
  created: Int
  eps: String
  fpx: StripeFpx
  giropay: String
  ideal: StripeIdeal
  interac_present: String
  livemode: Boolean
  oxxo: String
  p24: String
  sepa_debit: StripeSebaDebit
  sofort: StripeSofort
}

input EmailMessageGroupByOptions {
  """The field by which to to group the matching data"""
  field: EmailMessageScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input WorkflowOrderedInput {
  execAs: String
  async: Boolean
  name: String
  fn: GraphQLRefInput
  maxExecutionTime: String
  repeatN: Int
  hypi: HypiInput
  evaluateIf: GraphQLRefInput
  order: Int!
  repeatIf: GraphQLRefInput
}

input WorkflowGroupByOptions {
  """The field by which to to group the matching data"""
  field: WorkflowScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input OAuth2AuthorizedClientGroupByOptions {
  """The field by which to to group the matching data"""
  field: OAuth2AuthorizedClientScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type AccountAggs {
  verified: AggOtherScalar
  enabled: AggOtherScalar
  username: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

enum HttpMethod {
  GET
  PUT
  POST
  DELETE
  PATCH
  OPTIONS
  HEAD
  TRACE
}

input ServerlessResponseInputOpt {
  hypi: HypiInputOpt
  path: String
  headers: Json
  multiPart: Boolean
  method: String
  files: [FileInputOpt]
  chunked: Boolean
  attributes: [String]
  queryString: Json
  body: Json
  cookies: Json
}

"""All fields defined by StripeTransfer"""
enum StripeTransferFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""
Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.
https://stripe.com/docs/api/refunds
"""
type StripeRefund {
  hypi: Hypi
  id: String
  object: String
}

"""Scalar fields defined by InvoiceItem"""
enum InvoiceItemScalarFields {
  name
  description

  """
   If provided this specifies the type that the GraphQL item is for.
   When used in a price plan's inclusion, this can limit operations on a per type basis
   For example, if the value is Account and allowed amount is 10, then attempting to create an 11th Account will fail
  """
  type
  quantity
  unit

  """
  If provided then apply VAT to this invoice item even if there is a global invoice item
  """
  vat

  """
  Valid for credit and discount units. If provided the quantity of credit or discount is taken as a percentage rather than an absolute value.
  """
  is_percentage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripePeriod"""
enum StripePeriodScalarFields {
  start
  end
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input NotificationCtxInput {
  hypi: HypiInput
  type: String
  targetAccount: ID
}

input StripePromotionCodeGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePromotionCodeScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StripeStatusTransitions"""
enum StripeStatusTransitionsNumericFields {
  finalized_at
  marked_uncollectible_at
  paid_at
  voided_at
}

input StripeDisputeInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input FileInput {
  hypi: HypiInput
  name: String!
  directory: String!
  path: String!
  isDirectory: Boolean!
  status: FileStatus
  url: URLInput
  children: [FileInput!]
  type: String
  size: Long
  extension: String
  isStared: Boolean
  isSharable: Boolean
  content: String
}

input StripeSubscriptionPhaseInput {
  hypi: HypiInput
  end_date: Int
  start_date: Int
  add_invoice_items: StripeInvoiceItemInput
  billing_cycle_anchor: StripeBillingCycleAnchor
  billing_thresholds: StripeBillingThresholdInput
  collection_method: StripeCollectionMethod
  coupon: StripeCouponInput
  default_payment_method: StripePaymentMethodInput
  default_tax_rates: [StripeTaxRateInput!]
  invoice_settings: StripeInvoiceSettingsInput
  items: StripeSubscriptionItemInput
  proration_behavior: StripeProrationBehavior
  trial_end: Int
}

"""
Events that can be raised by the system to inform you about errors or other state that happened asynchronously, hence you may not otherwise have been told this info.
"""
type Notification {
  hypi: Hypi
  message: String
  ctx: NotificationCtx
}

input NotificationCtxGroupByOptions {
  """The field by which to to group the matching data"""
  field: NotificationCtxScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type ObjectSubjectRatingTripletAggs {
  subjectId: AggInt
  objectId: AggInt
  rating: AggFloat
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeFpx"""
enum StripeFpxScalarFields {
  bank
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeReceiptInputOpt {
  hypi: HypiInputOpt
  account_type: StripeAccountType
  application_cryptogram: String
  application_preferred_name: String
  authorization_code: String
  authorization_response_code: String
  cardholder_verification_method: String
  dedicated_file_name: String
  terminal_verification_results: String
  transaction_status_information: String
}

input RemoteLoginInput {
  hypi: HypiInput
  type: String
  email: String
  remoteId: String
  otherAttributes: Json
}

input RolePolicyInput {
  hypi: HypiInput
  roles: [RoleInput!]!
  name: String!
  logic: AuthLogic
}

type AggregatedPolicy implements Policy {
  hypi: Hypi

  """defines how the policy arrives at a decision, the options are:"""
  decisionStrategy: DecisionStrategy
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  policies(arcql: String, first: Int, after: String, last: Int, before: String): [Policy!]!
}

input StripeOrderGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeOrderScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by Phone"""
enum PhoneFields {
  hypi
  number
  country
  code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripeTransformQuantity"""
enum StripeTransformQuantityFields {
  hypi

  """Divide usage by this number."""
  divide_by

  """After division, either round the result up or down."""
  round
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input AccountGroupByOptions {
  """The field by which to to group the matching data"""
  field: AccountScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeSubscriptionPhaseGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSubscriptionPhaseScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeSubscriptionScheduleMaths {
  canceled_at: MathInputInt
  completed_at: MathInputInt
  created: MathInputInt
  released_at: MathInputInt
}

enum StripeProrationBehavior {
  create_prorations
  none
}

"""All fields defined by RolePolicy"""
enum RolePolicyFields {
  hypi
  name

  """Positive` or `Negative"""
  logic
  roles
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeInvoiceLineItemGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeInvoiceLineItemScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StripeInvoice"""
enum StripeInvoiceNumericFields {
  period_end
  period_start
  total
  amount_due
  amount_paid
  amount_remaining
  attempt_count
  created
  due_date
  ending_balance
  next_payment_attempt
  post_payment_credit_notes_amount
  pre_payment_credit_notes_amount
  starting_balance
  subscription_proration_date
  subtotal
  tax
  webhooks_delivered_at
}

"""All fields defined by ABACPolicy"""
enum ABACPolicyFields {
  hypi
  from
  to

  """
   The instance the policy applies to. By default the same instance in which it exists.
   A `Platform Admin` can set it to *, all other users get permission denied if this is not the same as their current instance.
   
  """
  givenInstance

  """e.g. Account or *"""
  givenType

  """Exactly one of Query|Mutation|Subscription|*"""
  givenOperation

  """The exact function name or wildcard e.g. find|upsert|*"""
  givenFn

  """
  The prefix that any function can begin with e.g. find will match findX, findY, findOther
  """
  givenFnPrefix
  whenResourceTagKeyEq
  whenResourceTagKeyPrefix
  whenResourceTagValueEq
  whenResourceTagValuePrefix

  """Policy applies when the account ID is equal to this"""
  assertAccountIdEq

  """Policy applies when the account username starts with this"""
  assertAccountUsernamePrefix

  """When set, the account MUST have a tag whose key is equal to this"""
  assertAccountTagKeyEq

  """When set, the account MUST have a tag whose key is starts with this"""
  assertAccountTagKeyPrefix

  """When set, the account MUST have a tag whose value is equal to this"""
  assertAccountTagValEq

  """When set, the account MUST have a tag whose value is starts with this"""
  assertAccountTagValPrefix

  """
  Resource owner can set the boundary to RESOURCE (or anyone that has permission to do so)
  System Admin for the instance can set the boundary to INSTANCE
  Platform Admin can set the boundary to PLATFORM
  PLATFORM|INSTANCE|RESOURCE
  """
  boundary

  """
  If provided, this is a comma separate list of field paths that are allowed by this policy
  e.g. a,b.c allows access to a and all sub-fields below it as well as to the field c under the parent field b. No other field under b is allowed
  If the policy is allowing read access, only these fields can be seen. If it is write acces, only these fields can be modified.
  """
  allowedFields
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input WorkflowStepDataInput {
  hypi: HypiInput
  stepName: String!
  stepResult: Any!
}

input StripeStatusTransitionsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeStatusTransitionsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeOxxoDisplayDetails {
  hypi: Hypi
  expires_after: Int
  hosted_voucher_url: String
  number: String
}

"""Scalar fields defined by Notification"""
enum NotificationScalarFields {
  message
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  ctx_type
  ctx_targetAccount
}

"""All fields defined by StripeInvoice"""
enum StripeInvoiceFields {
  hypi
  id
  auto_advance
  charge
  collection_method
  currency
  customer
  description
  hosted_invoice_url
  metadata
  payment_intent
  period_end
  period_start
  status
  subscription
  total
  object
  account_country
  account_name
  amount_due
  amount_paid
  amount_remaining
  attempt_count
  attempted
  billing_reason
  created
  customer_address
  customer_email
  customer_name
  customer_phone
  customer_shipping
  customer_tax_exempt
  default_payment_method
  default_source
  discount
  due_date
  ending_balance
  footer
  invoice_pdf
  livemode
  next_payment_attempt
  number
  paid
  post_payment_credit_notes_amount
  pre_payment_credit_notes_amount
  receipt_number
  starting_balance
  statement_descriptor
  status_transitions
  subscription_proration_date
  subtotal
  tax
  threshold_reason
  webhooks_delivered_at
  lines
  account_tax_ids
  custom_fields
  customer_tax_ids
  default_tax_rates
  discounts
  total_discount_amounts
  total_tax_amounts
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input RealmLinkInput {
  hypi: HypiInput
  name: String!
  accounts: [AccountInput!]!
}

type StripeEventAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeInvoiceSettings"""
enum StripeInvoiceSettingsFields {
  hypi
  days_until_due
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type LoginAttempt {
  hypi: Hypi
  successful: Boolean
  errorCode: String
}

input CountryInputOpt {
  hypi: HypiInputOpt
  name: String
  stateName: String
  sovereignty: String
  alpha2code: String
  alpha3code: String
  numericCode: String
  subdivisionCodeLinks: String
  internetCCTLD: String
  continent: String
  currencies: [CurrencyInputOpt]
  languagesSpoken: [LanguageInputOpt]
  officialLanguage: LanguageInputOpt
}

input AccessTokenInputOpt {
  hypi: HypiInputOpt
  sessionToken: String
  sessionExpires: Long
  errorCode: String
  errorMsg: String
}

input PolicyInputOpt {
  realms: [RealmLinkInputOpt]
  clients: [AuthClientInputOpt]
  roles: [RoleInputOpt]
  name: String
  policies: [PolicyInputOpt]
  groups: [GroupInputOpt]
  from: DateTime
  hypi: HypiInputOpt
  logic: AuthLogic
  to: DateTime
  accounts: [AccountInputOpt]
  decisionStrategy: DecisionStrategy
}

input StripePaymentIntentInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  amount: Int
  amount_capturable: Int
  amount_received: Int
  charges: [StripeChargeInputOpt]
  client_secret: String
  currency: String
  customer: StripeCustomerInputOpt
  description: String
  last_payment_error: StripeErrorInputOpt
  metadata: Json
  next_action: StripeNextActionInputOpt
  payment_method: StripePaymentMethodInputOpt
  payment_method_types: [String]
  receipt_email: String
  setup_future_usage: StripeUsage
  shipping: StripeShippingInfoInputOpt
  statement_descriptor: String
  statement_descriptor_suffix: String
  status: String
  canceled_at: Int
  cncellation_reason: String
  capture_method: StripeCaptureMethod
  confirmation_method: StripeConfirmationMethod
  created: Int
  invoice: StripeInvoiceInputOpt
  livemode: Boolean
  payment_method_options: StripePaymentOptionInputOpt
  review: String
}

"""All fields defined by StripePaymentMethod"""
enum StripePaymentMethodFields {
  hypi
  id
  object
  billing_details
  customer
  metadata
  type
  alipay
  au_becs_debit
  bacs_debit
  bancontact
  card
  card_present
  created
  eps
  fpx
  giropay
  ideal
  interac_present
  livemode
  oxxo
  p24
  sepa_debit
  sofort
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeSetupIntentGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSetupIntentScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by PricePlanAllowance"""
enum PricePlanAllowanceNumericFields {
  allowed_overage_amount
}

"""Scalar fields defined by StripeAddress"""
enum StripeAddressScalarFields {
  """Address line 1 (e.g., street, PO Box, or company name)."""
  line1

  """Address line 2 (e.g., apartment, suite, unit, or building)."""
  line2

  """City, district, suburb, town, or village."""
  city

  """Two-letter country code (ISO 3166-1 alpha-2)."""
  country

  """State, county, province, or region."""
  state

  """ZIP or postal code."""
  postal_code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeCardPresentAggs {
  brand: AggOtherScalar
  cardholder_name: AggOtherScalar
  country: AggOtherScalar
  emv_auth_data: AggOtherScalar
  exp_month: AggInt
  exp_year: AggInt
  fingerprint: AggOtherScalar
  funding: AggOtherScalar
  generated_card: AggOtherScalar
  last4: AggOtherScalar
  network: AggOtherScalar
  read_method: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type Email {
  hypi: Hypi
  value: String!
  type: String
}

input StripeTransformQuantityGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTransformQuantityScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeSubscriptionScheduleSettingsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSubscriptionScheduleSettingsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by HypiEnv"""
enum HypiEnvFields {
  hypi
  apiHost
  websocketHost
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeCustomerGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCustomerScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeTaxAmountMaths {
  amount: MathInputInt
}

input StripeInvoiceItemMaths {
  amount: MathInputInt
  date: MathInputInt
  quantity: MathInputInt
  unit_amount: MathInputInt
  unit_amount_decimal: MathInputFloat
}

input StripeAliPayHandleRedirectInputOpt {
  hypi: HypiInputOpt
  native_data: String
  native_url: String
  return_url: String
  url: String
}

input GaugeMaths {
  value: MathInputFloat
}

"""All fields defined by Realm"""
enum RealmFields {
  hypi

  """
  the name identifying the organisation and becomes the URL by which it is accessed e.g. alpha-corp.hypi.app, where alpha-corp is name
  If not provided one will be automatically generated
  """
  name
  logo

  """The name displayed in the user interface"""
  displayName

  """If true users can register without an admin creating their account"""
  allowRegistrations

  """if true users must verify their email before they're allowed to login"""
  verifyEmail

  """
  Optionally defines some options to help detect and protect against brute force login attempts
  """
  bruteForceDetection
  referrer
  remoteLoginId
  organisations
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeTaxId"""
enum StripeTaxIdScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices.
https://stripe.com/docs/api/usage_records
"""
type StripeUsageRecord {
  hypi: Hypi
  id: String
  quantity: Int
  subscription_item: StripeSubscriptionItem
  timestamp: Int
  object: String
  livemode: Boolean
}

input StripeFpxGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeFpxScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePaymentIntentGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePaymentIntentScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type ABACPolicyAggs {
  from: AggOtherScalar
  to: AggOtherScalar
  givenInstance: AggOtherScalar
  givenType: AggOtherScalar
  givenOperation: AggOtherScalar
  givenFn: AggOtherScalar
  givenFnPrefix: AggOtherScalar
  whenResourceTagKeyEq: AggOtherScalar
  whenResourceTagKeyPrefix: AggOtherScalar
  whenResourceTagValueEq: AggOtherScalar
  whenResourceTagValuePrefix: AggOtherScalar
  assertAccountIdEq: AggOtherScalar
  assertAccountUsernamePrefix: AggOtherScalar
  assertAccountTagKeyEq: AggOtherScalar
  assertAccountTagKeyPrefix: AggOtherScalar
  assertAccountTagValEq: AggOtherScalar
  assertAccountTagValPrefix: AggOtherScalar
  boundary: AggOtherScalar
  allowedFields: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input EmailTemplateInputOpt {
  hypi: HypiInputOpt
  name: String
  description: String
  template: String
  comment: String
}

enum StripeFpxBank {
  affin_bank
  alliance_bank
  ambank
  bank_islam
  bank_muamalat
  bank_rakyat
  bsn
  cimb
  hong_leong_bank
  hsbc
  kfh
  maybank2u
  ocbc
  public_bank
  rhb
  standard_chartered
  uob
  deutsche_bank
  maybank2e
  pb_enterprise
}

input StripePauseCollectionInputOpt {
  hypi: HypiInputOpt
  behavior: StripePauseCollectionBehavior
  resumes_at: Int
}

"""Scalar fields defined by StripeSetupIntent"""
enum StripeSetupIntentScalarFields {
  id
  object
  client_secret
  description
  metadata
  status
  cncellation_reason
  created
  livemode
  usage
  payment_method_types
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeBillingDetailsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeBillingDetailsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input CounterMaths {
  value: MathInputFloat
}

type ABACPolicy {
  hypi: Hypi
  from: DateTime
  to: DateTime

  """
   The instance the policy applies to. By default the same instance in which it exists.
   A `Platform Admin` can set it to *, all other users get permission denied if this is not the same as their current instance.
   
  """
  givenInstance: String

  """e.g. Account or *"""
  givenType: String!

  """Exactly one of Query|Mutation|Subscription|*"""
  givenOperation: String!

  """The exact function name or wildcard e.g. find|upsert|*"""
  givenFn: String

  """
  The prefix that any function can begin with e.g. find will match findX, findY, findOther
  """
  givenFnPrefix: String
  whenResourceTagKeyEq: String
  whenResourceTagKeyPrefix: String
  whenResourceTagValueEq: String
  whenResourceTagValuePrefix: String

  """Policy applies when the account ID is equal to this"""
  assertAccountIdEq: String

  """Policy applies when the account username starts with this"""
  assertAccountUsernamePrefix: String

  """When set, the account MUST have a tag whose key is equal to this"""
  assertAccountTagKeyEq: String

  """When set, the account MUST have a tag whose key is starts with this"""
  assertAccountTagKeyPrefix: String

  """When set, the account MUST have a tag whose value is equal to this"""
  assertAccountTagValEq: String

  """When set, the account MUST have a tag whose value is starts with this"""
  assertAccountTagValPrefix: String

  """
  Resource owner can set the boundary to RESOURCE (or anyone that has permission to do so)
  System Admin for the instance can set the boundary to INSTANCE
  Platform Admin can set the boundary to PLATFORM
  PLATFORM|INSTANCE|RESOURCE
  """
  boundary: PolicyBoundary

  """
  If provided, this is a comma separate list of field paths that are allowed by this policy
  e.g. a,b.c allows access to a and all sub-fields below it as well as to the field c under the parent field b. No other field under b is allowed
  If the policy is allowing read access, only these fields can be seen. If it is write acces, only these fields can be modified.
  """
  allowedFields: String
}

"""All fields defined by PredictionData"""
enum PredictionDataFields {
  hypi
  modelName
  data
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeMandate"""
enum StripeMandateScalarFields {
  id
  status
  type
  object
  livemode
  multi_use
  single_use
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeReceipt"""
enum StripeReceiptScalarFields {
  account_type
  application_cryptogram
  application_preferred_name
  authorization_code
  authorization_response_code
  cardholder_verification_method
  dedicated_file_name
  terminal_verification_results
  transaction_status_information
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeUsageRecord"""
enum StripeUsageRecordScalarFields {
  id
  quantity
  timestamp
  object
  livemode
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type PermissionAggs {
  name: AggOtherScalar
  decisionStrategy: AggOtherScalar
  type: AggOtherScalar
  resource: AggOtherScalar
  operationType: AggOtherScalar
  includeAllAccounts: AggOtherScalar
  scopes: AggOtherScalar
  operations: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

enum StripePriceType {
  one_time
  recurring
}

input RealmInput {
  hypi: HypiInput
  name: String
  logo: ImageInput
  displayName: String
  allowRegistrations: Boolean
  verifyEmail: Boolean
  bruteForceDetection: BruteForceDetectionOptionsInput
  organisations: [OrganisationInput!]!
  referrer: String
  remoteLoginId: String
}

input TimePolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: TimePolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePriceRecurrenceInput {
  hypi: HypiInput
  aggregate_usage: StripeAggregateUsage
  interval: StripeBillingFrequency
  interval_count: Int
  usage_type: StripeUsageType
}

input StripeCreditNoteInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input InlineHttpRequestTemplate {
  requestTemplate: String
  responseTemplate: String
}

"""Scalar fields defined by StripeInvoice"""
enum StripeInvoiceScalarFields {
  id
  auto_advance
  collection_method
  currency
  description
  hosted_invoice_url
  metadata
  period_end
  period_start
  status
  total
  object
  account_country
  account_name
  amount_due
  amount_paid
  amount_remaining
  attempt_count
  attempted
  billing_reason
  created
  customer_email
  customer_name
  customer_phone
  customer_tax_exempt
  due_date
  ending_balance
  footer
  invoice_pdf
  livemode
  next_payment_attempt
  number
  paid
  post_payment_credit_notes_amount
  pre_payment_credit_notes_amount
  receipt_number
  starting_balance
  statement_descriptor
  subscription_proration_date
  subtotal
  tax
  webhooks_delivered_at
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type FileAggs {
  name: AggOtherScalar
  directory: AggOtherScalar
  path: AggOtherScalar
  isDirectory: AggOtherScalar
  status: AggOtherScalar
  type: AggOtherScalar
  size: AggOtherScalar
  extension: AggOtherScalar
  isStared: AggOtherScalar
  isSharable: AggOtherScalar
  content: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All numeric fields defined by StripeSubscriptionPhase"""
enum StripeSubscriptionPhaseNumericFields {
  end_date
  start_date
  trial_end
}

input PhoneGroupByOptions {
  """The field by which to to group the matching data"""
  field: PhoneScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type Video {
  hypi: Hypi
  name: String!
  file: File!
  description: String
  location: Geo
  thumbnails(arcql: String, first: Int, after: String, last: Int, before: String): [Image!]
}

input ABACTagInputOpt {
  hypi: HypiInputOpt
  key: String
  value: String
}

type StripeReviewAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
A discount represents the actual application of a coupon to a particular customer. It contains information about when the discount began and when it will end.
https://stripe.com/docs/api/discounts
"""
type StripeDiscount {
  hypi: Hypi
  id: String
  object: String
}

input ProductGroupByOptions {
  """The field by which to to group the matching data"""
  field: ProductScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by ServerlessResponse"""
enum ServerlessResponseScalarFields {
  path
  headers
  multiPart
  method
  chunked
  queryString
  body
  cookies
  attributes
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input VideoGroupByOptions {
  """The field by which to to group the matching data"""
  field: VideoScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""
Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Checkout and Subscriptions.
https://stripe.com/docs/api/products
"""
type StripeProduct {
  hypi: Hypi
  id: String
  active: Boolean
  description: String
  metadata: Json
  name: String
  object: String
  caption: String
  created: Int
  livemode: Boolean
  url: String
  updated: Int
  unit_label: String
  statement_descriptor: String
  shippable: Boolean
  package_dimensions: StripePackageDimensions
  attributes(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
  deactivate_on(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
  images(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
}

type NotificationCtxAggs {
  type: AggOtherScalar
  targetAccount: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input WorkflowStepDataGroupByOptions {
  """The field by which to to group the matching data"""
  field: WorkflowStepDataScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by StripeBacsDebit"""
enum StripeBacsDebitScalarFields {
  fingerprint
  last4
  sort_code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeTransferDataAggs {
  amount: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
Invoices are statements of amounts owed by a customer, and are either generated one-off, or generated periodically from a subscription.

They contain invoice items, and proration adjustments that may be caused by subscription upgrades/downgrades (if necessary).

If your invoice is configured to be billed through automatic charges, Stripe automatically finalizes your invoice and attempts payment. Note that finalizing the invoice, when automatic, does not happen immediately as the invoice is created. Stripe waits until one hour after the last webhook was successfully sent (or the last webhook timed out after failing). If you (and the platforms you may have connected to) have no webhooks configured, Stripe waits one hour after creation to finalize the invoice.

If your invoice is configured to be billed by sending an email, then based on your email settings, Stripe will email the invoice to your customer and await payment. These emails can contain a link to a hosted page to pay the invoice.

Stripe applies any customer credit on the account before determining the amount due for the invoice (i.e., the amount that will be actually charged). If the amount due for the invoice is less than Stripe's minimum allowed charge per currency, the invoice is automatically marked paid, and we add the amount due to the customer's running account balance which is applied to the next invoice.

https://stripe.com/docs/api/invoices
"""
type StripeInvoice {
  hypi: Hypi
  id: String
  auto_advance: Boolean
  charge: StripeCharge
  collection_method: StripeCollectionMethod
  currency: String
  customer: StripeCustomer
  description: String
  hosted_invoice_url: String
  metadata: Json
  payment_intent: StripePaymentIntent
  period_end: Int
  period_start: Int
  status: StripeInvoiceStatus
  subscription: StripeSubscription
  total: Int
  object: String
  account_country: String
  account_name: String
  amount_due: Int
  amount_paid: Int
  amount_remaining: Int
  attempt_count: Int
  attempted: Boolean
  billing_reason: String
  created: Int
  customer_address: StripeAddress
  customer_email: String
  customer_name: String
  customer_phone: String
  customer_shipping: StripeShippingInfo
  customer_tax_exempt: String
  default_payment_method: StripePaymentMethod
  default_source: StripeSource
  discount: StripeDiscount
  due_date: Int
  ending_balance: Int
  footer: String
  invoice_pdf: String
  livemode: Boolean
  next_payment_attempt: Int
  number: String
  paid: Boolean
  post_payment_credit_notes_amount: Int
  pre_payment_credit_notes_amount: Int
  receipt_number: String
  starting_balance: Int
  statement_descriptor: String
  status_transitions: StripeStatusTransitions
  subscription_proration_date: Int
  subtotal: Int
  tax: Int
  threshold_reason: StripeThesholdReason
  webhooks_delivered_at: Int
  lines(arcql: String, first: Int, after: String, last: Int, before: String): [StripeInvoiceLineItem!]
  account_tax_ids(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxId!]
  custom_fields(arcql: String, first: Int, after: String, last: Int, before: String): [Pair!]
  customer_tax_ids(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxId!]
  default_tax_rates(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxRate!]
  discounts(arcql: String, first: Int, after: String, last: Int, before: String): [StripeDiscount!]
  total_discount_amounts(arcql: String, first: Int, after: String, last: Int, before: String): [StripeDiscountAmount!]
  total_tax_amounts(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxAmount!]
}

input WorkflowParallelInputOpt {
  execAs: String
  async: Boolean
  parallel: Boolean
  name: String
  maxExecutionTime: String
  repeatN: Int
  hypi: HypiInputOpt
  steps: [WorkflowStepInputOpt]
  evaluateIf: GraphQLRefInputOpt
  cronSchedule: String
  repeatIf: GraphQLRefInputOpt
}

enum ClientAuthenticationMethod {
  basic
  post
}

"""All numeric fields defined by StripeItemReason"""
enum StripeItemReasonNumericFields {
  usage_gte
}

"""Scalar fields defined by RealmLink"""
enum RealmLinkScalarFields {
  name
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeSubscriptionScheduleSettings {
  hypi: Hypi
  billing_cycle_anchor: StripeBillingCycleAnchor
  billing_thresholds: StripeBillingThreshold
  collection_method: StripeCollectionMethod
  default_payment_method: StripePaymentMethod
  invoice_settings: StripeInvoiceSettings
}

type StripePackageDimensions {
  hypi: Hypi
  height: Float
  length: Float
  weight: Float
  width: Float
}

type StripePaymentMethodAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  metadata: AggOtherScalar
  type: AggOtherScalar
  alipay: AggOtherScalar
  bancontact: AggOtherScalar
  card: AggOtherScalar
  created: AggInt
  eps: AggOtherScalar
  giropay: AggOtherScalar
  interac_present: AggOtherScalar
  livemode: AggOtherScalar
  oxxo: AggOtherScalar
  p24: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input InvoiceInputOpt {
  hypi: HypiInputOpt
  buyer: AccountInputOpt
  seller: AccountInputOpt
  due_date: DateTime
  notes: String
  vat_amount: Float
  items: [InvoiceItemInputOpt]
}

"""Scalar fields defined by StripeInvoiceLineItem"""
enum StripeInvoiceLineItemScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripePayoutAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by Workflow"""
enum WorkflowScalarFields {
  name

  """
  If present, this is a cron schedule to automatically execute this Workflow
  The syntax as defined at https://www.manpagez.com/man/5/crontab/
  NOTE: The special strings @hourly, @daily etc are NOT supported
  """
  cronSchedule

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs
  async

  """
  If present AND true, all steps in this block are executed at the same time.
  """
  parallel

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime
  repeatN
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  evaluateIf_type
  evaluateIf_field
  evaluateIf_selection
  repeatIf_type
  repeatIf_field
  repeatIf_selection
}

input StripeFraudDetailsInputOpt {
  hypi: HypiInputOpt
  stripe_report: String
  user_report: String
}

input StripeProductInput {
  hypi: HypiInput
  id: String
  active: Boolean
  description: String
  metadata: Json
  name: String
  object: String
  attributes: [String!]
  caption: String
  created: Int
  deactivate_on: [String!]
  images: [String!]
  livemode: Boolean
  url: String
  updated: Int
  unit_label: String
  statement_descriptor: String
  shippable: Boolean
  package_dimensions: StripePackageDimensionsInput
}

input OAuthProviderGroupByOptions {
  """The field by which to to group the matching data"""
  field: OAuthProviderScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input NotificationCtxInputOpt {
  hypi: HypiInputOpt
  type: String
  targetAccount: ID
}

"""Scalar fields defined by ClientPolicy"""
enum ClientPolicyScalarFields {
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input GraphQLRefGroupByOptions {
  """The field by which to to group the matching data"""
  field: GraphQLRefScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input LanguageInputOpt {
  hypi: HypiInputOpt
  family: String
  isoName: String
  nativeName: String
  iso6391Code: String
  iso6392TCode: String
  iso6392BCode: String
  iso6393Code: String
}

"""
Used to represent arbitrary customer specific collections of entities e.g. an Organisation, a Meetup or Friends
"""
type Organisation {
  hypi: Hypi
  name: String!
  logo: Image
  incorporated: DateTime
  addresses(arcql: String, first: Int, after: String, last: Int, before: String): [Address!]
  phones(arcql: String, first: Int, after: String, last: Int, before: String): [Phone!]
  emails(arcql: String, first: Int, after: String, last: Int, before: String): [Email!]
  members(arcql: String, first: Int, after: String, last: Int, before: String): [Account!]
  subsidiaries(arcql: String, first: Int, after: String, last: Int, before: String): [Organisation!]
}

type StripeFraudDetailsAggs {
  stripe_report: AggOtherScalar
  user_report: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type WorkflowSession {
  hypi: Hypi
  data(arcql: String, first: Int, after: String, last: Int, before: String): [WorkflowStepData!]
}

input HttpResponseInput {
  headers: Json
  rawPayload: String
  hypi: HypiInput
  status: Int
}

input WorkflowRepeatableInputOpt {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInputOpt
  repeatN: Int
  steps: [WorkflowStepInputOpt]
  cronSchedule: String
  repeatIf: GraphQLRefInputOpt
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInputOpt
  evaluateIf: GraphQLRefInputOpt
  order: Int
}

input StripeRefundInput {
  hypi: HypiInput
  id: String
  object: String
}

"""See https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo"""
type PageInfo {
  hypi: Hypi
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: ID!

  """relay modern - https://relay.dev/graphql/connections.htm#note-95f8a"""
  endCursor: ID!

  """
  relay modern
  If present, is the page size that is used to generate the previousOffsets and nextOffsets if they're present
  """
  pageLimit: Int

  """
  If present, contains the pagination cursors that can be used to get the previous N pages
  """
  previousOffsets: [String!]

  """
  If present, contains the pagination cursors that can be used to get the next N pages
  """
  nextOffsets: [String!]
}

input GeoInput {
  envelope: GeoEnvelopeInput
  hypi: HypiInput
  srid: Int
}

type AuthClientAggs {
  name: AggOtherScalar
  secret: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

enum PolicyBoundary {
  PLATFORM
  INSTANCE
  RESOURCE
}

input EmailSendingAttemptInputOpt {
  hypi: HypiInputOpt
  headers: Json
  body: Json
  status: EmailEventType
  statusMessage: String
}

input LogMessageInputOpt {
  hypi: HypiInputOpt
  level: LogLevel
  message: String
  stackTrace: String
  releaseId: String
  type: String
  workflow: String
}

"""Scalar fields defined by StripePrice"""
enum StripePriceScalarFields {
  """Unique identifier for the object."""
  id

  """Whether the price can be used for new purchases."""
  active

  """
  Three letter ISO currency code (https://www.iso.org/iso-4217-currency-codes.html). Must be a supported currency (https://stripe.com/docs/currencies)
  """
  currency

  """
  Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
  """
  metadata

  """A brief description of the plan, hidden from customers."""
  nickname
  type

  """
  The unit amount in cents (or local currency equivalent) to be charged, represented as a whole integer if possible.
  """
  unit_amount

  """
  String representing the object’s type. Objects of the same type share the same value.
  """
  object

  """
  Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
  """
  billing_scheme
  created

  """
  Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  """
  live_mode

  """A lookup key used to retrieve prices dynamically from a static string."""
  lookup_key

  """
  Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price. In graduated tiering, pricing can change as the quantity grows.
  """
  tiers_mode

  """
  The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.
  """
  unit_amount_decimal
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input GeoEnvelopeGroupByOptions {
  """The field by which to to group the matching data"""
  field: GeoEnvelopeScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input EmailGroupByOptions {
  """The field by which to to group the matching data"""
  field: EmailScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by Webhook"""
enum WebhookFields {
  hypi

  """
  The name by which this web hook is referenced in the URL, if missing the webhook is only adressable by ID
  """
  name

  """
   Defaults to the account creating the Webhook.
   Hypi will generate an authorisation token automatically for the account when the web hook is triggered.
   This token will then be used to execute the triggers in the web hook (query or mutation).
   For security an account should be created specifically for invoking web hooks and an AccountPolicy should be created that grants access only to the specified functions or otherwise limit the scope of what the account can do.
   
  """
  as

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_hypi

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_type

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_field

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_selection
}

type StripeTaxAmountAggs {
  amount: AggInt
  inclusive: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All numeric fields defined by StripeChargeOutcome"""
enum StripeChargeOutcomeNumericFields {
  risk_score
}

type StripeFpx {
  hypi: Hypi
  bank: StripeFpxBank
}

input WorkflowStepInput {
  hypi: HypiInput
  name: String
  fn: GraphQLRefInput!
  order: Int!
  execAs: String
  async: Boolean
  maxExecutionTime: String
  repeatN: Int
  evaluateIf: GraphQLRefInput
  repeatIf: GraphQLRefInput
}

input VideoInput {
  hypi: HypiInput
  name: String!
  thumbnails: [ImageInput!]
  file: FileInput!
  description: String
  location: GeoInput
}

input LogMessageGroupByOptions {
  """The field by which to to group the matching data"""
  field: LogMessageScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeOrderInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input RealmGroupByOptions {
  """The field by which to to group the matching data"""
  field: RealmScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeInvoiceLineItemAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type InvoiceItemAggs {
  name: AggOtherScalar
  description: AggOtherScalar
  type: AggOtherScalar
  quantity: AggFloat
  unit: AggOtherScalar
  vat: AggFloat
  is_percentage: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type RecommendationTrainer {
  hypi: Hypi
  maxIterations: Int!
  minMdlImprovement: Float!
  batchSize: Int!
  learningRate: Int!
}

input StripeChargeOutcomeInput {
  hypi: HypiInput
  network_status: StripeNetworkStatus
  reason: String
  risk_level: String
  risk_score: Int
  rule: String
  seller_message: String
  type: StripeOutcomeType
  paid: Boolean
  payment_method: StripePaymentMethodInput
  receipt_number: String
  receipt_url: String
  refunds: [StripeRefundInput]
  review: String
}

type ClientPolicyAggs {
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input PairInputOpt {
  hypi: HypiInputOpt
  key: String
  value: String
}

"""Scalar fields defined by StripeRedirectToUrl"""
enum StripeRedirectToUrlScalarFields {
  return_url
  url
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.

https://stripe.com/docs/api/subscription_schedules
"""
type StripeSubscriptionSchedule {
  hypi: Hypi
  id: String
  object: String
  current_phase: StripeSubscriptionPhase
  customer: StripeCustomer
  metadata: Json
  status: StripeSubscriptionScheduleStatus
  subscription: StripeSubscription
  canceled_at: Int
  completed_at: Int
  created: Int
  default_settings: StripeSubscriptionScheduleSettings
  end_behavior: StripeSubscriptionScheduleBehavior
  livemode: Boolean
  released_at: Int
  released_subscription: StripeSubscription
  phases(arcql: String, first: Int, after: String, last: Int, before: String): [StripeSubscriptionPhase!]
}

input StripeReviewGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeReviewScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input ClientPolicyInputOpt {
  hypi: HypiInputOpt
  clients: [AuthClientInputOpt]
  name: String
  logic: AuthLogic
}

"""All fields defined by StripeDiscount"""
enum StripeDiscountFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeCustomerPortalInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input CountryInput {
  hypi: HypiInput
  name: String!
  stateName: String
  sovereignty: String
  alpha2code: String
  alpha3code: String
  numericCode: String
  subdivisionCodeLinks: String
  internetCCTLD: String
  continent: String
  currencies: [CurrencyInput!]
  languagesSpoken: [LanguageInput!]
  officialLanguage: LanguageInput
}

input StripeBacsDebitInput {
  hypi: HypiInput
  fingerprint: String
  last4: String
  sort_code: String
}

type OrganisationAggs {
  name: AggOtherScalar
  incorporated: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input PersonInputOpt {
  hypi: HypiInputOpt
  names: [PersonNameInputOpt]
  addresses: [AddressInputOpt]
  phones: [PhoneInputOpt]
  dob: DateTime
  gender: Gender
  avatar: ImageInputOpt
  roles: [PairInputOpt]
  preferences: [PairInputOpt]
}

input StripeChargeOutcomeGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeChargeOutcomeScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by Hypi"""
enum HypiFields {
  """
  An ID automatically generated by the platform for new objects.
  If provided and the ID does not exist, the provided ID is used instead of a generated one and a new entry is inserted
  If provided and the ID already exists then the existing object is updated.
  """
  id

  """
  When you work with interface fields, Hypi is unable to distinguish which implementation you intend to use
  automatically, you must set this field to the name of the implementation of the interface e.g.
  If creating an AccountPolicy which implements the Policy interface, this field should be set to AccountPolicy
  """
  impl

  """The ISO8601 date of when the object was created"""
  created

  """The ISO8601 date of when the object was last modified"""
  updated

  """
  The ISO8601 date of when the object was trashed (if it is currently trashed, null otherwise)
  """
  trashed

  """The ID of the account which created the object"""
  createdBy

  """The ID of the app instance which created and owns the object"""
  instanceId
  tags
}

input RequestTemplateInput {
  hypi: HypiInput
  name: String!
  request: String
  response: String
}

"""All fields defined by BruteForceDetectionOptions"""
enum BruteForceDetectionOptionsFields {
  hypi
  maxLoginFailures

  """How long the user ust wait when maxLoginFailures have been reached"""
  waitIncrements
  waitIncrementsUnit

  """
  If login failures occurr too quickly, lock out the user, this sets number of milliseconds that determine "quickly"
  """
  quickLoginCheckMillis

  """How long to wait after a quick failure lock out"""
  minQuickLoginWait
  minQuickLoginWaitUnit

  """max time a user will be locked out for"""
  maxWait
  maxWaitUnit

  """When failure count is reset"""
  failureReset
  failureResetUnit
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeReview"""
enum StripeReviewScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input GeoInputOpt {
  envelope: GeoEnvelopeInputOpt
  hypi: HypiInputOpt
  srid: Int
}

input HttpResponseInputOpt {
  headers: Json
  rawPayload: String
  hypi: HypiInputOpt
  status: Int
}

"""All fields defined by StripePlan"""
enum StripePlanFields {
  hypi
  id
  object
  active
  billing_scheme
  created
  currency
  interval
  interval_count
  livemode
  metadata
  product
  tiers_mode
  usage_type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""JSON scalar"""
scalar Json

input AccessTokenGroupByOptions {
  """The field by which to to group the matching data"""
  field: AccessTokenScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeCardPresent"""
enum StripeCardPresentFields {
  hypi
  brand
  cardholder_name
  country
  emv_auth_data
  exp_month
  exp_year
  fingerprint
  funding
  generated_card
  last4
  network
  read_method
  receipt
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input PasswordInputOpt {
  hypi: HypiInputOpt
  value: String
  expired: Boolean
}

input ProductInput {
  hypi: HypiInput
  title: String!
  description: String!
  price: Float
}

"""Scalar fields defined by StripeBillingDetails"""
enum StripeBillingDetailsScalarFields {
  """Email address."""
  email

  """Full name."""
  name

  """Billing phone number (including extension)."""
  phone
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All numeric fields defined by StripeSubscriptionUpdate"""
enum StripeSubscriptionUpdateNumericFields {
  billing_cycle_anchor
  expires_at
  trial_end
}

type RealmPolicyAggs {
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
Subscriptions allow you to charge a customer on a recurring basis.

https://stripe.com/docs/api/subscriptions
"""
type StripeSubscription {
  hypi: Hypi
  id: String
  object: String
  cancel_at_period_end: Boolean
  current_period_end: Int
  current_period_start: Int
  customer: StripeCustomer
  default_payment_method: StripePaymentMethod
  latest_invoice: StripeInvoice
  metadata: Json
  pending_setup_intent: StripeSetupIntent
  pending_update: StripeSubscriptionUpdate
  status: StripeSubscriptionStatus
  billing_cycle_anchor: Int
  billing_thresholds: StripeBillingThreshold
  cancel_at: Int
  canceled_at: Int
  collection_method: StripeCollectionMethod
  created: Int
  days_until_due: Int
  default_source: StripeSource
  discount: StripeDiscount
  ended_at: Int
  livemode: Boolean
  next_pending_invoice_item_invoice: Int
  pause_collection: StripePauseCollection
  pending_invoice_item_interval: StripeIntervalObject
  schedule: StripeSubscriptionSchedule
  start_date: Int
  trial_end: Int
  trial_start: Int
  items(arcql: String, first: Int, after: String, last: Int, before: String): [StripeSubscriptionItem]
  default_tax_rates(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxRate!]
}

"""Scalar fields defined by StripeStatusTransitions"""
enum StripeStatusTransitionsScalarFields {
  finalized_at
  marked_uncollectible_at
  paid_at
  voided_at
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by PasswordReminder"""
enum PasswordReminderFields {
  hypi

  """If true the reset code has not yet been used."""
  valid

  """
  The verification code that is included in the email sent. Generated by the server, if provided the provided value is ignored
  """
  code

  """The Account email that needs to be changed"""
  to

  """
  Optionally, the email from which the email will be sent. You MUST have a Hypi email app configured to send from this address
  """
  from

  """
  Optionally, the subject of the email, this is a velocity template - Hypi provides a default such as "Please verify your email to <realm>"
  """
  subject

  """
   The HTML contents of the email. This is a Velocity template that will be rendered before being sent.
   The available variables and their types are:
   instance: AppId - You app instance ID
   parent - a map representing the current EmailVerification object
   value - the value of the htmlMessage field
   env: HypiEnv
   
  """
  htmlMessage

  """
  A plain text version of the email - see this is a velocity template, see htmlMessage for available variables
  """
  plainTextMessage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags

  """The Account email that needs to be changed"""
  to_hypi

  """The Account email that needs to be changed"""
  to_value

  """The Account email that needs to be changed"""
  to_type
}

type StripeCustomerAcceptanceAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeUsageRecordAggs {
  id: AggOtherScalar
  quantity: AggInt
  timestamp: AggInt
  object: AggOtherScalar
  livemode: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type Person {
  hypi: Hypi
  dob: DateTime
  gender: Gender
  avatar: Image
  names(arcql: String, first: Int, after: String, last: Int, before: String): [PersonName!]!
  addresses(arcql: String, first: Int, after: String, last: Int, before: String): [Address!]
  phones(arcql: String, first: Int, after: String, last: Int, before: String): [Phone!]
  roles(arcql: String, first: Int, after: String, last: Int, before: String): [Pair!]
  preferences(arcql: String, first: Int, after: String, last: Int, before: String): [Pair!]
}

input PasswordReminderInput {
  hypi: HypiInput
  valid: Boolean
  code: String
  to: EmailInput!
  from: String
  subject: String
  htmlMessage: String
  plainTextMessage: String
}

"""Scalar fields defined by NotificationCtx"""
enum NotificationCtxScalarFields {
  """The type that the notification applies to"""
  type
  targetAccount
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeCardPresent {
  hypi: Hypi
  brand: String
  cardholder_name: String
  country: String
  emv_auth_data: String
  exp_month: Int
  exp_year: Int
  fingerprint: String
  funding: StripeFunding
  generated_card: String
  last4: String
  network: StripeNetwork
  read_method: StripeReadMethod
  receipt: StripeReceipt
}

input ClientPolicyInput {
  hypi: HypiInput
  clients: [AuthClientInput!]
  name: String!
  logic: AuthLogic
}

"""All fields defined by StripeTaxAmount"""
enum StripeTaxAmountFields {
  hypi
  amount
  inclusive
  tax_rate
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by TrainingInstance"""
enum TrainingInstanceFields {
  hypi
  model
  status
  errors
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripePriceRecurrence"""
enum StripePriceRecurrenceScalarFields {
  """
  Specifies a usage aggregation strategy for prices of usage_type=metered
  """
  aggregate_usage

  """The frequency at which a subscription is billed."""
  interval

  """
  The number of intervals (specified in the interval attribute) between subscription billings. For example, interval=month and interval_count=3 bills every 3 months.
  """
  interval_count

  """
  Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
  """
  usage_type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeMandate"""
enum StripeMandateFields {
  hypi
  id
  customer_acceptance
  payment_method
  payment_method_details
  status
  type
  object
  livemode
  multi_use
  single_use
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePaymentMethodInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  billing_details: StripeBillingDetailsInputOpt
  customer: StripeCustomerInputOpt
  metadata: Json
  type: StripePaymentMethds
  alipay: String
  au_becs_debit: StripeAuBecsDebitInputOpt
  bacs_debit: StripeBacsDebitInputOpt
  bancontact: String
  card: String
  card_present: StripeCardPresentInputOpt
  created: Int
  eps: String
  fpx: StripeFpxInputOpt
  giropay: String
  ideal: StripeIdealInputOpt
  interac_present: String
  livemode: Boolean
  oxxo: String
  p24: String
  sepa_debit: StripeSebaDebitInputOpt
  sofort: StripeSofortInputOpt
}

"""All fields defined by StripeBillingDetails"""
enum StripeBillingDetailsFields {
  hypi

  """Billing address."""
  address

  """Email address."""
  email

  """Full name."""
  name

  """Billing phone number (including extension)."""
  phone
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by EmailTemplate"""
enum EmailTemplateFields {
  hypi

  """
   Name of the template being created. The name can contain alpha-numeric characters, digits and next symbols: .-_~
   
  """
  name
  description
  template
  comment
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripePauseCollection"""
enum StripePauseCollectionFields {
  hypi
  behavior
  resumes_at
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input RealmPolicyInput {
  hypi: HypiInput
  realms: [RealmLinkInput!]
  name: String!
  logic: AuthLogic
}

"""Scalar fields defined by Person"""
enum PersonScalarFields {
  dob
  gender
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by GroupPolicy"""
enum GroupPolicyScalarFields {
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripePeriodGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePeriodScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type URL {
  hypi: Hypi
  path: String!
  queryParams: Json
  port: Int
  host: String
}

"""A list of types on which mutations can be performed on"""
input HypiUpsertInputUnion {
  Product: [ProductInputOpt!]
  Pair: [PairInputOpt!]
  Script: [ScriptInputOpt!]
  RequestTemplate: [RequestTemplateInputOpt!]
  NotificationCtx: [NotificationCtxInputOpt!]
  Notification: [NotificationInputOpt!]
  URL: [URLInputOpt!]
  Currency: [CurrencyInputOpt!]
  Coordinate: [CoordinateInputOpt!]
  GeoEnvelope: [GeoEnvelopeInputOpt!]
  Language: [LanguageInputOpt!]
  Address: [AddressInputOpt!]
  PersonName: [PersonNameInputOpt!]
  Phone: [PhoneInputOpt!]
  Email: [EmailInputOpt!]
  Password: [PasswordInputOpt!]
  RemoteLogin: [RemoteLoginInputOpt!]
  LoginAttempt: [LoginAttemptInputOpt!]
  BruteForceDetectionOptions: [BruteForceDetectionOptionsInputOpt!]
  OAuth2AuthorizedClient: [OAuth2AuthorizedClientInputOpt!]
  AuthClient: [AuthClientInputOpt!]
  ABACPolicy: [ABACPolicyInputOpt!]
  ABACTag: [ABACTagInputOpt!]
  Image: [ImageInputOpt!]
  EmailVerification: [EmailVerificationInputOpt!]
  EmailTemplate: [EmailTemplateInputOpt!]
  EmailSendingAttempt: [EmailSendingAttemptInputOpt!]
  PasswordReminder: [PasswordReminderInputOpt!]
  Webhook: [WebhookInputOpt!]
  WebhookResponse: [WebhookResponseInputOpt!]
  LogMessage: [LogMessageInputOpt!]
  GraphQLRef: [GraphQLRefInputOpt!]
  WorkflowStepData: [WorkflowStepDataInputOpt!]
  WorkflowStep: [WorkflowStepInputOpt!]
  AccessToken: [AccessTokenInputOpt!]
  StorageCounter: [StorageCounterInputOpt!]
  Hypi: [HypiInputOpt!]
  Country: [CountryInputOpt!]
  Account: [AccountInputOpt!]
  Person: [PersonInputOpt!]
  Organisation: [OrganisationInputOpt!]
  OAuthProvider: [OAuthProviderInputOpt!]
  Realm: [RealmInputOpt!]
  Group: [GroupInputOpt!]
  Role: [RoleInputOpt!]
  RolePolicy: [RolePolicyInputOpt!]
  ClientPolicy: [ClientPolicyInputOpt!]
  TimePolicy: [TimePolicyInputOpt!]
  AggregatedPolicy: [AggregatedPolicyInputOpt!]
  GroupPolicy: [GroupPolicyInputOpt!]
  AccountPolicy: [AccountPolicyInputOpt!]
  RealmPolicy: [RealmPolicyInputOpt!]
  RealmLink: [RealmLinkInputOpt!]
  Permission: [PermissionInputOpt!]
  File: [FileInputOpt!]
  Video: [VideoInputOpt!]
  EmailMessage: [EmailMessageInputOpt!]
  Workflow: [WorkflowInputOpt!]
  WorkflowSession: [WorkflowSessionInputOpt!]
  Counter: [CounterInputOpt!]
  Gauge: [GaugeInputOpt!]
  ServerlessResponse: [ServerlessResponseInputOpt!]
  LearningEnvironment: [LearningEnvironmentInputOpt!]
  RecommendationModel: [RecommendationModelInputOpt!]
  KMeanCLusteringModel: [KMeanCLusteringModelInputOpt!]
  RecommendationTrainer: [RecommendationTrainerInputOpt!]
  ObjectSubjectRatingTriplet: [ObjectSubjectRatingTripletInputOpt!]
  PredictionData: [PredictionDataInputOpt!]
  TrainingInstance: [TrainingInstanceInputOpt!]
  InvoiceItem: [InvoiceItemInputOpt!]
  PricePlanInclusion: [PricePlanInclusionInputOpt!]
  StripeOrder: [StripeOrderInputOpt!]
  StripeReview: [StripeReviewInputOpt!]
  StripeTransfer: [StripeTransferInputOpt!]
  StripeTransferData: [StripeTransferDataInputOpt!]
  StripeFraudDetails: [StripeFraudDetailsInputOpt!]
  StripeShippingInfo: [StripeShippingInfoInputOpt!]
  StripeBillingDetails: [StripeBillingDetailsInputOpt!]
  StripeAddress: [StripeAddressInputOpt!]
  StripeDispute: [StripeDisputeInputOpt!]
  StripeEvent: [StripeEventInputOpt!]
  StripeMandate: [StripeMandateInputOpt!]
  StripePaymentMethodDetails: [StripePaymentMethodDetailsInputOpt!]
  StripeCustomerAcceptance: [StripeCustomerAcceptanceInputOpt!]
  StripePayout: [StripePayoutInputOpt!]
  StripePackageDimensions: [StripePackageDimensionsInputOpt!]
  StripeTransformQuantity: [StripeTransformQuantityInputOpt!]
  StripeTier: [StripeTierInputOpt!]
  StripePriceRecurrence: [StripePriceRecurrenceInputOpt!]
  StripeRefund: [StripeRefundInputOpt!]
  StripePaymentMethod: [StripePaymentMethodInputOpt!]
  StripeSebaDebit: [StripeSebaDebitInputOpt!]
  StripeIdeal: [StripeIdealInputOpt!]
  StripeFpx: [StripeFpxInputOpt!]
  StripeCardPresent: [StripeCardPresentInputOpt!]
  StripeReceipt: [StripeReceiptInputOpt!]
  StripeBacsDebit: [StripeBacsDebitInputOpt!]
  StripeAuBecsDebit: [StripeAuBecsDebitInputOpt!]
  StripeBankAccount: [StripeBankAccountInputOpt!]
  StripeSource: [StripeSourceInputOpt!]
  StripeCoupon: [StripeCouponInputOpt!]
  StripeCreditNote: [StripeCreditNoteInputOpt!]
  StripeCustomerBalanceTransaction: [StripeCustomerBalanceTransactionInputOpt!]
  StripeCustomerPortal: [StripeCustomerPortalInputOpt!]
  StripeTaxId: [StripeTaxIdInputOpt!]
  StripeDiscount: [StripeDiscountInputOpt!]
  StripeTaxAmount: [StripeTaxAmountInputOpt!]
  StripeDiscountAmount: [StripeDiscountAmountInputOpt!]
  StripeStatusTransitions: [StripeStatusTransitionsInputOpt!]
  StripeInvoiceLineItem: [StripeInvoiceLineItemInputOpt!]
  StripePeriod: [StripePeriodInputOpt!]
  StripePromotionCode: [StripePromotionCodeInputOpt!]
  StripeIntervalObject: [StripeIntervalObjectInputOpt!]
  StripePauseCollection: [StripePauseCollectionInputOpt!]
  StripePlan: [StripePlanInputOpt!]
  StripeBillingThreshold: [StripeBillingThresholdInputOpt!]
  StripeSubscriptionScheduleSettings: [StripeSubscriptionScheduleSettingsInputOpt!]
  StripeInvoiceSettings: [StripeInvoiceSettingsInputOpt!]
  StripeTaxRate: [StripeTaxRateInputOpt!]
  StripeUsageRecord: [StripeUsageRecordInputOpt!]
  StripeCheckoutSession: [StripeCheckoutSessionInputOpt!]
  StripeError: [StripeErrorInputOpt!]
  StripeNextAction: [StripeNextActionInputOpt!]
  StripeAliPayHandleRedirect: [StripeAliPayHandleRedirectInputOpt!]
  StripeOxxoDisplayDetails: [StripeOxxoDisplayDetailsInputOpt!]
  StripeRedirectToUrl: [StripeRedirectToUrlInputOpt!]
  StripeSofort: [StripeSofortInputOpt!]
  StripeReference: [StripeReferenceInputOpt!]
  Invoice: [InvoiceInputOpt!]
  PricePlanAllowance: [PricePlanAllowanceInputOpt!]
  PricePlan: [PricePlanInputOpt!]
  StripeCharge: [StripeChargeInputOpt!]
  StripeChargeOutcome: [StripeChargeOutcomeInputOpt!]
  StripeCustomer: [StripeCustomerInputOpt!]
  StripeProduct: [StripeProductInputOpt!]
  StripePrice: [StripePriceInputOpt!]
  StripeInvoice: [StripeInvoiceInputOpt!]
  StripeThesholdReason: [StripeThesholdReasonInputOpt!]
  StripeItemReason: [StripeItemReasonInputOpt!]
  StripeInvoiceItem: [StripeInvoiceItemInputOpt!]
  StripeSubscription: [StripeSubscriptionInputOpt!]
  StripeSubscriptionUpdate: [StripeSubscriptionUpdateInputOpt!]
  StripeSubscriptionItem: [StripeSubscriptionItemInputOpt!]
  StripeSubscriptionSchedule: [StripeSubscriptionScheduleInputOpt!]
  StripeSubscriptionPhase: [StripeSubscriptionPhaseInputOpt!]
  StripePaymentIntent: [StripePaymentIntentInputOpt!]
  StripeSetupIntent: [StripeSetupIntentInputOpt!]
}

"""All fields defined by StripeProduct"""
enum StripeProductFields {
  hypi
  id
  active
  description
  metadata
  name
  object
  caption
  created
  livemode
  url
  updated
  unit_label
  statement_descriptor
  shippable
  package_dimensions
  attributes
  deactivate_on
  images
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by AggFloat"""
enum AggFloatFields {
  hypi

  """The value of the aggregated field for each group"""
  groupValues
  avg
  count
  max
  min
  sum
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags

  """The value of the aggregated field for each group"""
  groupValues_hypi

  """The value of the aggregated field for each group"""
  groupValues_key

  """The value of the aggregated field for each group"""
  groupValues_value
}

input StripeInvoiceSettingsInput {
  hypi: HypiInput
  days_until_due: Int
}

"""All fields defined by RecommendationTrainer"""
enum RecommendationTrainerFields {
  hypi
  maxIterations
  minMdlImprovement
  batchSize
  learningRate
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeSubscriptionGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSubscriptionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by URL"""
enum URLNumericFields {
  port
}

""" Mandate is a record of the permission a customer has given you to debit their payment method.
"""
type StripeMandate {
  hypi: Hypi
  id: String
  customer_acceptance: StripeCustomerAcceptance
  payment_method: StripePaymentMethod
  payment_method_details: StripePaymentMethodDetails
  status: StripeMandateStatus
  type: StripeMandateType
  object: String
  livemode: Boolean
  multi_use: String
  single_use: String
}

type StripeIdeal {
  hypi: Hypi
  bank: StripeIdealBank
  bic: String
}

input StripeBankAccountInput {
  hypi: HypiInput
  id: String
  object: String
}

type AggFloat {
  hypi: Hypi

  """The value of the aggregated field for each group"""
  groupValues: [Pair]
  avg(distinct: Boolean): Float
  count(distinct: Boolean): Int
  max: Float
  min: Float
  sum(distinct: Boolean): Float
}

"""All fields defined by StripePrice"""
enum StripePriceFields {
  hypi

  """Unique identifier for the object."""
  id

  """Whether the price can be used for new purchases."""
  active

  """
  Three letter ISO currency code (https://www.iso.org/iso-4217-currency-codes.html). Must be a supported currency (https://stripe.com/docs/currencies)
  """
  currency

  """
  Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
  """
  metadata

  """A brief description of the plan, hidden from customers."""
  nickname

  """
  In Stripe this is the ID of the product this price is associated with.
  In Hypi it links directly to the price object
  """
  product

  """The recurring components of a price such as interval and usage_type."""
  recurring
  type

  """
  The unit amount in cents (or local currency equivalent) to be charged, represented as a whole integer if possible.
  """
  unit_amount

  """
  String representing the object’s type. Objects of the same type share the same value.
  """
  object

  """
  Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
  """
  billing_scheme
  created

  """
  Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  """
  live_mode

  """A lookup key used to retrieve prices dynamically from a static string."""
  lookup_key

  """
  Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price. In graduated tiering, pricing can change as the quantity grows.
  """
  tiers_mode

  """
  Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with tiers.
  """
  transform_quantity

  """
  The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.
  """
  unit_amount_decimal
  tiers
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeTransformQuantity {
  hypi: Hypi

  """Divide usage by this number."""
  divide_by: Int

  """After division, either round the result up or down."""
  round: StripeTransformRounding
}

input PricePlanAllowanceInputOpt {
  hypi: HypiInputOpt
  accessible_to: [AccountInputOpt]
  inclusions: [PricePlanInclusionInputOpt]
  unit: TimeUnit
  allow_overage: Boolean
  allowed_overage_amount: Float
  allowed_overage_is_percentage: Boolean
}

type StripePlan {
  hypi: Hypi
  id: String
  object: String
  active: Boolean
  billing_scheme: StripeBillingScheme
  created: Int
  currency: String
  interval: StripeInterval
  interval_count: Int
  livemode: Boolean
  metadata: Json
  product: String
  tiers_mode: StripeTierMode
  usage_type: StripeUsageType
}

input StripeIntervalObjectInput {
  hypi: HypiInput
  interval: StripeInterval
  interval_count: Int
}

type StripeSubscriptionScheduleSettingsAggs {
  billing_cycle_anchor: AggOtherScalar
  collection_method: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeAddressInputOpt {
  hypi: HypiInputOpt
  line1: String
  line2: String
  city: String
  country: String
  state: String
  postal_code: String
}

input EmailTemplateInput {
  hypi: HypiInput
  name: String
  description: String
  template: String
  comment: String
}

"""All fields defined by LogMessage"""
enum LogMessageFields {
  hypi
  level
  message
  stackTrace

  """Optional, may not be a stacktrace"""
  releaseId

  """This is optional, we can have system messages that aren't from an app"""
  type

  """
  The name of the GraphQL type that the log is for, this is also optional
  """
  workflow
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type OAuth2AuthorizedClient {
  hypi: Hypi
  clientRegistrationId: String
  principalName: String
  accessToken: String
  refreshToken: String
}

"""Scalar fields defined by Coordinate"""
enum CoordinateScalarFields {
  x
  y
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by PricePlan"""
enum PricePlanScalarFields {
  billing_frequency

  """
  Remote card ID e.g. Stripe, BrainTree or other third party card ID that this plan bills
  In invoices create credit on the price plan then payment is made to this card
  """
  default_card
  valid_from
  valid_to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeTaxRateAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All numeric fields defined by StripePlan"""
enum StripePlanNumericFields {
  created
  interval_count
}

type WorkflowStep implements WorkflowAsync & WorkflowTimed & WorkflowRepeatable & WorkflowConditional & WorkflowExecutableAs & WorkflowOrdered {
  hypi: Hypi

  """A name that can be used to reference or trigger this step"""
  name: String

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn: GraphQLRef!
  order: Int!

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs: String
  async: Boolean

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime: String
  repeatN: Int
  evaluateIf: GraphQLRef
  repeatIf: GraphQLRef
}

input ClientPolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: ClientPolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""
Published as part of a subscription event's meta data to indicate the nature of the mutation that resulted in the event being triggered.
"""
enum EventType {
  """
   An event type indicating that the cache entry was created.
   
  """
  CREATED

  """
   An event type indicating that the cache entry was updated. i.e. a previous mapping existed
   
  """
  UPDATED

  """
   An event type indicating that the cache entry was removed.
   
  """
  REMOVED

  """
   An event type indicating that the cache entry has expired.
   
  """
  EXPIRED
}

input PersonInput {
  hypi: HypiInput
  names: [PersonNameInput!]!
  addresses: [AddressInput!]
  phones: [PhoneInput!]
  dob: DateTime
  gender: Gender
  avatar: ImageInput
  roles: [PairInput!]
  preferences: [PairInput!]
}

input StripeSubscriptionScheduleGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSubscriptionScheduleScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeStatusTransitionsInputOpt {
  hypi: HypiInputOpt
  finalized_at: Int
  marked_uncollectible_at: Int
  paid_at: Int
  voided_at: Int
}

"""All fields defined by StripePromotionCode"""
enum StripePromotionCodeFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StorageCounterAggs {
  type: AggOtherScalar
  field: AggOtherScalar
  size: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeAuBecsDebit"""
enum StripeAuBecsDebitFields {
  hypi
  bsb_number
  fingerprint
  last4
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input KMeanCLusteringModelInput {
  hypi: HypiInput
  typeName: String!
  arcql: String
  name: String!
  description: String
  label: String
}

input AuthClientInputOpt {
  hypi: HypiInputOpt
  name: String
  secret: String
}

input Trigger {
  """
  Executes before the target function. Typically used for validation to prevent execution of a function.
  It MUST have the same arguments as the target function and return Boolean
  """
  before: GraphQLRefInput

  """
  Executed asynchronously after the target. It MUST have the same arguments as the target and can optionally
  have an argument called "hypiResult: T" where T is the type returned by the target
  """
  after: GraphQLRefInput
}

type Counter {
  hypi: Hypi

  """
  A name which uniquely identifies this counter in an instance. Must be a letter followed by 0 or more letters, numbers or underscores
  """
  name: String!

  """A human friendly display label for the counter"""
  label: String

  """
  The value of the counter. Semantically this is intended to be monotonically increasing but this is not currently enforced
  See the Gauge type if you want to arbitrarily increase/decrease/set value on a type
  """
  value: Float!
  tags(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
}

"""All numeric fields defined by InvoiceItem"""
enum InvoiceItemNumericFields {
  quantity
  vat
}

"""All fields defined by StripePeriod"""
enum StripePeriodFields {
  hypi
  start
  end
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripeTier"""
enum StripeTierFields {
  hypi

  """Price for the entire tier."""
  flat_amount

  """
  Same as flat_amount, but contains a decimal value with at most 12 decimal places.
  """
  flat_amount_decimal

  """Per unit price for units relevant to the tier."""
  unit_amount

  """
  Same as unit_amount, but contains a decimal value with at most 12 decimal places.
  """
  unit_amount_decimal

  """Up to and including to this quantity will be contained in the tier."""
  up_to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input AccountPolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: AccountPolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeCoupon"""
enum StripeCouponFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by OAuthProvider"""
enum OAuthProviderScalarFields {
  """ instanceId-(hypi.id = registrationId)"""
  clientId
  clientSecret
  clientAuthenticationMethod
  authorizationGrantType
  redirectUriTemplate
  authorizationUri
  tokenUri
  userInfoUri
  userInfoAuthenticationMethod
  userNameAttributeName
  jwkSetUri
  clientName
  hypiSuccessRedirectUri
  hypiFailureRedirectUri
  scopes
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeDisputeGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeDisputeScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeSofortAggs {
  country: AggOtherScalar
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePromotionCodeInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeShippingInfoInputOpt {
  hypi: HypiInputOpt
  address: StripeAddressInputOpt
  carrier: String
  name: String
  phone: String
  tracking_number: String
}

"""All numeric fields defined by StripeSubscriptionItem"""
enum StripeSubscriptionItemNumericFields {
  quantity
  created
}

"""Scalar fields defined by OAuth2AuthorizedClient"""
enum OAuth2AuthorizedClientScalarFields {
  clientRegistrationId
  principalName
  accessToken
  refreshToken
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by WorkflowStepData"""
enum WorkflowStepDataScalarFields {
  stepName
  stepResult
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by ObjectSubjectRatingTriplet"""
enum ObjectSubjectRatingTripletFields {
  hypi
  subjectId
  objectId
  rating
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input PricePlanAllowanceInput {
  hypi: HypiInput
  accessible_to: [AccountInput]
  inclusions: [PricePlanInclusionInput!]
  unit: TimeUnit
  allow_overage: Boolean
  allowed_overage_amount: Float
  allowed_overage_is_percentage: Boolean
}

"""Scalar fields defined by File"""
enum FileScalarFields {
  name
  directory
  path
  isDirectory
  status

  """mime type"""
  type
  size
  extension
  isStared
  isSharable
  content
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input RecommendationTrainerInput {
  hypi: HypiInput
  maxIterations: Int!
  minMdlImprovement: Float!
  batchSize: Int!
  learningRate: Int!
}

type RecommendationModel implements MLModel {
  hypi: Hypi
  env: LearningEnvironment
  trainer: RecommendationTrainer!
  type: String!
  ratingFieldName: String!
  subjectFieldName: String
  objectFieldName: String
  arcql: String
  name: String!
  description: String
  label: String
}

input StripeSourceInput {
  hypi: HypiInput
  id: String
  object: String
  client_secret: String
  reusable: Boolean
  livemode: Boolean
}

"""Scalar fields defined by Realm"""
enum RealmScalarFields {
  """
  the name identifying the organisation and becomes the URL by which it is accessed e.g. alpha-corp.hypi.app, where alpha-corp is name
  If not provided one will be automatically generated
  """
  name

  """The name displayed in the user interface"""
  displayName

  """If true users can register without an admin creating their account"""
  allowRegistrations

  """if true users must verify their email before they're allowed to login"""
  verifyEmail
  referrer
  remoteLoginId
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input PermissionInput {
  hypi: HypiInput
  name: String!
  policies: [PolicyInput!]
  decisionStrategy: DecisionStrategy
  type: String!
  scopes: [String!]!
  resource: String
  operationType: OpType!
  operations: [String]!
  includeAllAccounts: Boolean
}

type StripeBacsDebitAggs {
  fingerprint: AggOtherScalar
  last4: AggOtherScalar
  sort_code: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeAuBecsDebit {
  hypi: Hypi
  bsb_number: String
  fingerprint: String
  last4: String
}

input StripeSetupIntentMaths {
  created: MathInputInt
}

input StripeSourceGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSourceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeSubscriptionAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  cancel_at_period_end: AggOtherScalar
  current_period_end: AggInt
  current_period_start: AggInt
  metadata: AggOtherScalar
  status: AggOtherScalar
  billing_cycle_anchor: AggInt
  cancel_at: AggInt
  canceled_at: AggInt
  collection_method: AggOtherScalar
  created: AggInt
  days_until_due: AggInt
  ended_at: AggInt
  livemode: AggOtherScalar
  next_pending_invoice_item_invoice: AggInt
  start_date: AggInt
  trial_end: AggInt
  trial_start: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeTransferData {
  hypi: Hypi
  amount: Int
  destination: StripeCustomer
}

"""Scalar fields defined by GraphQLRef"""
enum GraphQLRefScalarFields {
  type
  field

  """
   If present this is a set of GraphQL fields that will be selected from the results of the function referenced.
   For example if the type returned by field is "T" and T is the object
   type T {
   a: Int
   b: T2
   }
   type T2 {
   c: String
   }
   then this field can be the selection string:
   a b{c}
   i.e. the GraphQL selection you would use if manually selecting fields from T and T2 WITHOUT any curly braces at the start/end - i.e. no enclosing curlies.
   If not provided, the platform will select hypi{id} meaning the result of this function call will have ONLY the hypi.id field
   
  """
  selection
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by Permission"""
enum PermissionScalarFields {
  name

  """defines how the policy arrives at a decision, defaults to Unanimous"""
  decisionStrategy

  """The type that this permission applies to"""
  type

  """
   If present then the scopes in this permission will have the given policies applied to this resource.
   This can be used for example to prevent mutation on a resource by a user, group etc
   
  """
  resource

  """Query, Mutation or Subscription"""
  operationType

  """
  If true, this permission grants/denies access to all accounts (including anonymous account)
  """
  includeAllAccounts
  scopes
  operations
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

enum StripeBillingScheme {
  per_unit
  tiered
}

input HypiInputOpt {
  id: ID
  impl: String
  created: DateTime
  updated: DateTime
  trashed: DateTime
  createdBy: ID
  instanceId: String
  tags: [ABACTagInputOpt]
}

"""Scalar fields defined by EmailMessage"""
enum EmailMessageScalarFields {
  subject

  """
  Name of the template to use, if present then the given template is used and text/html etc fields in this message are not used
  """
  template
  text
  html

  """
   Schedule sending in the future
   
  """
  deliveryTime

  """
   If set to True or yes this requires the message only be sent over a TLS connection. If a TLS connection can not be established, we will not deliver the message.
   If set to False or no, we will still try and upgrade the connection, if that fails the message will be delivered over a plaintext SMTP connection.
   
  """
  requireTls

  """
   If set to True or yes, the certificate and hostname will not be verified when trying to establish a TLS connection and Hypi will accept any certificate during delivery.
  
   If set to False or no, Hypi will verify the certificate and hostname. If either one can not be verified, a TLS connection will not be established.
  
   The default is False.
   
  """
  skipVerification

  """
   allows to append a custom MIME header to the message (X-My-Header in this case). For example, h:Reply-To to specify Reply-To address.
   
  """
  headers

  """
   prefix followed by an arbitrary name allows to attach a custom JSON data to the message. See Attaching Data to Messages for more information.
   
  """
  variables

  """
   A valid JSON-encoded dictionary, where key is a plain recipient address and value is a dictionary with variables that can be referenced in the message body.
   
  """
  recipientVariables
  tags
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  from_value
  from_type
  to_value
  to_type
  cc_value
  cc_type
  bcc_value
  bcc_type
}

"""Scalar fields defined by PredictionData"""
enum PredictionDataScalarFields {
  modelName
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type Mutation {
  """Removes the link between two objects WITHOUT deleting either object"""
  unlink(
    from: HypiMutationType!
    to: HypiMutationType!
    via: String!
    whereFromID: String!
    andToID: String!

    """The instance ID in which the from ID exists, defaults to this instance"""
    fromInstanceId: String

    """The instance ID in which the to ID exists, defaults to this instance"""
    toInstanceId: String
  ): Boolean!

  """
  Creates a relationship between two existing objects via some field on the source type
  """
  link(
    from: HypiMutationType!
    to: HypiMutationType!
    via: String!
    whereFromID: String!
    andToID: String!

    """The instance ID in which the from ID exists, defaults to this instance"""
    fromInstanceId: String

    """The instance ID in which the to ID exists, defaults to this instance"""
    toInstanceId: String
  ): Boolean!

  """
  Inserts or updates a set of values. To update an existing value provide the hypi.id
  """
  upsert(values: HypiUpsertInputUnion!): [Hypi!]!

  """
  Marks any object that matches the filter as NOT trash if they were previous trashed with the 'trash' function
  """
  untrash(type: HypiMutationType!, arcql: String!): Int!
  math(values: HypiMathType): [Hypi!]!

  """
  Deletes any objects matching the query up to a maximum of 25 (regardless of the first/last arguments if they are bigger than 25)
  """
  delete(
    type: HypiMutationType!
    arcql: String!

    """
    If true this acts as a 'light' cascade by deleting array references to the matched data.Only array references are deleted, one to one references will remain but will return null. A side effect of this behaviour is that if an object is re-created with the same hypi.id then the one to one references that were not cleared will automatically all point to the new object. This takes precedence over the 'enforceReferentialIntegrityOnDeletes' status set on the instance. Defaults to false
    """
    clearArrayReferences: Boolean = false
  ): Int!

  """
  Deletes the given scalar values from the object with the given ID from the field in the specified type
  """
  deleteScalars(
    """The type which contains the field from which you want to delete"""
    type: HypiMutationType!

    """The name of the scalar array field"""
    field: String!

    """The list of values you want to delete"""
    values: [String!]!

    """The query matching the objects to delete the values from"""
    arcql: String!
  ): Int!

  """
  Marks any object that matches the filter as trash. Those objects will not be returned in get or find queries unless they're marked as not trash later. Maximum of 25 will be trashed (regardless of the first/last arguments if they are bigger than 25)
  """
  trash(type: HypiMutationType!, arcql: String!): Int!

  """
  Used to perform registration of a new realm. Normally only Hypi directly calls this
  """
  createRealm(value: RealmInput!): Hypi

  """
  Creates a new account which can be used to login and perform various actions in a Realm
  """
  createAccount(value: AccountInput!): Hypi
  deleteModel(name: String!): Boolean
  startMLTraining(model: MLModelInput!): TrainingInstance
}

"""All fields defined by Coordinate"""
enum CoordinateFields {
  hypi
  x
  y
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeSubscriptionUpdateMaths {
  billing_cycle_anchor: MathInputInt
  expires_at: MathInputInt
  trial_end: MathInputInt
}

type File {
  hypi: Hypi
  name: String!
  directory: String!
  path: String!
  isDirectory: Boolean!
  status: FileStatus
  url: URL

  """mime type"""
  type: String
  size: Long
  extension: String
  isStared: Boolean
  isSharable: Boolean
  content: String
  children(arcql: String, first: Int, after: String, last: Int, before: String): [File!]
}

"""Scalar fields defined by PricePlanAllowance"""
enum PricePlanAllowanceScalarFields {
  """Time period in which this allowance is given"""
  unit

  """
  Globally control overage allowance - overridden by per inclusion overage settings.
  """
  allow_overage

  """If overage is allowed, how much is allowed?"""
  allowed_overage_amount

  """
  If overage is allowed and an amount is specified, is the amount a percentage?
  """
  allowed_overage_is_percentage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeBacsDebit"""
enum StripeBacsDebitFields {
  hypi
  fingerprint
  last4
  sort_code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeBillingThresholdInputOpt {
  hypi: HypiInputOpt
  usage_gte: Int
  amount_gte: Int
  reset_billing_cycle_anchor: Boolean
}

"""
Each customer has a balance value, which denotes a debit or credit that's automatically applied to their next invoice upon finalization. You may modify the value directly by using the update customer API, or by creating a Customer Balance Transaction, which increments or decrements the customer's balance by the specified amount.
https://stripe.com/docs/api/customer_balance_transactions
"""
type StripeCustomerBalanceTransaction {
  hypi: Hypi
  id: String
  object: String
}

input StripeCardPresentMaths {
  exp_month: MathInputInt
  exp_year: MathInputInt
}

type StripeCustomerAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  description: AggOtherScalar
  email: AggOtherScalar
  metadata: AggOtherScalar
  name: AggOtherScalar
  phone: AggOtherScalar
  balance: AggInt
  created: AggInt
  currency: AggOtherScalar
  delinquent: AggOtherScalar
  invoice_prefix: AggOtherScalar
  livemode: AggOtherScalar
  next_invoice_sequence: AggInt
  source: AggOtherScalar
  tax_exempt: AggOtherScalar
  preferred_locales: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeInvoiceMaths {
  period_end: MathInputInt
  period_start: MathInputInt
  total: MathInputInt
  amount_due: MathInputInt
  amount_paid: MathInputInt
  amount_remaining: MathInputInt
  attempt_count: MathInputInt
  created: MathInputInt
  due_date: MathInputInt
  ending_balance: MathInputInt
  next_payment_attempt: MathInputInt
  post_payment_credit_notes_amount: MathInputInt
  pre_payment_credit_notes_amount: MathInputInt
  starting_balance: MathInputInt
  subscription_proration_date: MathInputInt
  subtotal: MathInputInt
  tax: MathInputInt
  webhooks_delivered_at: MathInputInt
}

type StripeChargeAggs {
  id: AggOtherScalar
  amount: AggFloat
  currency: AggOtherScalar
  description: AggOtherScalar
  disputed: AggOtherScalar
  metadata: AggOtherScalar
  receipt_email: AggOtherScalar
  refund: AggOtherScalar
  statement_descriptor: AggOtherScalar
  statement_descriptor_suffix: AggOtherScalar
  status: AggOtherScalar
  object: AggOtherScalar
  amount_refunded: AggInt
  application: AggOtherScalar
  application_fee: AggOtherScalar
  application_fee_amount: AggInt
  calculated_statement_descriptor: AggOtherScalar
  captured: AggOtherScalar
  created: AggOtherScalar
  failure_code: AggOtherScalar
  failure_message: AggOtherScalar
  live_mode: AggOtherScalar
  on_behalf_of: AggOtherScalar
  paid: AggOtherScalar
  payment_method: AggOtherScalar
  receipt_number: AggOtherScalar
  receipt_url: AggOtherScalar
  source_transfer: AggOtherScalar
  transfer_group: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
Any scalar. DO NOT USE except in extremely rare cases where it is unavoidable to do so
"""
scalar Any

type StripeThesholdReason {
  hypi: Hypi
  amount_gte: Int
  item_reasons(arcql: String, first: Int, after: String, last: Int, before: String): [StripeItemReason!]
}

"""All numeric fields defined by StripeSubscriptionSchedule"""
enum StripeSubscriptionScheduleNumericFields {
  canceled_at
  completed_at
  created
  released_at
}

interface WorkflowParallel {
  hypi: Hypi

  """
  If present AND true, all steps in this block are executed at the same time.
  """
  parallel: Boolean
}

"""Scalar fields defined by StripeChargeOutcome"""
enum StripeChargeOutcomeScalarFields {
  network_status

  """
  An enumerated value providing a more detailed explanation of the outcome’s type. Charges blocked by Radar’s default block rule have the value highest_risk_level. Charges placed in review by Radar’s default review rule have the value elevated_risk_level.
  """
  reason

  """
  Stripe’s evaluation of the riskiness of the payment. Possible values for evaluated payments are normal, elevated, highest. For non-card payments, and card-based payments predating the public assignment of risk levels, this field will have the value not_assessed. In the event of an error in the evaluation, this field will have the value unknown.
  """
  risk_level

  """
  Stripe’s evaluation of the riskiness of the payment. Possible values for evaluated payments are between 0 and 100. For non-card payments, card-based payments predating the public assignment of risk scores, or in the event of an error during evaluation, this field will not be present. This field is only available with Radar for Fraud Teams.
  """
  risk_score

  """The ID of the Radar rule that matched the payment, if applicable."""
  rule

  """
  A human-readable description of the outcome type and reason, designed for you (the recipient of the payment), not your customer.
  """
  seller_message

  """
  Possible values are authorized, manual_review, issuer_declined, blocked, and invalid.
  """
  type

  """
  true if the charge succeeded, or was successfully authorized for later capture.
  """
  paid

  """
  This is the transaction number that appears on email receipts sent for this charge. This attribute will be null until a receipt has been sent.
  """
  receipt_number

  """
  This is the URL to view the receipt for this charge. The receipt is kept up-to-date to the latest state of the charge, including any refunds. If the charge is for an Invoice, the receipt will be stylized as an Invoice receipt.
  """
  receipt_url
  review
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type Phone {
  hypi: Hypi
  number: String!
  country: Country
  code: String
}

"""Scalar fields defined by StripePayout"""
enum StripePayoutScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeTransferDataInputOpt {
  hypi: HypiInputOpt
  amount: Int
  destination: StripeCustomerInputOpt
}

"""All fields defined by AccessToken"""
enum AccessTokenFields {
  hypi
  sessionToken
  sessionExpires
  errorCode
  errorMsg
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by Pair"""
enum PairScalarFields {
  key
  value
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeDisputeInput {
  hypi: HypiInput
  id: String
  object: String
}

"""All numeric fields defined by StripePrice"""
enum StripePriceNumericFields {
  unit_amount
  created
}

type StripeTransferAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeTaxAmountInputOpt {
  hypi: HypiInputOpt
  amount: Int
  inclusive: Boolean
  tax_rate: StripeTaxRateInputOpt
}

type ObjectSubjectRatingTriplet {
  hypi: Hypi
  subjectId: Int!
  objectId: Int!
  rating: Float
}

"""All numeric fields defined by StripePeriod"""
enum StripePeriodNumericFields {
  start
  end
}

input StripeCardPresentGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCardPresentScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by WorkflowStep"""
enum WorkflowStepNumericFields {
  order
  repeatN
}

input StripeCustomerAcceptanceInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input WebhookInputOpt {
  hypi: HypiInputOpt
  name: String
  as: AccountInputOpt
  query: GraphQLRefInputOpt
}

input StorageCounterGroupByOptions {
  """The field by which to to group the matching data"""
  field: StorageCounterScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StorageCounter"""
enum StorageCounterNumericFields {
  size
}

input StripeDiscountInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input StripeBillingThresholdInput {
  hypi: HypiInput
  usage_gte: Int
  amount_gte: Int
  reset_billing_cycle_anchor: Boolean
}

"""All numeric fields defined by StripePackageDimensions"""
enum StripePackageDimensionsNumericFields {
  height
  length
  weight
  width
}

input StripeTransferDataMaths {
  amount: MathInputInt
}

input WebhookGroupByOptions {
  """The field by which to to group the matching data"""
  field: WebhookScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeOrder"""
enum StripeOrderFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type WorkflowStepDataAggs {
  stepName: AggOtherScalar
  stepResult: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input ImageInputOpt {
  hypi: HypiInputOpt
  name: String
  file: FileInputOpt
  description: String
  location: GeoInputOpt
}

input StripeProductMaths {
  created: MathInputInt
  updated: MathInputInt
}

"""The types of GraphQL queries"""
enum OpType {
  Query
  Mutation
  Subscription
}

"""All fields defined by StripeSubscriptionUpdate"""
enum StripeSubscriptionUpdateFields {
  hypi
  billing_cycle_anchor
  expires_at
  trial_end
  trial_from_plan
  subscription_items
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePackageDimensionsMaths {
  height: MathInputFloat
  length: MathInputFloat
  weight: MathInputFloat
  width: MathInputFloat
}

input StripeSubscriptionScheduleInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  current_phase: StripeSubscriptionPhaseInputOpt
  customer: StripeCustomerInputOpt
  metadata: Json
  phases: [StripeSubscriptionPhaseInputOpt]
  status: StripeSubscriptionScheduleStatus
  subscription: StripeSubscriptionInputOpt
  canceled_at: Int
  completed_at: Int
  created: Int
  default_settings: StripeSubscriptionScheduleSettingsInputOpt
  end_behavior: StripeSubscriptionScheduleBehavior
  livemode: Boolean
  released_at: Int
  released_subscription: StripeSubscriptionInputOpt
}

"""
A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate.
https://stripe.com/docs/disputes
"""
type StripeDispute {
  hypi: Hypi
  id: String
  object: String
}

input StripeReviewInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

type ClientPolicy implements Policy {
  hypi: Hypi
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  clients(arcql: String, first: Int, after: String, last: Int, before: String): [AuthClient!]
}

input StripeMandateGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeMandateScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input InvoiceGroupByOptions {
  """The field by which to to group the matching data"""
  field: InvoiceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by StripeSubscriptionPhase"""
enum StripeSubscriptionPhaseScalarFields {
  end_date
  start_date
  billing_cycle_anchor
  collection_method
  proration_behavior
  trial_end
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input WorkflowAsyncInputOpt {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInputOpt
  repeatN: Int
  steps: [WorkflowStepInputOpt]
  cronSchedule: String
  repeatIf: GraphQLRefInputOpt
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInputOpt
  evaluateIf: GraphQLRefInputOpt
  order: Int
}

"""All fields defined by AggInt"""
enum AggIntFields {
  hypi

  """The value of the aggregated field for each group"""
  groupValues
  avg
  count
  max
  min
  sum
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags

  """The value of the aggregated field for each group"""
  groupValues_hypi

  """The value of the aggregated field for each group"""
  groupValues_key

  """The value of the aggregated field for each group"""
  groupValues_value
}

enum StripeUsage {
  on_session
  off_session
}

"""All numeric fields defined by WebhookResponse"""
enum WebhookResponseNumericFields {
  status
}

input ImageGroupByOptions {
  """The field by which to to group the matching data"""
  field: ImageScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by ABACTag"""
enum ABACTagScalarFields {
  key

  """If provided then policy assertion can be made against it"""
  value
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

enum StripeAccountType {
  credit
  checking
  prepaid
  unknown
}

type StripeSebaDebit {
  hypi: Hypi
  bank_code: String
  branch_code: String
  country: String
  fingerprint: String
  last4: String
}

type RecommendationModelAggs {
  type: AggOtherScalar
  ratingFieldName: AggOtherScalar
  subjectFieldName: AggOtherScalar
  objectFieldName: AggOtherScalar
  arcql: AggOtherScalar
  name: AggOtherScalar
  description: AggOtherScalar
  label: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePeriodMaths {
  start: MathInputInt
  end: MathInputInt
}

type Currency {
  hypi: Hypi
  name: String!
  code: String!
  symbol: String!
}

"""Email related"""
type EmailVerification {
  hypi: Hypi
  email: Email!

  """
  After the link is clicked from the email, redirect the browser to this URL passing a token in the URL i.e. token=jwt.token.here which can be used get the value in the meta field
  """
  redirectTo: String!

  """
  The verification code that is included in the email sent. Generated by the server, if provided the provided value is ignored
  """
  code: String

  """
  Optionally, the email from which the email will be sent. You MUST have a Hypi email app configured to send from this address
  """
  from: String

  """
  Optionally, the subject of the email, this is a velocity template - Hypi provides a default such as "Please verify your email to <realm>"
  """
  subject: String
  templateName: String

  """
   The HTML contents of the email. This is a Velocity template that will be rendered before being sent.
   The available variables and their types are:
   instance: AppId - You app instance ID
   parent - a map representing the current EmailVerification object
   value - the value of the htmlMessage field
   env: HypiEnv
   
  """
  htmlMessage: String

  """
  A plain text version of the email - see this is a velocity template, see htmlMessage for available variables
  """
  plainTextMessage: String

  """
  Any additional meta data you want to store. For example, you could collect all of the information needed to create the Account
  """
  meta: Json

  """Set by system, cannot be provided"""
  confirmed: Boolean
}

input WebhookResponseMaths {
  status: MathInputInt
}

"""All fields defined by Account"""
enum AccountFields {
  hypi
  verified
  enabled
  username
  password
  owner
  emails
  phones
  groups
  roles
  attempts
  remoteLogins
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""The event field of HypiEvent will be one of these"""
enum EmailEventType {
  """Hypi sent the email and it was accepted by the recipient email server."""
  delivered

  """
   Hypi could not deliver the email to the recipient email server.
   
  """
  failed
}

type StripeItemReason {
  hypi: Hypi
  usage_gte: Int
  line_item_ids(arcql: String, first: Int, after: String, last: Int, before: String): [StripeInvoiceLineItem!]
}

input StripeCustomerBalanceTransactionInput {
  hypi: HypiInput
  id: String
  object: String
}

input InvoiceItemInput {
  hypi: HypiInput
  name: String
  description: String
  type: String
  quantity: Float!
  unit: InvoiceItemUnit!
  vat: Float
  is_percentage: Boolean
}

input StripeMandateInput {
  hypi: HypiInput
  id: String
  customer_acceptance: StripeCustomerAcceptanceInput
  payment_method: StripePaymentMethodInput
  payment_method_details: StripePaymentMethodDetailsInput
  status: StripeMandateStatus
  type: StripeMandateType
  object: String
  livemode: Boolean
  multi_use: String
  single_use: String
}

input StripeBankAccountInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input WorkflowAsyncInput {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInput
  repeatN: Int
  steps: [WorkflowStepInput!]
  cronSchedule: String
  repeatIf: GraphQLRefInput
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInput
  evaluateIf: GraphQLRefInput
  order: Int
}

"""All fields defined by StripePayout"""
enum StripePayoutFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by RequestTemplate"""
enum RequestTemplateFields {
  hypi
  name
  request
  response
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePaymentOptionInputOpt {
  country: StripeSofortCountry
  hypi: HypiInputOpt
  id: String
  object: String
}

"""All fields defined by StripeCustomerAcceptance"""
enum StripeCustomerAcceptanceFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by WorkflowStepData"""
enum WorkflowStepDataFields {
  hypi
  stepName
  stepResult
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by PersonName"""
enum PersonNameScalarFields {
  title
  firstName
  lastName
  from
  to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripePackageDimensions"""
enum StripePackageDimensionsFields {
  hypi
  height
  length
  weight
  width
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""
These bank accounts are payment methods on Customer objects.

On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well, and are documented in the links above.
https://stripe.com/docs/api/customer_bank_accounts
"""
type StripeBankAccount {
  hypi: Hypi
  id: String
  object: String
}

type LanguageAggs {
  family: AggOtherScalar
  isoName: AggOtherScalar
  nativeName: AggOtherScalar
  iso6391Code: AggOtherScalar
  iso6392TCode: AggOtherScalar
  iso6392BCode: AggOtherScalar
  iso6393Code: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input PricePlanInputOpt {
  hypi: HypiInputOpt
  allowance: PricePlanAllowanceInputOpt
  bill_to: AccountInputOpt
  billing_frequency: TimeUnit
  default_card: String
  invoices: [InvoiceInputOpt]
  valid_from: DateTime
  valid_to: DateTime
}

type StripeOxxoDisplayDetailsAggs {
  expires_after: AggInt
  hosted_voucher_url: AggOtherScalar
  number: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All numeric fields defined by StripePaymentIntent"""
enum StripePaymentIntentNumericFields {
  amount
  amount_capturable
  amount_received
  canceled_at
  created
}

"""Defines a collection for subjects, roles, policies and permissions."""
type Group {
  hypi: Hypi

  """
  A unique name identifying this group, implicitly sets the path of the group to /<name> whihc can be referenced in wild card permissions
  """
  name: String!
  accounts(arcql: String, first: Int, after: String, last: Int, before: String): [Account!]
  children(arcql: String, first: Int, after: String, last: Int, before: String): [Group!]
  organisations(arcql: String, first: Int, after: String, last: Int, before: String): [Organisation!]
}

input StripePaymentIntentMaths {
  amount: MathInputInt
  amount_capturable: MathInputInt
  amount_received: MathInputInt
  canceled_at: MathInputInt
  created: MathInputInt
}

input NotificationInputOpt {
  hypi: HypiInputOpt
  message: String
  ctx: NotificationCtxInputOpt
}

"""
A client defines an agent that acts on behalf of a user/subject.
Currently implicitly created by Hypi.
"""
type AuthClient {
  hypi: Hypi
  name: String!
  secret: String!
}

enum StripeRequest3DSecure {
  any
  automatic
}

"""Scalar fields defined by AuthClient"""
enum AuthClientScalarFields {
  name
  secret
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input RecommendationTrainerGroupByOptions {
  """The field by which to to group the matching data"""
  field: RecommendationTrainerScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input CounterInputOpt {
  hypi: HypiInputOpt
  name: String
  label: String
  tags: [String]
  value: Float
}

input WorkflowStepInputOpt {
  hypi: HypiInputOpt
  name: String
  fn: GraphQLRefInputOpt
  order: Int
  execAs: String
  async: Boolean
  maxExecutionTime: String
  repeatN: Int
  evaluateIf: GraphQLRefInputOpt
  repeatIf: GraphQLRefInputOpt
}

input StripeSourceInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  client_secret: String
  reusable: Boolean
  livemode: Boolean
}

"""All fields defined by GeoEnvelope"""
enum GeoEnvelopeFields {
  hypi
  p1
  p2
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeBillingThreshold {
  hypi: Hypi
  usage_gte: Int
  amount_gte: Int
  reset_billing_cycle_anchor: Boolean
}

input StripeOxxoDisplayDetailsInput {
  hypi: HypiInput
  expires_after: Int
  hosted_voucher_url: String
  number: String
}

"""All numeric fields defined by StripeBillingThreshold"""
enum StripeBillingThresholdNumericFields {
  usage_gte
  amount_gte
}

type StripeBacsDebit {
  hypi: Hypi
  fingerprint: String
  last4: String
  sort_code: String
}

input PasswordGroupByOptions {
  """The field by which to to group the matching data"""
  field: PasswordScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type ABACTag {
  hypi: Hypi
  key: String!

  """If provided then policy assertion can be made against it"""
  value: String
}

"""All fields defined by Notification"""
enum NotificationFields {
  hypi
  message
  ctx
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
  ctx_hypi
  ctx_type
  ctx_targetAccount
}

type HypiFilterConnection {
  hypi: Hypi
  edges: [HypiResultEdge!]
  pageInfo: PageInfo!
}

input StripeSubscriptionPhaseInputOpt {
  hypi: HypiInputOpt
  end_date: Int
  start_date: Int
  add_invoice_items: StripeInvoiceItemInputOpt
  billing_cycle_anchor: StripeBillingCycleAnchor
  billing_thresholds: StripeBillingThresholdInputOpt
  collection_method: StripeCollectionMethod
  coupon: StripeCouponInputOpt
  default_payment_method: StripePaymentMethodInputOpt
  default_tax_rates: [StripeTaxRateInputOpt]
  invoice_settings: StripeInvoiceSettingsInputOpt
  items: StripeSubscriptionItemInputOpt
  proration_behavior: StripeProrationBehavior
  trial_end: Int
}

"""A list of types on which aggregation queries can be executed"""
type HypiAggregationType {
  product(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ProductAggs
  productWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ProductGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ProductAggs]
  script(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ScriptAggs
  scriptWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ScriptGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ScriptAggs]
  requestTemplate(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RequestTemplateAggs
  requestTemplateWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RequestTemplateGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RequestTemplateAggs]
  notificationCtx(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): NotificationCtxAggs
  notificationCtxWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [NotificationCtxGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [NotificationCtxAggs]
  notification(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): NotificationAggs
  notificationWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [NotificationGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [NotificationAggs]
  uRL(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): URLAggs
  uRLWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [URLGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [URLAggs]
  currency(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): CurrencyAggs
  currencyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [CurrencyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [CurrencyAggs]
  coordinate(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): CoordinateAggs
  coordinateWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [CoordinateGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [CoordinateAggs]
  geoEnvelope(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): GeoEnvelopeAggs
  geoEnvelopeWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [GeoEnvelopeGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [GeoEnvelopeAggs]
  language(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): LanguageAggs
  languageWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [LanguageGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [LanguageAggs]
  address(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): AddressAggs
  addressWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [AddressGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [AddressAggs]
  personName(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PersonNameAggs
  personNameWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PersonNameGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PersonNameAggs]
  phone(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PhoneAggs
  phoneWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PhoneGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PhoneAggs]
  email(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): EmailAggs
  emailWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [EmailGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [EmailAggs]
  password(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PasswordAggs
  passwordWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PasswordGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PasswordAggs]
  remoteLogin(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RemoteLoginAggs
  remoteLoginWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RemoteLoginGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RemoteLoginAggs]
  loginAttempt(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): LoginAttemptAggs
  loginAttemptWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [LoginAttemptGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [LoginAttemptAggs]
  bruteForceDetectionOptions(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): BruteForceDetectionOptionsAggs
  bruteForceDetectionOptionsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [BruteForceDetectionOptionsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [BruteForceDetectionOptionsAggs]
  oAuth2AuthorizedClient(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): OAuth2AuthorizedClientAggs
  oAuth2AuthorizedClientWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [OAuth2AuthorizedClientGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [OAuth2AuthorizedClientAggs]
  authClient(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): AuthClientAggs
  authClientWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [AuthClientGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [AuthClientAggs]
  aBACPolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ABACPolicyAggs
  aBACPolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ABACPolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ABACPolicyAggs]
  aBACTag(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ABACTagAggs
  aBACTagWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ABACTagGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ABACTagAggs]
  image(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ImageAggs
  imageWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ImageGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ImageAggs]
  emailVerification(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): EmailVerificationAggs
  emailVerificationWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [EmailVerificationGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [EmailVerificationAggs]
  emailTemplate(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): EmailTemplateAggs
  emailTemplateWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [EmailTemplateGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [EmailTemplateAggs]
  emailSendingAttempt(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): EmailSendingAttemptAggs
  emailSendingAttemptWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [EmailSendingAttemptGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [EmailSendingAttemptAggs]
  passwordReminder(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PasswordReminderAggs
  passwordReminderWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PasswordReminderGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PasswordReminderAggs]
  webhook(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): WebhookAggs
  webhookWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [WebhookGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [WebhookAggs]
  webhookResponse(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): WebhookResponseAggs
  webhookResponseWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [WebhookResponseGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [WebhookResponseAggs]
  logMessage(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): LogMessageAggs
  logMessageWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [LogMessageGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [LogMessageAggs]
  graphQLRef(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): GraphQLRefAggs
  graphQLRefWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [GraphQLRefGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [GraphQLRefAggs]
  workflowStepData(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): WorkflowStepDataAggs
  workflowStepDataWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [WorkflowStepDataGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [WorkflowStepDataAggs]
  workflowStep(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): WorkflowStepAggs
  workflowStepWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [WorkflowStepGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [WorkflowStepAggs]
  accessToken(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): AccessTokenAggs
  accessTokenWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [AccessTokenGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [AccessTokenAggs]
  storageCounter(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StorageCounterAggs
  storageCounterWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StorageCounterGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StorageCounterAggs]
  country(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): CountryAggs
  countryWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [CountryGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [CountryAggs]
  account(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): AccountAggs
  accountWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [AccountGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [AccountAggs]
  person(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PersonAggs
  personWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PersonGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PersonAggs]
  organisation(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): OrganisationAggs
  organisationWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [OrganisationGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [OrganisationAggs]
  oAuthProvider(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): OAuthProviderAggs
  oAuthProviderWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [OAuthProviderGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [OAuthProviderAggs]
  realm(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RealmAggs
  realmWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RealmGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RealmAggs]
  group(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): GroupAggs
  groupWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [GroupGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [GroupAggs]
  role(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RoleAggs
  roleWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RoleGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RoleAggs]
  rolePolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RolePolicyAggs
  rolePolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RolePolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RolePolicyAggs]
  clientPolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ClientPolicyAggs
  clientPolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ClientPolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ClientPolicyAggs]
  timePolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): TimePolicyAggs
  timePolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [TimePolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [TimePolicyAggs]
  aggregatedPolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): AggregatedPolicyAggs
  aggregatedPolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [AggregatedPolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [AggregatedPolicyAggs]
  groupPolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): GroupPolicyAggs
  groupPolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [GroupPolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [GroupPolicyAggs]
  accountPolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): AccountPolicyAggs
  accountPolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [AccountPolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [AccountPolicyAggs]
  realmPolicy(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RealmPolicyAggs
  realmPolicyWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RealmPolicyGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RealmPolicyAggs]
  realmLink(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RealmLinkAggs
  realmLinkWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RealmLinkGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RealmLinkAggs]
  permission(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PermissionAggs
  permissionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PermissionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PermissionAggs]
  file(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): FileAggs
  fileWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [FileGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [FileAggs]
  video(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): VideoAggs
  videoWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [VideoGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [VideoAggs]
  emailMessage(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): EmailMessageAggs
  emailMessageWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [EmailMessageGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [EmailMessageAggs]
  workflow(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): WorkflowAggs
  workflowWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [WorkflowGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [WorkflowAggs]
  workflowSession(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): WorkflowSessionAggs
  workflowSessionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [WorkflowSessionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [WorkflowSessionAggs]
  counter(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): CounterAggs
  counterWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [CounterGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [CounterAggs]
  gauge(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): GaugeAggs
  gaugeWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [GaugeGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [GaugeAggs]
  serverlessResponse(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ServerlessResponseAggs
  serverlessResponseWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ServerlessResponseGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ServerlessResponseAggs]
  learningEnvironment(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): LearningEnvironmentAggs
  learningEnvironmentWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [LearningEnvironmentGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [LearningEnvironmentAggs]
  recommendationModel(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RecommendationModelAggs
  recommendationModelWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RecommendationModelGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RecommendationModelAggs]
  kMeanCLusteringModel(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): KMeanCLusteringModelAggs
  kMeanCLusteringModelWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [KMeanCLusteringModelGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [KMeanCLusteringModelAggs]
  recommendationTrainer(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): RecommendationTrainerAggs
  recommendationTrainerWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [RecommendationTrainerGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [RecommendationTrainerAggs]
  objectSubjectRatingTriplet(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): ObjectSubjectRatingTripletAggs
  objectSubjectRatingTripletWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [ObjectSubjectRatingTripletGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [ObjectSubjectRatingTripletAggs]
  predictionData(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PredictionDataAggs
  predictionDataWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PredictionDataGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PredictionDataAggs]
  trainingInstance(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): TrainingInstanceAggs
  trainingInstanceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [TrainingInstanceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [TrainingInstanceAggs]
  invoiceItem(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): InvoiceItemAggs
  invoiceItemWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [InvoiceItemGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [InvoiceItemAggs]
  pricePlanInclusion(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PricePlanInclusionAggs
  pricePlanInclusionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PricePlanInclusionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PricePlanInclusionAggs]
  stripeOrder(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeOrderAggs
  stripeOrderWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeOrderGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeOrderAggs]
  stripeReview(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeReviewAggs
  stripeReviewWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeReviewGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeReviewAggs]
  stripeTransfer(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTransferAggs
  stripeTransferWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTransferGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTransferAggs]
  stripeTransferData(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTransferDataAggs
  stripeTransferDataWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTransferDataGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTransferDataAggs]
  stripeFraudDetails(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeFraudDetailsAggs
  stripeFraudDetailsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeFraudDetailsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeFraudDetailsAggs]
  stripeShippingInfo(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeShippingInfoAggs
  stripeShippingInfoWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeShippingInfoGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeShippingInfoAggs]
  stripeBillingDetails(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeBillingDetailsAggs
  stripeBillingDetailsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeBillingDetailsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeBillingDetailsAggs]
  stripeAddress(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeAddressAggs
  stripeAddressWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeAddressGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeAddressAggs]
  stripeDispute(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeDisputeAggs
  stripeDisputeWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeDisputeGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeDisputeAggs]
  stripeEvent(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeEventAggs
  stripeEventWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeEventGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeEventAggs]
  stripeMandate(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeMandateAggs
  stripeMandateWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeMandateGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeMandateAggs]
  stripePaymentMethodDetails(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePaymentMethodDetailsAggs
  stripePaymentMethodDetailsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePaymentMethodDetailsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePaymentMethodDetailsAggs]
  stripeCustomerAcceptance(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCustomerAcceptanceAggs
  stripeCustomerAcceptanceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCustomerAcceptanceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCustomerAcceptanceAggs]
  stripePayout(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePayoutAggs
  stripePayoutWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePayoutGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePayoutAggs]
  stripePackageDimensions(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePackageDimensionsAggs
  stripePackageDimensionsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePackageDimensionsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePackageDimensionsAggs]
  stripeTransformQuantity(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTransformQuantityAggs
  stripeTransformQuantityWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTransformQuantityGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTransformQuantityAggs]
  stripeTier(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTierAggs
  stripeTierWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTierGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTierAggs]
  stripePriceRecurrence(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePriceRecurrenceAggs
  stripePriceRecurrenceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePriceRecurrenceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePriceRecurrenceAggs]
  stripeRefund(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeRefundAggs
  stripeRefundWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeRefundGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeRefundAggs]
  stripePaymentMethod(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePaymentMethodAggs
  stripePaymentMethodWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePaymentMethodGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePaymentMethodAggs]
  stripeSebaDebit(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSebaDebitAggs
  stripeSebaDebitWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSebaDebitGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSebaDebitAggs]
  stripeIdeal(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeIdealAggs
  stripeIdealWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeIdealGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeIdealAggs]
  stripeFpx(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeFpxAggs
  stripeFpxWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeFpxGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeFpxAggs]
  stripeCardPresent(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCardPresentAggs
  stripeCardPresentWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCardPresentGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCardPresentAggs]
  stripeReceipt(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeReceiptAggs
  stripeReceiptWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeReceiptGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeReceiptAggs]
  stripeBacsDebit(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeBacsDebitAggs
  stripeBacsDebitWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeBacsDebitGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeBacsDebitAggs]
  stripeAuBecsDebit(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeAuBecsDebitAggs
  stripeAuBecsDebitWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeAuBecsDebitGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeAuBecsDebitAggs]
  stripeBankAccount(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeBankAccountAggs
  stripeBankAccountWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeBankAccountGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeBankAccountAggs]
  stripeSource(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSourceAggs
  stripeSourceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSourceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSourceAggs]
  stripeCoupon(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCouponAggs
  stripeCouponWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCouponGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCouponAggs]
  stripeCreditNote(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCreditNoteAggs
  stripeCreditNoteWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCreditNoteGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCreditNoteAggs]
  stripeCustomerBalanceTransaction(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCustomerBalanceTransactionAggs
  stripeCustomerBalanceTransactionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCustomerBalanceTransactionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCustomerBalanceTransactionAggs]
  stripeCustomerPortal(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCustomerPortalAggs
  stripeCustomerPortalWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCustomerPortalGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCustomerPortalAggs]
  stripeTaxId(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTaxIdAggs
  stripeTaxIdWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTaxIdGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTaxIdAggs]
  stripeDiscount(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeDiscountAggs
  stripeDiscountWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeDiscountGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeDiscountAggs]
  stripeTaxAmount(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTaxAmountAggs
  stripeTaxAmountWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTaxAmountGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTaxAmountAggs]
  stripeDiscountAmount(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeDiscountAmountAggs
  stripeDiscountAmountWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeDiscountAmountGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeDiscountAmountAggs]
  stripeStatusTransitions(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeStatusTransitionsAggs
  stripeStatusTransitionsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeStatusTransitionsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeStatusTransitionsAggs]
  stripeInvoiceLineItem(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeInvoiceLineItemAggs
  stripeInvoiceLineItemWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeInvoiceLineItemGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeInvoiceLineItemAggs]
  stripePeriod(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePeriodAggs
  stripePeriodWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePeriodGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePeriodAggs]
  stripePromotionCode(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePromotionCodeAggs
  stripePromotionCodeWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePromotionCodeGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePromotionCodeAggs]
  stripeIntervalObject(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeIntervalObjectAggs
  stripeIntervalObjectWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeIntervalObjectGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeIntervalObjectAggs]
  stripePauseCollection(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePauseCollectionAggs
  stripePauseCollectionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePauseCollectionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePauseCollectionAggs]
  stripePlan(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePlanAggs
  stripePlanWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePlanGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePlanAggs]
  stripeBillingThreshold(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeBillingThresholdAggs
  stripeBillingThresholdWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeBillingThresholdGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeBillingThresholdAggs]
  stripeSubscriptionScheduleSettings(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSubscriptionScheduleSettingsAggs
  stripeSubscriptionScheduleSettingsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSubscriptionScheduleSettingsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSubscriptionScheduleSettingsAggs]
  stripeInvoiceSettings(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeInvoiceSettingsAggs
  stripeInvoiceSettingsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeInvoiceSettingsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeInvoiceSettingsAggs]
  stripeTaxRate(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeTaxRateAggs
  stripeTaxRateWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeTaxRateGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeTaxRateAggs]
  stripeUsageRecord(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeUsageRecordAggs
  stripeUsageRecordWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeUsageRecordGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeUsageRecordAggs]
  stripeCheckoutSession(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCheckoutSessionAggs
  stripeCheckoutSessionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCheckoutSessionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCheckoutSessionAggs]
  stripeError(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeErrorAggs
  stripeErrorWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeErrorGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeErrorAggs]
  stripeNextAction(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeNextActionAggs
  stripeNextActionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeNextActionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeNextActionAggs]
  stripeAliPayHandleRedirect(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeAliPayHandleRedirectAggs
  stripeAliPayHandleRedirectWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeAliPayHandleRedirectGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeAliPayHandleRedirectAggs]
  stripeOxxoDisplayDetails(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeOxxoDisplayDetailsAggs
  stripeOxxoDisplayDetailsWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeOxxoDisplayDetailsGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeOxxoDisplayDetailsAggs]
  stripeRedirectToUrl(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeRedirectToUrlAggs
  stripeRedirectToUrlWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeRedirectToUrlGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeRedirectToUrlAggs]
  stripeSofort(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSofortAggs
  stripeSofortWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSofortGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSofortAggs]
  stripeReference(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeReferenceAggs
  stripeReferenceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeReferenceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeReferenceAggs]
  invoice(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): InvoiceAggs
  invoiceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [InvoiceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [InvoiceAggs]
  pricePlanAllowance(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PricePlanAllowanceAggs
  pricePlanAllowanceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PricePlanAllowanceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PricePlanAllowanceAggs]
  pricePlan(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): PricePlanAggs
  pricePlanWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [PricePlanGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [PricePlanAggs]
  stripeCharge(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeChargeAggs
  stripeChargeWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeChargeGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeChargeAggs]
  stripeChargeOutcome(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeChargeOutcomeAggs
  stripeChargeOutcomeWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeChargeOutcomeGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeChargeOutcomeAggs]
  stripeCustomer(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeCustomerAggs
  stripeCustomerWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeCustomerGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeCustomerAggs]
  stripeProduct(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeProductAggs
  stripeProductWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeProductGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeProductAggs]
  stripePrice(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePriceAggs
  stripePriceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePriceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePriceAggs]
  stripeInvoice(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeInvoiceAggs
  stripeInvoiceWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeInvoiceGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeInvoiceAggs]
  stripeThesholdReason(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeThesholdReasonAggs
  stripeThesholdReasonWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeThesholdReasonGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeThesholdReasonAggs]
  stripeItemReason(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeItemReasonAggs
  stripeItemReasonWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeItemReasonGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeItemReasonAggs]
  stripeInvoiceItem(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeInvoiceItemAggs
  stripeInvoiceItemWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeInvoiceItemGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeInvoiceItemAggs]
  stripeSubscription(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSubscriptionAggs
  stripeSubscriptionWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSubscriptionGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSubscriptionAggs]
  stripeSubscriptionUpdate(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSubscriptionUpdateAggs
  stripeSubscriptionUpdateWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSubscriptionUpdateGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSubscriptionUpdateAggs]
  stripeSubscriptionItem(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSubscriptionItemAggs
  stripeSubscriptionItemWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSubscriptionItemGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSubscriptionItemAggs]
  stripeSubscriptionSchedule(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSubscriptionScheduleAggs
  stripeSubscriptionScheduleWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSubscriptionScheduleGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSubscriptionScheduleAggs]
  stripeSubscriptionPhase(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSubscriptionPhaseAggs
  stripeSubscriptionPhaseWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSubscriptionPhaseGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSubscriptionPhaseAggs]
  stripePaymentIntent(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripePaymentIntentAggs
  stripePaymentIntentWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripePaymentIntentGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripePaymentIntentAggs]
  stripeSetupIntent(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String
  ): StripeSetupIntentAggs
  stripeSetupIntentWith(
    """
    Filters rows before the they are summarised into groups by the GROUP BY clause
    """
    where: String

    """
    Combines rows into groups based on matching values in specified columns. One row is returned for each group.
    """
    groupBy: [StripeSetupIntentGroupByOptions!]!

    """Filters rows after the results are grouped"""
    having: String
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): [StripeSetupIntentAggs]
}

input RoleGroupByOptions {
  """The field by which to to group the matching data"""
  field: RoleScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeSubscriptionUpdate {
  hypi: Hypi
  billing_cycle_anchor: Int
  expires_at: Int
  trial_end: Int
  trial_from_plan: Boolean
  subscription_items(arcql: String, first: Int, after: String, last: Int, before: String): [StripeSubscriptionItem!]
}

type StripePlanAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  active: AggOtherScalar
  billing_scheme: AggOtherScalar
  created: AggInt
  currency: AggOtherScalar
  interval: AggOtherScalar
  interval_count: AggInt
  livemode: AggOtherScalar
  metadata: AggOtherScalar
  product: AggOtherScalar
  tiers_mode: AggOtherScalar
  usage_type: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by BruteForceDetectionOptions"""
enum BruteForceDetectionOptionsScalarFields {
  maxLoginFailures

  """How long the user ust wait when maxLoginFailures have been reached"""
  waitIncrements
  waitIncrementsUnit

  """
  If login failures occurr too quickly, lock out the user, this sets number of milliseconds that determine "quickly"
  """
  quickLoginCheckMillis

  """How long to wait after a quick failure lock out"""
  minQuickLoginWait
  minQuickLoginWaitUnit

  """max time a user will be locked out for"""
  maxWait
  maxWaitUnit

  """When failure count is reset"""
  failureReset
  failureResetUnit
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripePaymentMethodDetailsAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

enum AuthorizationGrantType {
  authorization_code
  implicit
  refresh_token
  client_credentials
}

type StripeAddressAggs {
  line1: AggOtherScalar
  line2: AggOtherScalar
  city: AggOtherScalar
  country: AggOtherScalar
  state: AggOtherScalar
  postal_code: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeBankAccount"""
enum StripeBankAccountScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeIdealInputOpt {
  hypi: HypiInputOpt
  bank: StripeIdealBank
  bic: String
}

enum StripeInterval {
  day
  week
  month
  year
}

input RecommendationTrainerInputOpt {
  hypi: HypiInputOpt
  maxIterations: Int
  minMdlImprovement: Float
  batchSize: Int
  learningRate: Int
}

"""
Defines a web hook that can be used to trigger Hypi GraphQL functions on a given app.
The account specified in the web hook must have access to the app/instance and must be authorised to call the functions specified.
"""
type Webhook {
  hypi: Hypi

  """
  The name by which this web hook is referenced in the URL, if missing the webhook is only adressable by ID
  """
  name: String

  """
   Defaults to the account creating the Webhook.
   Hypi will generate an authorisation token automatically for the account when the web hook is triggered.
   This token will then be used to execute the triggers in the web hook (query or mutation).
   For security an account should be created specifically for invoking web hooks and an AccountPolicy should be created that grants access only to the specified functions or otherwise limit the scope of what the account can do.
   
  """
  as: Account

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query: GraphQLRef!
}

input OrganisationInput {
  hypi: HypiInput
  name: String!
  logo: ImageInput
  addresses: [AddressInput!]
  incorporated: DateTime
  phones: [PhoneInput!]
  emails: [EmailInput!]
  members: [AccountInput!]
  subsidiaries: [OrganisationInput!]
}

"""All numeric fields defined by StripePauseCollection"""
enum StripePauseCollectionNumericFields {
  resumes_at
}

type StripeCustomerBalanceTransactionAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input AccessTokenInput {
  hypi: HypiInput
  sessionToken: String
  sessionExpires: Long
  errorCode: String
  errorMsg: String
}

type StripePriceRecurrence {
  hypi: Hypi

  """
  Specifies a usage aggregation strategy for prices of usage_type=metered
  """
  aggregate_usage: StripeAggregateUsage

  """The frequency at which a subscription is billed."""
  interval: StripeBillingFrequency

  """
  The number of intervals (specified in the interval attribute) between subscription billings. For example, interval=month and interval_count=3 bills every 3 months.
  """
  interval_count: Int

  """
  Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
  """
  usage_type: StripeUsageType
}

input StripeSubscriptionUpdateGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSubscriptionUpdateScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by Pair"""
enum PairFields {
  hypi
  key
  value
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

enum FileStatus {
  UPLOADED
  PROCESSING
  PENDING_APPROVAL
  DISABLED
  AVAILABLE
  DELETED
  UNAVAILABLE
}

input StripeProductInputOpt {
  hypi: HypiInputOpt
  id: String
  active: Boolean
  description: String
  metadata: Json
  name: String
  object: String
  attributes: [String]
  caption: String
  created: Int
  deactivate_on: [String]
  images: [String]
  livemode: Boolean
  url: String
  updated: Int
  unit_label: String
  statement_descriptor: String
  shippable: Boolean
  package_dimensions: StripePackageDimensionsInputOpt
}

type StripeDiscountAmountAggs {
  amount: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All numeric fields defined by StripeSubscription"""
enum StripeSubscriptionNumericFields {
  current_period_end
  current_period_start
  billing_cycle_anchor
  cancel_at
  canceled_at
  created
  days_until_due
  ended_at
  next_pending_invoice_item_invoice
  start_date
  trial_end
  trial_start
}

input ServerlessResponseInput {
  hypi: HypiInput
  path: String
  headers: Json
  multiPart: Boolean
  method: String
  files: [FileInput]
  chunked: Boolean
  attributes: [String]
  queryString: Json
  body: Json
  cookies: Json
}

input StripeFpxInput {
  hypi: HypiInput
  bank: StripeFpxBank
}

"""All fields defined by StripeError"""
enum StripeErrorFields {
  hypi
  charge
  code
  decline_code
  doc_url
  message
  param
  payment_method
  type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input LearningEnvironmentInputOpt {
  hypi: HypiInputOpt
  rngSeed: Int
  parallelism: Int
  dataTtl: Int
}

"""All fields defined by Gauge"""
enum GaugeFields {
  hypi

  """
  A name which uniquely identifies this counter in an instance. Must be a letter followed by 0 or more letters, numbers or underscores
  """
  name

  """A human friendly display label for the counter"""
  label

  """
  The current value of this gauge, set, increase or decrease as you see fit
  """
  value
  tags
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""The status of the payment is either succeeded, pending, or failed."""
enum StripeChargeStatus {
  SUCCEEDED
  PENDING
  FAILED
}

input RoleInput {
  hypi: HypiInput
  name: String!
  accounts: [AccountInput!]
}

enum StripeCaptureMethod {
  automatic
  manual
}

input CurrencyInput {
  hypi: HypiInput
  name: String!
  code: String!
  symbol: String!
}

input GroupPolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: GroupPolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input TrainingInstanceInput {
  hypi: HypiInput
  model: MLModelInput!
  status: TrainingStatus!
  errors: [String!]
}

type StripeStatusTransitionsAggs {
  finalized_at: AggInt
  marked_uncollectible_at: AggInt
  paid_at: AggInt
  voided_at: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeCheckoutSessionInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

"""All fields defined by Person"""
enum PersonFields {
  hypi
  dob
  gender
  avatar
  names
  addresses
  phones
  roles
  preferences
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeAliPayHandleRedirect {
  hypi: Hypi
  native_data: String
  native_url: String
  return_url: String
  url: String
}

"""Scalar fields defined by StripeThesholdReason"""
enum StripeThesholdReasonScalarFields {
  amount_gte
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input NotificationInput {
  hypi: HypiInput
  message: String
  ctx: NotificationCtxInput
}

"""Scalar fields defined by Counter"""
enum CounterScalarFields {
  """
  A name which uniquely identifies this counter in an instance. Must be a letter followed by 0 or more letters, numbers or underscores
  """
  name

  """A human friendly display label for the counter"""
  label

  """
  The value of the counter. Semantically this is intended to be monotonically increasing but this is not currently enforced
  See the Gauge type if you want to arbitrarily increase/decrease/set value on a type
  """
  value
  tags
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input PersonGroupByOptions {
  """The field by which to to group the matching data"""
  field: PersonScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeChargeOutcomeAggs {
  network_status: AggOtherScalar
  reason: AggOtherScalar
  risk_level: AggOtherScalar
  risk_score: AggInt
  rule: AggOtherScalar
  seller_message: AggOtherScalar
  type: AggOtherScalar
  paid: AggOtherScalar
  receipt_number: AggOtherScalar
  receipt_url: AggOtherScalar
  review: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type PermissionDescription {
  hypi: Hypi
  roles: [Role!]
  groups: [Group!]
  organisations: [Organisation!]
  realms: [Realm!]
  permissions(after: String, limit: Int = 25, type: String, resources: [String!]): [Permission]
}

"""Scalar fields defined by TrainingInstance"""
enum TrainingInstanceScalarFields {
  status
  errors
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type AggOtherScalar {
  hypi: Hypi

  """The value of the aggregated field for each group"""
  groupValues: [Pair]
  count(distinct: Boolean): Int
}

input StripeSubscriptionInput {
  hypi: HypiInput
  id: String
  object: String
  cancel_at_period_end: Boolean
  current_period_end: Int
  current_period_start: Int
  customer: StripeCustomerInput
  default_payment_method: StripePaymentMethodInput
  items: [StripeSubscriptionItemInput]
  latest_invoice: StripeInvoiceInput
  metadata: Json
  pending_setup_intent: StripeSetupIntentInput
  pending_update: StripeSubscriptionUpdateInput
  status: StripeSubscriptionStatus
  billing_cycle_anchor: Int
  billing_thresholds: StripeBillingThresholdInput
  cancel_at: Int
  canceled_at: Int
  collection_method: StripeCollectionMethod
  created: Int
  days_until_due: Int
  default_source: StripeSourceInput
  default_tax_rates: [StripeTaxRateInput!]
  discount: StripeDiscountInput
  ended_at: Int
  livemode: Boolean
  next_pending_invoice_item_invoice: Int
  pause_collection: StripePauseCollectionInput
  pending_invoice_item_interval: StripeIntervalObjectInput
  schedule: StripeSubscriptionScheduleInput
  start_date: Int
  trial_end: Int
  trial_start: Int
}

"""Long type"""
scalar Long

input StripeCustomerInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  address: StripeAddressInputOpt
  description: String
  email: String
  metadata: Json
  name: String
  phone: String
  shipping: StripeShippingInfoInputOpt
  balance: Int
  created: Int
  currency: String
  default_source: StripeSourceInputOpt
  delinquent: Boolean
  discount: StripeDiscountInputOpt
  invoice_prefix: String
  invoice_settings: StripeInvoiceSettingsInputOpt
  livemode: Boolean
  next_invoice_sequence: Int
  preferred_locales: [String]
  source: String
  sources: [StripeSourceInputOpt]
  subscriptions: [StripeSubscriptionInputOpt]
  tax_exempt: String
  tax_ids: [StripeTaxIdInputOpt]
}

"""All numeric fields defined by Counter"""
enum CounterNumericFields {
  value
}

"""Scalar fields defined by PricePlanInclusion"""
enum PricePlanInclusionScalarFields {
  allow_overage

  """If overage is allowed, how much is allowed?"""
  allowed_overage_amount

  """
  If overage is allowed and an amount is specified, is the amount a percentage?
  """
  allowed_overage_is_percentage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeBillingThresholdGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeBillingThresholdScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input PersonNameInput {
  hypi: HypiInput
  title: String
  firstName: String
  lastName: String
  from: DateTime
  to: DateTime
}

"""All fields defined by StripeDiscountAmount"""
enum StripeDiscountAmountFields {
  hypi
  amount
  discount
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePromotionCodeInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

"""All fields defined by RemoteLogin"""
enum RemoteLoginFields {
  hypi
  type
  email
  remoteId
  otherAttributes
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeReceiptInput {
  hypi: HypiInput
  account_type: StripeAccountType
  application_cryptogram: String
  application_preferred_name: String
  authorization_code: String
  authorization_response_code: String
  cardholder_verification_method: String
  dedicated_file_name: String
  terminal_verification_results: String
  transaction_status_information: String
}

type AccessTokenAggs {
  sessionToken: AggOtherScalar
  sessionExpires: AggOtherScalar
  errorCode: AggOtherScalar
  errorMsg: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input TrainingInstanceGroupByOptions {
  """The field by which to to group the matching data"""
  field: TrainingInstanceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StripeInvoiceItem"""
enum StripeInvoiceItemNumericFields {
  amount
  date
  quantity
  unit_amount
  unit_amount_decimal
}

type TimePolicy implements Policy {
  hypi: Hypi

  """
  (yyyy-MM-dd hh:mm:ss) can be used for example to ensure a file is not viewable before the given date
  """
  from: DateTime

  """can be used to ensure a file is not viewable after a given date"""
  to: DateTime
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  clients(arcql: String, first: Int, after: String, last: Int, before: String): [AuthClient!]
  roles(arcql: String, first: Int, after: String, last: Int, before: String): [Role!]
  groups(arcql: String, first: Int, after: String, last: Int, before: String): [Group!]
  accounts(arcql: String, first: Int, after: String, last: Int, before: String): [Account!]
  realms(arcql: String, first: Int, after: String, last: Int, before: String): [RealmLink!]
}

"""Scalar fields defined by Currency"""
enum CurrencyScalarFields {
  name
  code
  symbol
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type CurrencyAggs {
  name: AggOtherScalar
  code: AggOtherScalar
  symbol: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeStatusTransitions"""
enum StripeStatusTransitionsFields {
  hypi
  finalized_at
  marked_uncollectible_at
  paid_at
  voided_at
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeItemReasonGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeItemReasonScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input URLInput {
  hypi: HypiInput
  path: String!
  queryParams: Json
  port: Int
  host: String
}

type EmailMessageAggs {
  subject: AggOtherScalar
  template: AggOtherScalar
  text: AggOtherScalar
  html: AggOtherScalar
  deliveryTime: AggOtherScalar
  requireTls: AggOtherScalar
  skipVerification: AggOtherScalar
  headers: AggOtherScalar
  variables: AggOtherScalar
  recipientVariables: AggOtherScalar
  tags: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  from_value: AggOtherScalar
  from_type: AggOtherScalar
  to_value: AggOtherScalar
  to_type: AggOtherScalar
  cc_value: AggOtherScalar
  cc_type: AggOtherScalar
  bcc_value: AggOtherScalar
  bcc_type: AggOtherScalar
}

enum StripeNetwork {
  amex
  cartes_bancaires
  diners
  discover
  interac
  jcb
  mastercard
  unionpay
  visa
  unknown
}

"""Scalar fields defined by TimePolicy"""
enum TimePolicyScalarFields {
  """
  (yyyy-MM-dd hh:mm:ss) can be used for example to ensure a file is not viewable before the given date
  """
  from

  """can be used to ensure a file is not viewable after a given date"""
  to
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input InvoiceItemGroupByOptions {
  """The field by which to to group the matching data"""
  field: InvoiceItemScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeFraudDetailsInput {
  hypi: HypiInput
  stripe_report: String
  user_report: String
}

type KMeanCLusteringModelAggs {
  typeName: AggOtherScalar
  arcql: AggOtherScalar
  name: AggOtherScalar
  description: AggOtherScalar
  label: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by AggOtherScalar"""
enum AggOtherScalarScalarFields {
  count
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId

  """The value of the aggregated field for each group"""
  groupValues_key

  """The value of the aggregated field for each group"""
  groupValues_value
}

input ScriptInput {
  hypi: HypiInput
  type: TanType!
  name: String!
  body: String!
}

input CounterGroupByOptions {
  """The field by which to to group the matching data"""
  field: CounterScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input ObjectSubjectRatingTripletMaths {
  subjectId: MathInputInt
  objectId: MathInputInt
  rating: MathInputFloat
}

input PolicyInput {
  realms: [RealmLinkInput!]
  clients: [AuthClientInput!]
  roles: [RoleInput!]
  name: String!
  policies: [PolicyInput!]
  groups: [GroupInput!]
  from: DateTime
  hypi: HypiInput
  logic: AuthLogic
  to: DateTime
  accounts: [AccountInput!]
  decisionStrategy: DecisionStrategy
}

"""Scalar fields defined by StripeFraudDetails"""
enum StripeFraudDetailsScalarFields {
  """Assessments from Stripe. If set, the value is fraudulent."""
  stripe_report

  """
  Assessments reported by you. If set, possible values of are safe and fraudulent.
  """
  user_report
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type Password {
  hypi: Hypi

  """
   password is never returned
   further, the @secret directive enforces this, queries can be use to perform comparison against the field but it is never returned
   
  """
  value: String!
  expired: Boolean
}

"""Scalar fields defined by StripeCustomerAcceptance"""
enum StripeCustomerAcceptanceScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input OAuth2AuthorizedClientInputOpt {
  hypi: HypiInputOpt
  clientRegistrationId: String
  principalName: String
  accessToken: String
  refreshToken: String
}

input StripeRefundGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeRefundScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by RealmPolicy"""
enum RealmPolicyFields {
  hypi
  name

  """Positive` or `Negative"""
  logic
  realms
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeErrorGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeErrorScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input GeoEnvelopeInputOpt {
  hypi: HypiInputOpt
  p1: CoordinateInputOpt
  p2: CoordinateInputOpt
}

input StripeItemReasonInputOpt {
  hypi: HypiInputOpt
  line_item_ids: [StripeInvoiceLineItemInputOpt]
  usage_gte: Int
}

"""Scalar fields defined by Organisation"""
enum OrganisationScalarFields {
  name
  incorporated
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""A list of all types in the app"""
enum HypiSchemaType {
  Product
  PageInfo
  HypiResultEdge
  HypiFilterConnection
  HypiEnv
  Pair
  AggInt
  AggFloat
  AggOtherScalar
  Script

  """Defines the templates that should be applied to a given HTTP request"""
  RequestTemplate
  NotificationCtx
  Notification
  URL
  Currency
  Coordinate
  GeoEnvelope
  Language
  Address
  PersonName
  Phone
  Email
  Password
  RemoteLogin
  LoginAttempt
  BruteForceDetectionOptions
  OAuth2AuthorizedClient

  """
  A client defines an agent that acts on behalf of a user/subject.
  Currently implicitly created by Hypi.
  """
  AuthClient
  ABACPolicy
  ABACTag
  Image
  EmailVerification

  """
  Defines a Hypi template that can be parameterised
  https://documentation.Hypi.com/en/latest/api-templates.html#store-new-template
  """
  EmailTemplate
  EmailSendingAttempt

  """
  To reset an Account's password, create a `PasswordReminder`.
  
  This will generate a code in the `code` field that can be referenced using $!{parent.code} in the `htmlMessage` or `plainTextMessage` fields.
  
  This will send an email to the email in the `to` field. In the message you should provide a link to a URL where the user can enter their new password.
  Include the code in this URL e.g. https://my-app.com/reset-password?code=$!{parent.code}.
  
  When the user gets to this page, you will have the password reset code in the URL query string. Get this code from the URL
  and when the user enter their new password, make a POST request to the Hypi API e.g.
  POST <hypi-domain>/email/reset/<domain> - where <domain> is app instance domain.
  
  In the body of the request send a JSON like this:
  {"code": "<the-code-from-the-URL>", "password": "<the-user's-new-password>"}
  
  Hypi will change the user's password and return HTTP status 200.
  """
  PasswordReminder

  """
  Defines a web hook that can be used to trigger Hypi GraphQL functions on a given app.
  The account specified in the web hook must have access to the app/instance and must be authorised to call the functions specified.
  """
  Webhook

  """
  If the query or mutation functions in the Webhook definition returns this then it controls what the server responds with
  For example, the GraphQL function can return a 301 or 302 status and a Location header to an external URL to cause a redirect.
  """
  WebhookResponse
  LogMessage

  """Creates a reference to a GraphQL function in an app instance."""
  GraphQLRef
  WorkflowStepData
  WorkflowStep
  AccessToken

  """
  A row is created for every resource. It cannot be created or modified by end users.
  The ID of each entry is a hash of the resource ID, type and field.
  When the resource is deleted, the entry is deleted.
  """
  StorageCounter
  PermissionDescription
  Hypi

  """
  Identifies a given country according to ISO3166
  https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes
  See also https://www.iso.org/obp/ui/#search and
  https://unicode-org.github.io/cldr-staging/charts/37/supplemental/territory_information.html
  """
  Country
  Account
  Person
  Organisation
  OAuthProvider

  """ namespace for containing authz objects and their relationships."""
  Realm

  """Defines a collection for subjects, roles, policies and permissions."""
  Group
  Role
  RolePolicy
  ClientPolicy
  TimePolicy
  AggregatedPolicy
  GroupPolicy
  AccountPolicy
  RealmPolicy
  RealmLink
  Permission
  File
  Video

  """
  Creates a new outbound message.
  Note that it automatically send unless the autoSend field is false
  """
  EmailMessage

  """
  A workflow defines a sequence of steps that execute in a defined order (you set the order field on each step).
  It is one way in which Hypi allows you to do composition, so similarities can be drawn to function composition with some specifics thrown in for Hypi and GraphQL.
  
  If two steps have the same order their execution order is undefined with relation to each other.
  Every step has a GraphQL function that is executed for that step.
  
  When a Workflow is executed it creates a WorkflowSession. The result of each step in the workflow is added to the session.
  
  The first step can have any parameters you want. For the other steps there are some rules that define how the system maps
  parameters to the function in these steps. These rules are:
  
  1. Any step (including the first step) can have a parameter "params: Json" i.e. name = params and type is Json.
  This params is a map of the arguments passed to the first function in the Workflow. For example if the function was defined as
  step1(a: Int, b: Json, c: MyType): T
  in this case the "params" Json object would be have the fields a, b and c set to the values the function was executed with.
  Normally, this is used in the first step but can be used in any step that wants access to this data.
  
  2. Any step can have a parameter "session: WorkflowSession" - this is the current workflow's session and contains the results of all steps before the current one.
  You can identify the results for a specific step by finding the result using the step's name in the session's data array.
  
  3. Except the first step, a parameter "previous: T" where T is the result type of the previous step can be used.
  In this case, the platform will use the output of the previous function for this parameter.
  Note that if the type is not the same as the last step's output type then the workflow will fail if the field is not optional.
  If the field is optional then the platform will not provide it and it would therefore be null if you try to use it.
  
  4. Except the first step, pass-through is possible. This is where the parameters from the first step are passed through
  to other steps by name and type. i.e. given
  step1(a: Int, b: String): String
  step2(a: Int): ID
  In this case, the variable "a" in both step1 and step2 will have the same value that step1 was executed with.
  Incidentally, this is the same as getting "a" from the "params" Json.
  """
  Workflow
  WorkflowSession
  Counter
  Gauge
  ServerlessResponse
  LearningEnvironment
  RecommendationModel
  KMeanCLusteringModel
  RecommendationTrainer
  ObjectSubjectRatingTriplet
  PredictionData
  TrainingInstance
  InvoiceItem
  PricePlanInclusion
  StripeOrder
  StripeReview
  StripeTransfer
  StripeTransferData
  StripeFraudDetails
  StripeShippingInfo
  StripeBillingDetails
  StripeAddress

  """
  A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate.
  https://stripe.com/docs/disputes
  """
  StripeDispute

  """
  Events are our way of letting you know when something interesting happens in your account. When an interesting event occurs, we create a new Event object. For example, when a charge succeeds, we create a charge.succeeded event; and when an invoice payment attempt fails, we create an invoice.payment_failed event. Note that many API requests may cause multiple events to be created. For example, if you create a new subscription for a customer, you will receive both a customer.subscription.created event and a charge.succeeded event.
  
  Events occur when the state of another API resource changes. The state of that resource at the time of the change is embedded in the event's data field. For example, a charge.succeeded event will contain a charge, and an invoice.payment_failed event will contain an invoice.
  https://stripe.com/docs/api/events
  """
  StripeEvent

  """ Mandate is a record of the permission a customer has given you to debit their payment method.
  """
  StripeMandate
  StripePaymentMethodDetails
  StripeCustomerAcceptance

  """
  A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. You can retrieve individual payouts, as well as list all payouts. Payouts are made on varying schedules, depending on your country and industry.
  https://stripe.com/docs/api/payouts
  """
  StripePayout
  StripePackageDimensions
  StripeTransformQuantity
  StripeTier
  StripePriceRecurrence

  """
  Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.
  https://stripe.com/docs/api/refunds
  """
  StripeRefund

  """
  PaymentMethod objects represent your customer's payment instruments. They can be used with PaymentIntents to collect payments or saved to Customer objects to store instrument details for future payments.
  https://stripe.com/docs/api/payment_methods
  """
  StripePaymentMethod
  StripeSebaDebit
  StripeIdeal
  StripeFpx
  StripeCardPresent
  StripeReceipt
  StripeBacsDebit
  StripeAuBecsDebit

  """
  These bank accounts are payment methods on Customer objects.
  
  On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well, and are documented in the links above.
  https://stripe.com/docs/api/customer_bank_accounts
  """
  StripeBankAccount

  """
  Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers.
  https://stripe.com/docs/api/sources
  """
  StripeSource

  """
  A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges.
  https://stripe.com/docs/api/coupons
  """
  StripeCoupon

  """
  Issue a credit note to adjust an invoice's amount after the invoice is finalized.
  https://stripe.com/docs/api/credit_notes
  """
  StripeCreditNote

  """
  Each customer has a balance value, which denotes a debit or credit that's automatically applied to their next invoice upon finalization. You may modify the value directly by using the update customer API, or by creating a Customer Balance Transaction, which increments or decrements the customer's balance by the specified amount.
  https://stripe.com/docs/api/customer_balance_transactions
  """
  StripeCustomerBalanceTransaction

  """
  A session describes the instantiation of the customer portal for a particular customer. By visiting the session's URL, the customer can manage their subscriptions and billing details. For security reasons, sessions are short-lived and will expire if the customer does not visit the URL. Create sessions on-demand when customers intend to manage their subscriptions and billing details.
  https://stripe.com/docs/api/customer_portal
  """
  StripeCustomerPortal

  """
  You can add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer.
  https://stripe.com/docs/api/customer_tax_ids
  """
  StripeTaxId

  """
  A discount represents the actual application of a coupon to a particular customer. It contains information about when the discount began and when it will end.
  https://stripe.com/docs/api/discounts
  """
  StripeDiscount
  StripeTaxAmount
  StripeDiscountAmount
  StripeStatusTransitions

  """https://stripe.com/docs/api/invoices/line_item"""
  StripeInvoiceLineItem
  StripePeriod

  """
  A Promotion Code represents a customer-redeemable code for a coupon. It can be used to create multiple codes for a single coupon.
  https://stripe.com/docs/api/promotion_codes
  """
  StripePromotionCode
  StripeIntervalObject
  StripePauseCollection
  StripePlan
  StripeBillingThreshold
  StripeSubscriptionScheduleSettings
  StripeInvoiceSettings

  """
  Tax rates can be applied to invoices, subscriptions and Checkout Sessions to collect tax.
  
  https://stripe.com/docs/api/tax_rates
  """
  StripeTaxRate

  """
  Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices.
  https://stripe.com/docs/api/usage_records
  """
  StripeUsageRecord

  """
  A Checkout Session represents your customer's session as they pay for one-time purchases or subscriptions through Checkout. We recommend creating a new Session each time your customer attempts to pay.
  
  Once payment is successful, the Checkout Session will contain a reference to the Customer, and either the successful PaymentIntent or an active Subscription.
  
  You can create a Checkout Session on your server and pass its ID to the client to begin Checkout.
  
  https://stripe.com/docs/api/checkout/sessions
  """
  StripeCheckoutSession
  StripeError
  StripeNextAction
  StripeAliPayHandleRedirect
  StripeOxxoDisplayDetails
  StripeRedirectToUrl
  StripeSofort
  StripeReference

  """"""
  Invoice
  PricePlanAllowance
  PricePlan

  """
  A Stripe API Charge to a card.
  https://stripe.com/docs/api/charges
  
  To charge a credit or a debit card, you create a Charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique, random ID.
  """
  StripeCharge
  StripeChargeOutcome

  """
  Customer objects allow you to perform recurring charges, and to track multiple charges, that are associated with the same customer. The API allows you to create, delete, and update your customers. You can retrieve individual customers as well as a list of all your customers.
  https://stripe.com/docs/api/customers
  """
  StripeCustomer

  """
  Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Checkout and Subscriptions.
  https://stripe.com/docs/api/products
  """
  StripeProduct

  """
  Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Products help you track inventory or provisioning, and prices help you track payment terms. Different physical goods or levels of service should be represented by products, and pricing options should be represented by prices. This approach lets you change prices without having to change your provisioning scheme.
  
  For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.
  https://stripe.com/docs/api/prices
  https://stripe.com/docs/api/prices/object
  """
  StripePrice

  """
  Invoices are statements of amounts owed by a customer, and are either generated one-off, or generated periodically from a subscription.
  
  They contain invoice items, and proration adjustments that may be caused by subscription upgrades/downgrades (if necessary).
  
  If your invoice is configured to be billed through automatic charges, Stripe automatically finalizes your invoice and attempts payment. Note that finalizing the invoice, when automatic, does not happen immediately as the invoice is created. Stripe waits until one hour after the last webhook was successfully sent (or the last webhook timed out after failing). If you (and the platforms you may have connected to) have no webhooks configured, Stripe waits one hour after creation to finalize the invoice.
  
  If your invoice is configured to be billed by sending an email, then based on your email settings, Stripe will email the invoice to your customer and await payment. These emails can contain a link to a hosted page to pay the invoice.
  
  Stripe applies any customer credit on the account before determining the amount due for the invoice (i.e., the amount that will be actually charged). If the amount due for the invoice is less than Stripe's minimum allowed charge per currency, the invoice is automatically marked paid, and we add the amount due to the customer's running account balance which is applied to the next invoice.
  
  https://stripe.com/docs/api/invoices
  """
  StripeInvoice
  StripeThesholdReason
  StripeItemReason

  """
  Sometimes you want to add a charge or credit to a customer, but actually charge or credit the customer's card only at the end of a regular billing cycle. This is useful for combining several charges (to minimize per-transaction fees), or for having Stripe tabulate your usage-based billing totals.
  https://stripe.com/docs/api/invoiceitems
  """
  StripeInvoiceItem

  """
  Subscriptions allow you to charge a customer on a recurring basis.
  
  https://stripe.com/docs/api/subscriptions
  """
  StripeSubscription
  StripeSubscriptionUpdate

  """
  Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships.
  https://stripe.com/docs/api/subscription_items
  """
  StripeSubscriptionItem

  """
  A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.
  
  https://stripe.com/docs/api/subscription_schedules
  """
  StripeSubscriptionSchedule
  StripeSubscriptionPhase

  """
  A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session.
  
  A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge.
  https://stripe.com/docs/api/payment_intents
  """
  StripePaymentIntent
  StripeSetupIntent
}

input StripeAuBecsDebitGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeAuBecsDebitScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type RealmLinkAggs {
  name: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeSubscriptionPhaseAggs {
  end_date: AggInt
  start_date: AggInt
  billing_cycle_anchor: AggOtherScalar
  collection_method: AggOtherScalar
  proration_behavior: AggOtherScalar
  trial_end: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeNextAction"""
enum StripeNextActionScalarFields {
  type
  id
  use_stripe_sdk
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeInvoiceAggs {
  id: AggOtherScalar
  auto_advance: AggOtherScalar
  collection_method: AggOtherScalar
  currency: AggOtherScalar
  description: AggOtherScalar
  hosted_invoice_url: AggOtherScalar
  metadata: AggOtherScalar
  period_end: AggInt
  period_start: AggInt
  status: AggOtherScalar
  total: AggInt
  object: AggOtherScalar
  account_country: AggOtherScalar
  account_name: AggOtherScalar
  amount_due: AggInt
  amount_paid: AggInt
  amount_remaining: AggInt
  attempt_count: AggInt
  attempted: AggOtherScalar
  billing_reason: AggOtherScalar
  created: AggInt
  customer_email: AggOtherScalar
  customer_name: AggOtherScalar
  customer_phone: AggOtherScalar
  customer_tax_exempt: AggOtherScalar
  due_date: AggInt
  ending_balance: AggInt
  footer: AggOtherScalar
  invoice_pdf: AggOtherScalar
  livemode: AggOtherScalar
  next_payment_attempt: AggInt
  number: AggOtherScalar
  paid: AggOtherScalar
  post_payment_credit_notes_amount: AggInt
  pre_payment_credit_notes_amount: AggInt
  receipt_number: AggOtherScalar
  starting_balance: AggInt
  statement_descriptor: AggOtherScalar
  subscription_proration_date: AggInt
  subtotal: AggInt
  tax: AggInt
  webhooks_delivered_at: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input RolePolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: RolePolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

enum StripePaymentMethds {
  alipay
  au_becs_debit
  bacs_debit
  bancontact
  card
  eps
  fpx
  giropay
  ideal
  oxxo
  p24
  sepa_debit
  sofort
}

type AccountPolicyAggs {
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeSubscriptionScheduleSettingsInputOpt {
  hypi: HypiInputOpt
  billing_cycle_anchor: StripeBillingCycleAnchor
  billing_thresholds: StripeBillingThresholdInputOpt
  collection_method: StripeCollectionMethod
  default_payment_method: StripePaymentMethodInputOpt
  invoice_settings: StripeInvoiceSettingsInputOpt
}

input StripeTaxRateGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTaxRateScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by Account"""
enum AccountScalarFields {
  verified
  enabled
  username
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by Language"""
enum LanguageScalarFields {
  family
  isoName
  nativeName
  iso6391Code
  iso6392TCode
  iso6392BCode
  iso6393Code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

""""""
type Invoice {
  hypi: Hypi
  buyer: Account
  seller: Account
  due_date: DateTime
  notes: String
  vat_amount: Float
  items(arcql: String, first: Int, after: String, last: Int, before: String): [InvoiceItem!]
}

input StripeTransferDataGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTransferDataScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input PasswordReminderInputOpt {
  hypi: HypiInputOpt
  valid: Boolean
  code: String
  to: EmailInputOpt
  from: String
  subject: String
  htmlMessage: String
  plainTextMessage: String
}

input StripeTaxRateInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input StripeCustomerAcceptanceGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCustomerAcceptanceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeSubscriptionPhase"""
enum StripeSubscriptionPhaseFields {
  hypi
  end_date
  start_date
  add_invoice_items
  billing_cycle_anchor
  billing_thresholds
  collection_method
  coupon
  default_payment_method
  invoice_settings
  items
  proration_behavior
  trial_end
  default_tax_rates
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type Subscription {
  """Subscribe to mutations on the given type."""
  subscribe(id: String): HypiSubscriptionUnion!
}

"""All fields defined by Organisation"""
enum OrganisationFields {
  hypi
  name
  logo
  incorporated
  addresses
  phones
  emails
  members
  subsidiaries
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by Address"""
enum AddressFields {
  hypi
  door
  street
  town
  county
  city
  country
  postCode

  """  country: Country"""
  from
  to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input WebhookResponseInputOpt {
  hypi: HypiInputOpt
  status: Int
  headers: Json
  body: Json
}

input StripeIntervalObjectMaths {
  interval_count: MathInputInt
}

"""
The precedence of the operations follows BODMAS. https://en.wikipedia.org/wiki/Order_of_operations
For clarity if all fields are specified the precedence is:
1. Divsion
2. Multiplication
3. Subtraction
4. Addition
"""
input MathInputInt {
  div: Int
  times: Int
  minus: Int
  plus: Int
  hypi: HypiInput!
}

input PasswordInput {
  hypi: HypiInput
  value: String!
  expired: Boolean
}

input StripeTaxRateInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeCheckoutSessionGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCheckoutSessionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeRedirectToUrlInputOpt {
  hypi: HypiInputOpt
  return_url: String
  url: String
}

input StripeRedirectToUrlInput {
  hypi: HypiInput
  return_url: String
  url: String
}

"""Scalar fields defined by RequestTemplate"""
enum RequestTemplateScalarFields {
  name
  request
  response
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeThesholdReasonInputOpt {
  hypi: HypiInputOpt
  amount_gte: Int
  item_reasons: [StripeItemReasonInputOpt]
}

input GaugeInputOpt {
  hypi: HypiInputOpt
  name: String
  label: String
  tags: [String]
  value: Float
}

type StripeBillingDetails {
  hypi: Hypi

  """Billing address."""
  address: StripeAddress

  """Email address."""
  email: String

  """Full name."""
  name: String

  """Billing phone number (including extension)."""
  phone: String
}

input StripeNextActionGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeNextActionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input GeoEnvelopeInput {
  hypi: HypiInput
  p1: CoordinateInput!
  p2: CoordinateInput!
}

type WebhookResponseAggs {
  status: AggInt
  headers: AggOtherScalar
  body: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type Coordinate {
  hypi: Hypi
  x: Float!
  y: Float!
}

"""Scalar fields defined by StripeDiscount"""
enum StripeDiscountScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by Invoice"""
enum InvoiceScalarFields {
  due_date
  notes
  vat_amount
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
Identifies a given country according to ISO3166
https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes
See also https://www.iso.org/obp/ui/#search and
https://unicode-org.github.io/cldr-staging/charts/37/supplemental/territory_information.html
"""
type Country {
  hypi: Hypi
  name: String!
  stateName: String
  sovereignty: String
  alpha2code: String
  alpha3code: String
  numericCode: String
  subdivisionCodeLinks: String
  internetCCTLD: String
  continent: String
  officialLanguage: Language
  currencies(arcql: String, first: Int, after: String, last: Int, before: String): [Currency!]
  languagesSpoken(arcql: String, first: Int, after: String, last: Int, before: String): [Language!]
}

type StripeCreditNoteAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type RecommendationTrainerAggs {
  maxIterations: AggInt
  minMdlImprovement: AggFloat
  batchSize: AggInt
  learningRate: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeRefund"""
enum StripeRefundScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input FileGroupByOptions {
  """The field by which to to group the matching data"""
  field: FileScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input WorkflowSessionGroupByOptions {
  """The field by which to to group the matching data"""
  field: WorkflowSessionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeAddressGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeAddressScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by Product"""
enum ProductNumericFields {
  price
}

"""Scalar fields defined by PasswordReminder"""
enum PasswordReminderScalarFields {
  """If true the reset code has not yet been used."""
  valid

  """
  The verification code that is included in the email sent. Generated by the server, if provided the provided value is ignored
  """
  code

  """
  Optionally, the email from which the email will be sent. You MUST have a Hypi email app configured to send from this address
  """
  from

  """
  Optionally, the subject of the email, this is a velocity template - Hypi provides a default such as "Please verify your email to <realm>"
  """
  subject

  """
   The HTML contents of the email. This is a Velocity template that will be rendered before being sent.
   The available variables and their types are:
   instance: AppId - You app instance ID
   parent - a map representing the current EmailVerification object
   value - the value of the htmlMessage field
   env: HypiEnv
   
  """
  htmlMessage

  """
  A plain text version of the email - see this is a velocity template, see htmlMessage for available variables
  """
  plainTextMessage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId

  """The Account email that needs to be changed"""
  to_value

  """The Account email that needs to be changed"""
  to_type
}

input PhoneInputOpt {
  hypi: HypiInputOpt
  number: String
  country: CountryInputOpt
  code: String
}

"""Scalar fields defined by Phone"""
enum PhoneScalarFields {
  number
  code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeSubscriptionInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  cancel_at_period_end: Boolean
  current_period_end: Int
  current_period_start: Int
  customer: StripeCustomerInputOpt
  default_payment_method: StripePaymentMethodInputOpt
  items: [StripeSubscriptionItemInputOpt]
  latest_invoice: StripeInvoiceInputOpt
  metadata: Json
  pending_setup_intent: StripeSetupIntentInputOpt
  pending_update: StripeSubscriptionUpdateInputOpt
  status: StripeSubscriptionStatus
  billing_cycle_anchor: Int
  billing_thresholds: StripeBillingThresholdInputOpt
  cancel_at: Int
  canceled_at: Int
  collection_method: StripeCollectionMethod
  created: Int
  days_until_due: Int
  default_source: StripeSourceInputOpt
  default_tax_rates: [StripeTaxRateInputOpt]
  discount: StripeDiscountInputOpt
  ended_at: Int
  livemode: Boolean
  next_pending_invoice_item_invoice: Int
  pause_collection: StripePauseCollectionInputOpt
  pending_invoice_item_interval: StripeIntervalObjectInputOpt
  schedule: StripeSubscriptionScheduleInputOpt
  start_date: Int
  trial_end: Int
  trial_start: Int
}

input StripeThesholdReasonInput {
  hypi: HypiInput
  amount_gte: Int
  item_reasons: [StripeItemReasonInput!]
}

input RemoteLoginInputOpt {
  hypi: HypiInputOpt
  type: String
  email: String
  remoteId: String
  otherAttributes: Json
}

type PricePlan {
  hypi: Hypi
  allowance: PricePlanAllowance
  bill_to: Account
  billing_frequency: TimeUnit

  """
  Remote card ID e.g. Stripe, BrainTree or other third party card ID that this plan bills
  In invoices create credit on the price plan then payment is made to this card
  """
  default_card: String
  valid_from: DateTime
  valid_to: DateTime
  invoices(arcql: String, first: Int, after: String, last: Int, before: String): [Invoice]
}

"""All fields defined by PermissionDescription"""
enum PermissionDescriptionFields {
  hypi
  roles
  groups
  organisations
  realms
  permissions
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeAddress {
  hypi: Hypi

  """Address line 1 (e.g., street, PO Box, or company name)."""
  line1: String

  """Address line 2 (e.g., apartment, suite, unit, or building)."""
  line2: String

  """City, district, suburb, town, or village."""
  city: String

  """Two-letter country code (ISO 3166-1 alpha-2)."""
  country: String

  """State, county, province, or region."""
  state: String

  """ZIP or postal code."""
  postal_code: String
}

"""Scalar fields defined by Hypi"""
enum HypiScalarFields {
  """
  An ID automatically generated by the platform for new objects.
  If provided and the ID does not exist, the provided ID is used instead of a generated one and a new entry is inserted
  If provided and the ID already exists then the existing object is updated.
  """
  id

  """
  When you work with interface fields, Hypi is unable to distinguish which implementation you intend to use
  automatically, you must set this field to the name of the implementation of the interface e.g.
  If creating an AccountPolicy which implements the Policy interface, this field should be set to AccountPolicy
  """
  impl

  """The ISO8601 date of when the object was created"""
  created

  """The ISO8601 date of when the object was last modified"""
  updated

  """
  The ISO8601 date of when the object was trashed (if it is currently trashed, null otherwise)
  """
  trashed

  """The ID of the account which created the object"""
  createdBy

  """The ID of the app instance which created and owns the object"""
  instanceId
}

type StripeSetupIntentAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  client_secret: AggOtherScalar
  description: AggOtherScalar
  metadata: AggOtherScalar
  status: AggOtherScalar
  cncellation_reason: AggOtherScalar
  created: AggInt
  livemode: AggOtherScalar
  usage: AggOtherScalar
  payment_method_types: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeCardPresent"""
enum StripeCardPresentScalarFields {
  brand
  cardholder_name
  country
  emv_auth_data
  exp_month
  exp_year
  fingerprint
  funding
  generated_card
  last4
  network
  read_method
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input LoginAttemptGroupByOptions {
  """The field by which to to group the matching data"""
  field: LoginAttemptScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type CoordinateAggs {
  x: AggFloat
  y: AggFloat
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input URLInputOpt {
  hypi: HypiInputOpt
  path: String
  queryParams: Json
  port: Int
  host: String
}

"""A list of types which can be subscribed to"""
type HypiSubscriptionUnion {
  Product: Product
  PageInfo: PageInfo
  HypiResultEdge: HypiResultEdge
  HypiFilterConnection: HypiFilterConnection
  HypiEnv: HypiEnv
  Pair: Pair
  AggInt: AggInt
  AggFloat: AggFloat
  AggOtherScalar: AggOtherScalar
  Script: Script
  RequestTemplate: RequestTemplate
  NotificationCtx: NotificationCtx
  Notification: Notification
  URL: URL
  Currency: Currency
  Coordinate: Coordinate
  GeoEnvelope: GeoEnvelope
  Language: Language
  Address: Address
  PersonName: PersonName
  Phone: Phone
  Email: Email
  Password: Password
  RemoteLogin: RemoteLogin
  LoginAttempt: LoginAttempt
  BruteForceDetectionOptions: BruteForceDetectionOptions
  OAuth2AuthorizedClient: OAuth2AuthorizedClient
  AuthClient: AuthClient
  ABACPolicy: ABACPolicy
  ABACTag: ABACTag
  Image: Image
  EmailVerification: EmailVerification
  EmailTemplate: EmailTemplate
  EmailSendingAttempt: EmailSendingAttempt
  PasswordReminder: PasswordReminder
  Webhook: Webhook
  WebhookResponse: WebhookResponse
  LogMessage: LogMessage
  GraphQLRef: GraphQLRef
  WorkflowStepData: WorkflowStepData
  WorkflowStep: WorkflowStep
  AccessToken: AccessToken
  StorageCounter: StorageCounter
  PermissionDescription: PermissionDescription
  Hypi: Hypi
  Country: Country
  Account: Account
  Person: Person
  Organisation: Organisation
  OAuthProvider: OAuthProvider
  Realm: Realm
  Group: Group
  Role: Role
  RolePolicy: RolePolicy
  ClientPolicy: ClientPolicy
  TimePolicy: TimePolicy
  AggregatedPolicy: AggregatedPolicy
  GroupPolicy: GroupPolicy
  AccountPolicy: AccountPolicy
  RealmPolicy: RealmPolicy
  RealmLink: RealmLink
  Permission: Permission
  File: File
  Video: Video
  EmailMessage: EmailMessage
  Workflow: Workflow
  WorkflowSession: WorkflowSession
  Counter: Counter
  Gauge: Gauge
  ServerlessResponse: ServerlessResponse
  LearningEnvironment: LearningEnvironment
  RecommendationModel: RecommendationModel
  KMeanCLusteringModel: KMeanCLusteringModel
  RecommendationTrainer: RecommendationTrainer
  ObjectSubjectRatingTriplet: ObjectSubjectRatingTriplet
  PredictionData: PredictionData
  TrainingInstance: TrainingInstance
  InvoiceItem: InvoiceItem
  PricePlanInclusion: PricePlanInclusion
  StripeOrder: StripeOrder
  StripeReview: StripeReview
  StripeTransfer: StripeTransfer
  StripeTransferData: StripeTransferData
  StripeFraudDetails: StripeFraudDetails
  StripeShippingInfo: StripeShippingInfo
  StripeBillingDetails: StripeBillingDetails
  StripeAddress: StripeAddress
  StripeDispute: StripeDispute
  StripeEvent: StripeEvent
  StripeMandate: StripeMandate
  StripePaymentMethodDetails: StripePaymentMethodDetails
  StripeCustomerAcceptance: StripeCustomerAcceptance
  StripePayout: StripePayout
  StripePackageDimensions: StripePackageDimensions
  StripeTransformQuantity: StripeTransformQuantity
  StripeTier: StripeTier
  StripePriceRecurrence: StripePriceRecurrence
  StripeRefund: StripeRefund
  StripePaymentMethod: StripePaymentMethod
  StripeSebaDebit: StripeSebaDebit
  StripeIdeal: StripeIdeal
  StripeFpx: StripeFpx
  StripeCardPresent: StripeCardPresent
  StripeReceipt: StripeReceipt
  StripeBacsDebit: StripeBacsDebit
  StripeAuBecsDebit: StripeAuBecsDebit
  StripeBankAccount: StripeBankAccount
  StripeSource: StripeSource
  StripeCoupon: StripeCoupon
  StripeCreditNote: StripeCreditNote
  StripeCustomerBalanceTransaction: StripeCustomerBalanceTransaction
  StripeCustomerPortal: StripeCustomerPortal
  StripeTaxId: StripeTaxId
  StripeDiscount: StripeDiscount
  StripeTaxAmount: StripeTaxAmount
  StripeDiscountAmount: StripeDiscountAmount
  StripeStatusTransitions: StripeStatusTransitions
  StripeInvoiceLineItem: StripeInvoiceLineItem
  StripePeriod: StripePeriod
  StripePromotionCode: StripePromotionCode
  StripeIntervalObject: StripeIntervalObject
  StripePauseCollection: StripePauseCollection
  StripePlan: StripePlan
  StripeBillingThreshold: StripeBillingThreshold
  StripeSubscriptionScheduleSettings: StripeSubscriptionScheduleSettings
  StripeInvoiceSettings: StripeInvoiceSettings
  StripeTaxRate: StripeTaxRate
  StripeUsageRecord: StripeUsageRecord
  StripeCheckoutSession: StripeCheckoutSession
  StripeError: StripeError
  StripeNextAction: StripeNextAction
  StripeAliPayHandleRedirect: StripeAliPayHandleRedirect
  StripeOxxoDisplayDetails: StripeOxxoDisplayDetails
  StripeRedirectToUrl: StripeRedirectToUrl
  StripeSofort: StripeSofort
  StripeReference: StripeReference
  Invoice: Invoice
  PricePlanAllowance: PricePlanAllowance
  PricePlan: PricePlan
  StripeCharge: StripeCharge
  StripeChargeOutcome: StripeChargeOutcome
  StripeCustomer: StripeCustomer
  StripeProduct: StripeProduct
  StripePrice: StripePrice
  StripeInvoice: StripeInvoice
  StripeThesholdReason: StripeThesholdReason
  StripeItemReason: StripeItemReason
  StripeInvoiceItem: StripeInvoiceItem
  StripeSubscription: StripeSubscription
  StripeSubscriptionUpdate: StripeSubscriptionUpdate
  StripeSubscriptionItem: StripeSubscriptionItem
  StripeSubscriptionSchedule: StripeSubscriptionSchedule
  StripeSubscriptionPhase: StripeSubscriptionPhase
  StripePaymentIntent: StripePaymentIntent
  StripeSetupIntent: StripeSetupIntent
}

"""All fields defined by StripeInvoiceItem"""
enum StripeInvoiceItemFields {
  hypi
  id
  amount
  currency
  customer
  description
  metadata
  period
  price
  proration
  object
  date
  discountable
  invoice
  livemode
  quantity
  subscription
  subscription_item
  unit_amount
  unit_amount_decimal
  discounts
  tax_rates
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input ServerlessResponseGroupByOptions {
  """The field by which to to group the matching data"""
  field: ServerlessResponseScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input TrainingInstanceInputOpt {
  hypi: HypiInputOpt
  model: MLModelInputOpt
  status: TrainingStatus
  errors: [String]
}

type WorkflowStepAggs {
  name: AggOtherScalar
  order: AggInt
  execAs: AggOtherScalar
  async: AggOtherScalar
  maxExecutionTime: AggOtherScalar
  repeatN: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  fn_type: AggOtherScalar
  fn_field: AggOtherScalar
  fn_selection: AggOtherScalar
  evaluateIf_type: AggOtherScalar
  evaluateIf_field: AggOtherScalar
  evaluateIf_selection: AggOtherScalar
  repeatIf_type: AggOtherScalar
  repeatIf_field: AggOtherScalar
  repeatIf_selection: AggOtherScalar
}

"""All fields defined by OAuth2AuthorizedClient"""
enum OAuth2AuthorizedClientFields {
  hypi
  clientRegistrationId
  principalName
  accessToken
  refreshToken
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by Role"""
enum RoleScalarFields {
  name
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input WorkflowMaths {
  repeatN: MathInputInt
}

"""Scalar fields defined by StripeCoupon"""
enum StripeCouponScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeSofortInputOpt {
  hypi: HypiInputOpt
  country: StripeSofortCountry
  id: String
  object: String
}

"""All numeric fields defined by StripeIntervalObject"""
enum StripeIntervalObjectNumericFields {
  interval_count
}

input StripeCouponInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input ObjectSubjectRatingTripletInputOpt {
  hypi: HypiInputOpt
  subjectId: Int
  objectId: Int
  rating: Float
}

"""All numeric fields defined by ObjectSubjectRatingTriplet"""
enum ObjectSubjectRatingTripletNumericFields {
  subjectId
  objectId
  rating
}

type StripeReference {
  hypi: Hypi
  entity: String
  key: String
  value: String
}

type LogMessage {
  hypi: Hypi
  level: LogLevel!
  message: String
  stackTrace: String

  """Optional, may not be a stacktrace"""
  releaseId: String

  """This is optional, we can have system messages that aren't from an app"""
  type: String

  """
  The name of the GraphQL type that the log is for, this is also optional
  """
  workflow: String
}

"""
Tax rates can be applied to invoices, subscriptions and Checkout Sessions to collect tax.

https://stripe.com/docs/api/tax_rates
"""
type StripeTaxRate {
  hypi: Hypi
  id: String
  object: String
}

"""The frequency at which a subscription is billed."""
enum StripeBillingFrequency {
  day
  week
  month
  year
}

input AddressGroupByOptions {
  """The field by which to to group the matching data"""
  field: AddressScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type CountryAggs {
  name: AggOtherScalar
  stateName: AggOtherScalar
  sovereignty: AggOtherScalar
  alpha2code: AggOtherScalar
  alpha3code: AggOtherScalar
  numericCode: AggOtherScalar
  subdivisionCodeLinks: AggOtherScalar
  internetCCTLD: AggOtherScalar
  continent: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type ProductAggs {
  title: AggOtherScalar
  description: AggOtherScalar
  price: AggFloat
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input EmailVerificationGroupByOptions {
  """The field by which to to group the matching data"""
  field: EmailVerificationScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeShippingInfo"""
enum StripeShippingInfoFields {
  hypi

  """Shipping address."""
  address

  """
  The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc.
  """
  carrier

  """Recipient name."""
  name

  """Recipient phone (including extension)."""
  phone

  """
  The tracking number for a physical product, obtained from the delivery service. If multiple tracking numbers were generated for this purchase, please separate them with commas.
  """
  tracking_number
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeTier"""
enum StripeTierScalarFields {
  """Price for the entire tier."""
  flat_amount

  """
  Same as flat_amount, but contains a decimal value with at most 12 decimal places.
  """
  flat_amount_decimal

  """Per unit price for units relevant to the tier."""
  unit_amount

  """
  Same as unit_amount, but contains a decimal value with at most 12 decimal places.
  """
  unit_amount_decimal

  """Up to and including to this quantity will be contained in the tier."""
  up_to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeSubscriptionItemInput {
  hypi: HypiInput
  id: String
  object: String
  metadata: Json
  price: StripePriceInput
  plan: StripePlanInput
  quantity: Int
  subscription: StripeSubscriptionInput
  billing_thresholds: StripeBillingThresholdInput
  created: Int
  tax_rates: [StripeTaxRateInput!]
}

input StripeShippingInfoInput {
  hypi: HypiInput
  address: StripeAddressInput
  carrier: String
  name: String
  phone: String
  tracking_number: String
}

input StripeCustomerPortalGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCustomerPortalScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type AggInt {
  hypi: Hypi

  """The value of the aggregated field for each group"""
  groupValues: [Pair]
  avg(distinct: Boolean): Float
  count(distinct: Boolean): Int
  max: Int
  min: Int
  sum(distinct: Boolean): Int
}

input AggregatedPolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: AggregatedPolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeTransformQuantityMaths {
  divide_by: MathInputInt
}

input StripeBillingDetailsInput {
  hypi: HypiInput
  address: StripeAddressInput
  email: String
  name: String
  phone: String
}

input StripeReferenceInput {
  hypi: HypiInput
  entity: String
  key: String
  value: String
}

input WorkflowTimedInput {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInput
  repeatN: Int
  steps: [WorkflowStepInput!]
  cronSchedule: String
  repeatIf: GraphQLRefInput
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInput
  evaluateIf: GraphQLRefInput
  order: Int
}

input TimePolicyInputOpt {
  hypi: HypiInputOpt
  from: DateTime
  to: DateTime
  clients: [AuthClientInputOpt]
  roles: [RoleInputOpt]
  groups: [GroupInputOpt]
  accounts: [AccountInputOpt]
  realms: [RealmLinkInputOpt]
  name: String
  logic: AuthLogic
}

"""All fields defined by AccountPolicy"""
enum AccountPolicyFields {
  hypi
  name

  """Positive` or `Negative"""
  logic
  accounts
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeThesholdReasonGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeThesholdReasonScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input RealmInputOpt {
  hypi: HypiInputOpt
  name: String
  logo: ImageInputOpt
  displayName: String
  allowRegistrations: Boolean
  verifyEmail: Boolean
  bruteForceDetection: BruteForceDetectionOptionsInputOpt
  organisations: [OrganisationInputOpt]
  referrer: String
  remoteLoginId: String
}

input StripeErrorInput {
  hypi: HypiInput
  charge: StripeChargeInput
  code: String
  decline_code: String
  doc_url: String
  message: String
  param: String
  payment_method: StripePaymentMethodInput
  type: String
}

"""Scalar fields defined by Gauge"""
enum GaugeScalarFields {
  """
  A name which uniquely identifies this counter in an instance. Must be a letter followed by 0 or more letters, numbers or underscores
  """
  name

  """A human friendly display label for the counter"""
  label

  """
  The current value of this gauge, set, increase or decrease as you see fit
  """
  value
  tags
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by LoginAttempt"""
enum LoginAttemptFields {
  hypi
  successful
  errorCode
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

interface MLModel {
  hypi: Hypi
  name: String!
  label: String
  description: String
  arcql: String
}

type StripePriceRecurrenceAggs {
  aggregate_usage: AggOtherScalar
  interval: AggOtherScalar
  interval_count: AggInt
  usage_type: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeDiscountAmountGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeDiscountAmountScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeSofort implements StripePaymentOption {
  hypi: Hypi
  country: StripeSofortCountry!
  id: String
  object: String
}

type WorkflowStepData {
  hypi: Hypi
  stepName: String!
  stepResult: Any!
}

"""Scalar fields defined by PermissionDescription"""
enum PermissionDescriptionScalarFields {
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeInvoiceLineItem"""
enum StripeInvoiceLineItemFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeSubscriptionScheduleSettings"""
enum StripeSubscriptionScheduleSettingsScalarFields {
  billing_cycle_anchor
  collection_method
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input LogMessageInput {
  hypi: HypiInput
  level: LogLevel!
  message: String
  stackTrace: String
  releaseId: String
  type: String
  workflow: String
}

input StripeStatusTransitionsMaths {
  finalized_at: MathInputInt
  marked_uncollectible_at: MathInputInt
  paid_at: MathInputInt
  voided_at: MathInputInt
}

type StripeIntervalObjectAggs {
  interval: AggOtherScalar
  interval_count: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeSubscriptionPhaseMaths {
  end_date: MathInputInt
  start_date: MathInputInt
  trial_end: MathInputInt
}

"""All fields defined by WebhookResponse"""
enum WebhookResponseFields {
  hypi
  status
  headers
  body
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by RecommendationTrainer"""
enum RecommendationTrainerScalarFields {
  maxIterations
  minMdlImprovement
  batchSize
  learningRate
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input VideoInputOpt {
  hypi: HypiInputOpt
  name: String
  thumbnails: [ImageInputOpt]
  file: FileInputOpt
  description: String
  location: GeoInputOpt
}

"""
Basically a product but a specific variant e.g. if one product varies in price by size, an invoice item is a specific size's amount
"""
type InvoiceItem {
  hypi: Hypi
  name: String
  description: String

  """
   If provided this specifies the type that the GraphQL item is for.
   When used in a price plan's inclusion, this can limit operations on a per type basis
   For example, if the value is Account and allowed amount is 10, then attempting to create an 11th Account will fail
  """
  type: String
  quantity: Float!
  unit: InvoiceItemUnit!

  """
  If provided then apply VAT to this invoice item even if there is a global invoice item
  """
  vat: Float

  """
  Valid for credit and discount units. If provided the quantity of credit or discount is taken as a percentage rather than an absolute value.
  """
  is_percentage: Boolean
}

input PersonNameGroupByOptions {
  """The field by which to to group the matching data"""
  field: PersonNameScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input PersonNameInputOpt {
  hypi: HypiInputOpt
  title: String
  firstName: String
  lastName: String
  from: DateTime
  to: DateTime
}

input StripePlanInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  active: Boolean
  billing_scheme: StripeBillingScheme
  created: Int
  currency: String
  interval: StripeInterval
  interval_count: Int
  livemode: Boolean
  metadata: Json
  product: String
  tiers_mode: StripeTierMode
  usage_type: StripeUsageType
}

input HypiInput {
  id: ID
  impl: String
  created: DateTime
  updated: DateTime
  trashed: DateTime
  createdBy: ID
  instanceId: String
  tags: [ABACTagInput!]
}

input StripePriceGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePriceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePaymentMethodGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePaymentMethodScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type RolePolicyAggs {
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeTaxIdInput {
  hypi: HypiInput
  id: String
  object: String
}

interface WorkflowAsync {
  hypi: Hypi
  async: Boolean
}

input StripeCheckoutSessionInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeSubscriptionUpdateInputOpt {
  hypi: HypiInputOpt
  billing_cycle_anchor: Int
  expires_at: Int
  trial_end: Int
  trial_from_plan: Boolean
  subscription_items: [StripeSubscriptionItemInputOpt]
}

"""All fields defined by Permission"""
enum PermissionFields {
  hypi
  name

  """defines how the policy arrives at a decision, defaults to Unanimous"""
  decisionStrategy

  """The type that this permission applies to"""
  type

  """
   If present then the scopes in this permission will have the given policies applied to this resource.
   This can be used for example to prevent mutation on a resource by a user, group etc
   
  """
  resource

  """Query, Mutation or Subscription"""
  operationType

  """
  If true, this permission grants/denies access to all accounts (including anonymous account)
  """
  includeAllAccounts
  policies
  scopes
  operations
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input WorkflowSessionInputOpt {
  hypi: HypiInputOpt
  data: [WorkflowStepDataInputOpt]
}

input ProductMaths {
  price: MathInputFloat
}

input EmailTemplateGroupByOptions {
  """The field by which to to group the matching data"""
  field: EmailTemplateScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeChargeMaths {
  amount: MathInputFloat
  amount_refunded: MathInputInt
  application_fee_amount: MathInputInt
}

"""https://stripe.com/docs/api/invoices/line_item"""
type StripeInvoiceLineItem {
  hypi: Hypi
  id: String
  object: String
}

type AccountPolicy implements Policy {
  hypi: Hypi
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  accounts(arcql: String, first: Int, after: String, last: Int, before: String): [Account!]
}

input RequestTemplateGroupByOptions {
  """The field by which to to group the matching data"""
  field: RequestTemplateScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeInvoiceSettingsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeInvoiceSettingsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""
A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges.
https://stripe.com/docs/api/coupons
"""
type StripeCoupon {
  hypi: Hypi
  id: String
  object: String
}

input RealmPolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: RealmPolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeInvoiceGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeInvoiceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePayoutInput {
  hypi: HypiInput
  id: String
  object: String
}

input InvoiceItemInputOpt {
  hypi: HypiInputOpt
  name: String
  description: String
  type: String
  quantity: Float
  unit: InvoiceItemUnit
  vat: Float
  is_percentage: Boolean
}

input StripeTierInputOpt {
  hypi: HypiInputOpt
  flat_amount: Int
  flat_amount_decimal: Float
  unit_amount: Int
  unit_amount_decimal: Float
  up_to: String
}

enum TrainingStatus {
  STARTED
  FINISHED
  ERROR
}

input PhoneInput {
  hypi: HypiInput
  number: String!
  country: CountryInput
  code: String
}

"""All fields defined by EmailMessage"""
enum EmailMessageFields {
  hypi
  from
  subject

  """
  Name of the template to use, if present then the given template is used and text/html etc fields in this message are not used
  """
  template
  text
  html

  """
   Schedule sending in the future
   
  """
  deliveryTime

  """
   If set to True or yes this requires the message only be sent over a TLS connection. If a TLS connection can not be established, we will not deliver the message.
   If set to False or no, we will still try and upgrade the connection, if that fails the message will be delivered over a plaintext SMTP connection.
   
  """
  requireTls

  """
   If set to True or yes, the certificate and hostname will not be verified when trying to establish a TLS connection and Hypi will accept any certificate during delivery.
  
   If set to False or no, Hypi will verify the certificate and hostname. If either one can not be verified, a TLS connection will not be established.
  
   The default is False.
   
  """
  skipVerification

  """
   allows to append a custom MIME header to the message (X-My-Header in this case). For example, h:Reply-To to specify Reply-To address.
   
  """
  headers

  """
   prefix followed by an arbitrary name allows to attach a custom JSON data to the message. See Attaching Data to Messages for more information.
   
  """
  variables

  """
   A valid JSON-encoded dictionary, where key is a plain recipient address and value is a dictionary with variables that can be referenced in the message body.
   
  """
  recipientVariables
  to
  cc
  bcc
  attachment
  inline
  tags
  responses
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
  from_hypi
  from_value
  from_type
  to_hypi
  to_value
  to_type
  cc_hypi
  cc_value
  cc_type
  bcc_hypi
  bcc_value
  bcc_type
}

type StripeTransformQuantityAggs {
  divide_by: AggInt
  round: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type OAuth2AuthorizedClientAggs {
  clientRegistrationId: AggOtherScalar
  principalName: AggOtherScalar
  accessToken: AggOtherScalar
  refreshToken: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type Query {
  """
  Find objects of the given type which match the query. Use a conditional fragment to select fields as in https://graphql.org/learn/schema/#union-types
  """
  find(
    type: HypiMutationType!
    arcql: String!
    first: Int
    after: String
    last: Int
    before: String
    includeTrashed: Boolean

    """
    The page number to offset results by. This should be used in combination with after (does not work with before). It can be used by itself but carries some performance impact as a result we limit this to a max of 25
    """
    page: Int
  ): HypiFilterConnection!

  """Gets a single object by its ID (hypi.id)"""
  get(type: HypiMutationType!, id: String!): HypiRootAggregate
  aggregate: HypiAggregationType
  loginByEmail(email: String!, password: String!): AccessToken
  hasPermission(req: [PermissionRequest!]!): [Boolean]
  me: PermissionDescription
  predictRecommendation(value: PredictionDataInput!): [ObjectSubjectRatingTriplet]
  login(username: String!, password: String!): AccessToken
}

type Product {
  hypi: Hypi
  title: String!
  description: String!
  price: Float
}

"""
A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session.

A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge.
https://stripe.com/docs/api/payment_intents
"""
type StripePaymentIntent {
  hypi: Hypi
  id: String
  object: String
  amount: Int
  amount_capturable: Int
  amount_received: Int
  client_secret: String
  currency: String
  customer: StripeCustomer
  description: String
  last_payment_error: StripeError
  metadata: Json
  next_action: StripeNextAction
  payment_method: StripePaymentMethod
  receipt_email: String
  setup_future_usage: StripeUsage
  shipping: StripeShippingInfo
  statement_descriptor: String
  statement_descriptor_suffix: String
  status: String
  canceled_at: Int
  cncellation_reason: String
  capture_method: StripeCaptureMethod
  confirmation_method: StripeConfirmationMethod
  created: Int
  invoice: StripeInvoice
  livemode: Boolean
  payment_method_options: StripePaymentOption
  review: String
  charges(arcql: String, first: Int, after: String, last: Int, before: String): [StripeCharge!]
  payment_method_types(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
}

""" Logging"""
enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}

"""Scalar fields defined by StripeTaxRate"""
enum StripeTaxRateScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by File"""
enum FileFields {
  hypi
  name
  directory
  path
  isDirectory
  status
  url

  """mime type"""
  type
  size
  extension
  isStared
  isSharable
  content
  children
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeAuBecsDebitInput {
  hypi: HypiInput
  bsb_number: String
  fingerprint: String
  last4: String
}

"""Defines the templates that should be applied to a given HTTP request"""
type RequestTemplate {
  hypi: Hypi
  name: String!
  request: String
  response: String
}

"""Scalar fields defined by StripeTransfer"""
enum StripeTransferScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input AccountInput {
  hypi: HypiInput
  emails: [EmailInput!]
  verified: Boolean
  enabled: Boolean
  phones: [PhoneInput!]
  username: String!
  password: PasswordInput!
  owner: PersonInput
  groups: [GroupInput!]
  roles: [RoleInput!]
  attempts: [LoginAttemptInput!]
  remoteLogins: [RemoteLoginInput!]
}

"""Scalar fields defined by StripeCustomerBalanceTransaction"""
enum StripeCustomerBalanceTransactionScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeTransferDataInput {
  hypi: HypiInput
  amount: Int
  destination: StripeCustomerInput
}

input StripeDiscountAmountInputOpt {
  hypi: HypiInputOpt
  amount: Int
  discount: StripeDiscountInputOpt
}

"""All fields defined by Group"""
enum GroupFields {
  hypi

  """
  A unique name identifying this group, implicitly sets the path of the group to /<name> whihc can be referenced in wild card permissions
  """
  name
  accounts
  children
  organisations
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

enum StripeNetworkStatus {
  APPROVED_BY_NETWORK
  DECLINED_BY_NETWORK
  NOT_SENT_TO_NETWORK
  REVERSED_AFTER_APPROVAL
}

"""All fields defined by Country"""
enum CountryFields {
  hypi
  name
  stateName
  sovereignty
  alpha2code
  alpha3code
  numericCode
  subdivisionCodeLinks
  internetCCTLD
  continent
  officialLanguage
  currencies
  languagesSpoken
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by RealmLink"""
enum RealmLinkFields {
  hypi
  name
  accounts
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePackageDimensionsInput {
  hypi: HypiInput
  height: Float
  length: Float
  weight: Float
  width: Float
}

type EmailSendingAttemptAggs {
  headers: AggOtherScalar
  body: AggOtherScalar
  status: AggOtherScalar
  statusMessage: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeTransformQuantity"""
enum StripeTransformQuantityScalarFields {
  """Divide usage by this number."""
  divide_by

  """After division, either round the result up or down."""
  round
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeSubscriptionItemInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  metadata: Json
  price: StripePriceInputOpt
  plan: StripePlanInputOpt
  quantity: Int
  subscription: StripeSubscriptionInputOpt
  billing_thresholds: StripeBillingThresholdInputOpt
  created: Int
  tax_rates: [StripeTaxRateInputOpt]
}

"""An object available as "env" in all scripts"""
type HypiEnv {
  hypi: Hypi
  apiHost: String
  websocketHost: String
}

type StripeFraudDetails {
  hypi: Hypi

  """Assessments from Stripe. If set, the value is fraudulent."""
  stripe_report: String

  """
  Assessments reported by you. If set, possible values of are safe and fraudulent.
  """
  user_report: String
}

input StripeCardPresentInput {
  hypi: HypiInput
  brand: String
  cardholder_name: String
  country: String
  emv_auth_data: String
  exp_month: Int
  exp_year: Int
  fingerprint: String
  funding: StripeFunding
  generated_card: String
  last4: String
  network: StripeNetwork
  read_method: StripeReadMethod
  receipt: StripeReceiptInput
}

"""All fields defined by PricePlan"""
enum PricePlanFields {
  hypi
  allowance
  bill_to
  billing_frequency

  """
  Remote card ID e.g. Stripe, BrainTree or other third party card ID that this plan bills
  In invoices create credit on the price plan then payment is made to this card
  """
  default_card
  valid_from
  valid_to
  invoices
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by Video"""
enum VideoFields {
  hypi
  name
  file
  description
  location
  thumbnails
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeIntervalObject {
  hypi: Hypi
  interval: StripeInterval
  interval_count: Int
}

"""Scalar fields defined by StripeIdeal"""
enum StripeIdealScalarFields {
  bank
  bic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeCheckoutSession"""
enum StripeCheckoutSessionScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by KMeanCLusteringModel"""
enum KMeanCLusteringModelScalarFields {
  typeName
  arcql
  name
  description
  label
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input BruteForceDetectionOptionsInput {
  hypi: HypiInput
  maxLoginFailures: Int!
  waitIncrements: Int
  waitIncrementsUnit: TimeUnit
  quickLoginCheckMillis: Int
  minQuickLoginWait: Int
  minQuickLoginWaitUnit: TimeUnit
  maxWait: Int
  maxWaitUnit: TimeUnit
  failureReset: Int
  failureResetUnit: TimeUnit
}

"""All numeric fields defined by PricePlanInclusion"""
enum PricePlanInclusionNumericFields {
  allowed_overage_amount
}

type StripeTaxAmount {
  hypi: Hypi
  amount: Int
  inclusive: Boolean
  tax_rate: StripeTaxRate
}

"""All fields defined by LearningEnvironment"""
enum LearningEnvironmentFields {
  hypi

  """Specifies a seed for random number generator."""
  rngSeed

  """
  Specifies the behaviour of processes in ML-algorithms that can may be parallelized such as parallel learning in
  bagging, learning submodels for One-vs-All model, Cross-Validation etc.
  """
  parallelism

  """
  Specify partition data time-to-live in seconds (-1 for an infinite lifetime).
  """
  dataTtl
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeIdealGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeIdealScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeSetupIntentInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
  client_secret: String
  customer: StripeCustomerInputOpt
  description: String
  last_setup_error: StripeErrorInputOpt
  metadata: Json
  next_action: StripeNextActionInputOpt
  payment_method: StripePaymentMethodInputOpt
  payment_method_types: [String]
  status: String
  cncellation_reason: String
  created: Int
  livemode: Boolean
  payment_method_options: StripePaymentOptionInputOpt
  usage: StripeUsage
  mandate: StripeMandateInputOpt
  single_use_mandate: StripeMandateInputOpt
}

input GraphQLRefInput {
  hypi: HypiInput
  type: OpType!
  field: String!
  selection: String
}

input StripeAliPayHandleRedirectGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeAliPayHandleRedirectScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input CurrencyInputOpt {
  hypi: HypiInputOpt
  name: String
  code: String
  symbol: String
}

enum StripeMandateStatus {
  active
  inactive
  pending
}

type VideoAggs {
  name: AggOtherScalar
  description: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeThesholdReasonAggs {
  amount_gte: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeTransferData"""
enum StripeTransferDataScalarFields {
  amount
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeIntervalObjectInputOpt {
  hypi: HypiInputOpt
  interval: StripeInterval
  interval_count: Int
}

input StripeDiscountInput {
  hypi: HypiInput
  id: String
  object: String
}

input ABACPolicyInput {
  hypi: HypiInput
  from: DateTime
  to: DateTime
  givenInstance: String
  givenType: String!
  givenOperation: String!
  givenFn: String
  givenFnPrefix: String
  whenResourceTagKeyEq: String
  whenResourceTagKeyPrefix: String
  whenResourceTagValueEq: String
  whenResourceTagValuePrefix: String
  assertAccountIdEq: String
  assertAccountUsernamePrefix: String
  assertAccountTagKeyEq: String
  assertAccountTagKeyPrefix: String
  assertAccountTagValEq: String
  assertAccountTagValPrefix: String
  boundary: PolicyBoundary
  allowedFields: String
}

"""All numeric fields defined by StripeInvoiceSettings"""
enum StripeInvoiceSettingsNumericFields {
  days_until_due
}

type StripeIdealAggs {
  bank: AggOtherScalar
  bic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeTierInput {
  hypi: HypiInput
  flat_amount: Int
  flat_amount_decimal: Float
  unit_amount: Int
  unit_amount_decimal: Float
  up_to: String
}

input StripePayoutInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

"""
Indicates the type should be repeated once it's finished IFF the referenced function is defined AND executing it returns true;
repeatIf and repeatN are mutually exclusive. If repeatN is specified it takes precedence over repeatIf
"""
interface WorkflowRepeatable {
  hypi: Hypi
  repeatIf: GraphQLRef
  repeatN: Int
}

"""All fields defined by StripeSubscriptionScheduleSettings"""
enum StripeSubscriptionScheduleSettingsFields {
  hypi
  billing_cycle_anchor
  billing_thresholds
  collection_method
  default_payment_method
  invoice_settings
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type ServerlessResponse {
  hypi: Hypi
  path: String
  headers: Json
  multiPart: Boolean
  method: String
  chunked: Boolean
  queryString: Json
  body: Json
  cookies: Json
  files(arcql: String, first: Int, after: String, last: Int, before: String): [File]
  attributes(arcql: String, first: Int, after: String, last: Int, before: String): [String]
}

input StorageCounterInputOpt {
  hypi: HypiInputOpt
  type: String
  field: String
  size: Int
}

"""@deprecated - to be removed"""
type RealmLink {
  hypi: Hypi
  name: String! @deprecated(reason: "RealmLink will be removed in a future version")
  accounts(arcql: String, first: Int, after: String, last: Int, before: String): [Account!]! @deprecated(reason: "RealmLink will be removed in a future version")
}

input StripeBankAccountGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeBankAccountScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by Workflow"""
enum WorkflowFields {
  hypi
  name

  """
  If present, this is a cron schedule to automatically execute this Workflow
  The syntax as defined at https://www.manpagez.com/man/5/crontab/
  NOTE: The special strings @hourly, @daily etc are NOT supported
  """
  cronSchedule

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs
  async

  """
  If present AND true, all steps in this block are executed at the same time.
  """
  parallel

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime
  repeatN
  evaluateIf
  repeatIf
  steps
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
  evaluateIf_hypi
  evaluateIf_type
  evaluateIf_field
  evaluateIf_selection
  repeatIf_hypi
  repeatIf_type
  repeatIf_field
  repeatIf_selection
}

type StripeCouponAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input ABACPolicyInputOpt {
  hypi: HypiInputOpt
  from: DateTime
  to: DateTime
  givenInstance: String
  givenType: String
  givenOperation: String
  givenFn: String
  givenFnPrefix: String
  whenResourceTagKeyEq: String
  whenResourceTagKeyPrefix: String
  whenResourceTagValueEq: String
  whenResourceTagValuePrefix: String
  assertAccountIdEq: String
  assertAccountUsernamePrefix: String
  assertAccountTagKeyEq: String
  assertAccountTagKeyPrefix: String
  assertAccountTagValEq: String
  assertAccountTagValPrefix: String
  boundary: PolicyBoundary
  allowedFields: String
}

"""
Events are our way of letting you know when something interesting happens in your account. When an interesting event occurs, we create a new Event object. For example, when a charge succeeds, we create a charge.succeeded event; and when an invoice payment attempt fails, we create an invoice.payment_failed event. Note that many API requests may cause multiple events to be created. For example, if you create a new subscription for a customer, you will receive both a customer.subscription.created event and a charge.succeeded event.

Events occur when the state of another API resource changes. The state of that resource at the time of the change is embedded in the event's data field. For example, a charge.succeeded event will contain a charge, and an invoice.payment_failed event will contain an invoice.
https://stripe.com/docs/api/events
"""
type StripeEvent {
  hypi: Hypi
  id: String
  object: String
}

"""Scalar fields defined by StripeSofort"""
enum StripeSofortScalarFields {
  country
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeTransformQuantityInput {
  hypi: HypiInput
  divide_by: Int
  round: StripeTransformRounding
}

enum StripeSubscriptionStatus {
  active
  past_due
  unpaid
  canceled
  incomplete
  incomplete_expired
  trialing
}

type ImageAggs {
  name: AggOtherScalar
  description: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePaymentMethodMaths {
  created: MathInputInt
}

"""Scalar fields defined by StripeDiscountAmount"""
enum StripeDiscountAmountScalarFields {
  amount
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""@deprecated - to be removed"""
type RealmPolicy implements Policy {
  hypi: Hypi
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  realms(arcql: String, first: Int, after: String, last: Int, before: String): [RealmLink!] @deprecated(reason: "RealmPolicy will be removed in a future version")
}

type StripeInvoiceSettingsAggs {
  days_until_due: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input PermissionRequest {
  opType: OpType!
  operationName: String!
  type: String!
  scopes: [String!]!
  resource: String!
  from: DateTime
  to: DateTime
}

interface WorkflowOrdered {
  hypi: Hypi
  order: Int!
}

"""Scalar fields defined by StripeCharge"""
enum StripeChargeScalarFields {
  """Unique identifier for the object."""
  id

  """
  Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or equivalent in charge currency. The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
  """
  amount

  """
  Three-letter ISO currency code, in lowercase. Must be a supported currency.
  """
  currency

  """
  An arbitrary string attached to the object. Often useful for displaying to users.
  """
  description

  """Whether the charge has been disputed."""
  disputed

  """
  Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
  """
  metadata

  """
  This is the email address that the receipt for this charge was sent to.
  """
  receipt_email

  """
  Whether the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.
  """
  refund

  """
  For card charges, use statement_descriptor_suffix instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
  """
  statement_descriptor

  """
  Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
  """
  statement_descriptor_suffix

  """The status of the payment is either succeeded, pending, or failed."""
  status
  object

  """
  Amount in cents refunded (can be less than the amount attribute on the charge if a partial refund was issued).
  """
  amount_refunded

  """ID of the Connect application that created the charge."""
  application

  """
  The application fee (if any) for the charge. See the Connect documentation for details.
  """
  application_fee

  """The amount of the application fee (if any) requested for the charge."""
  application_fee_amount

  """
  The full statement descriptor that is passed to card networks, and that is displayed on your customers’ credit card and bank statements. Allows you to see what the statement descriptor looks like after the static and dynamic portions are combined.
  """
  calculated_statement_descriptor

  """
  If the charge was created without capturing, this Boolean represents whether it is still uncaptured or has since been captured.
  """
  captured

  """
  Time at which the object was created. Measured in seconds since the Unix epoch.
  """
  created

  """
  Error code explaining reason for charge failure if available (see the errors section for a list of codes).
  """
  failure_code

  """
  Message to user further explaining reason for charge failure if available.
  """
  failure_message

  """
  Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  """
  live_mode

  """
  The account (if any) the charge was made on behalf of without triggering an automatic transfer. See the Connect documentation for details.
  """
  on_behalf_of
  paid
  payment_method
  receipt_number
  receipt_url

  """
  The transfer ID which created this charge. Only present if the charge came from another Stripe account.
  """
  source_transfer

  """
  A string that identifies this transaction as part of a group. See the Connect documentation for details.
  """
  transfer_group
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input CoordinateInput {
  hypi: HypiInput
  x: Float!
  y: Float!
}

input StripeSofortGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSofortScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeTransferInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input WorkflowOrderedInputOpt {
  execAs: String
  async: Boolean
  name: String
  fn: GraphQLRefInputOpt
  maxExecutionTime: String
  repeatN: Int
  hypi: HypiInputOpt
  evaluateIf: GraphQLRefInputOpt
  order: Int
  repeatIf: GraphQLRefInputOpt
}

"""All fields defined by StripePaymentMethodDetails"""
enum StripePaymentMethodDetailsFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type OAuthProvider {
  hypi: Hypi

  """ instanceId-(hypi.id = registrationId)"""
  clientId: String!
  clientSecret: String!
  clientAuthenticationMethod: ClientAuthenticationMethod
  authorizationGrantType: AuthorizationGrantType
  redirectUriTemplate: String
  authorizationUri: String
  tokenUri: String
  userInfoUri: String
  userInfoAuthenticationMethod: AuthenticationMethod
  userNameAttributeName: UserNameAttributeName
  jwkSetUri: String
  clientName: String
  hypiSuccessRedirectUri: String
  hypiFailureRedirectUri: String
  scopes(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
  configurationMetadata(arcql: String, first: Int, after: String, last: Int, before: String): [Pair!]
}

input StripeInvoiceLineItemInput {
  hypi: HypiInput
  id: String
  object: String
}

"""Scalar fields defined by AggregatedPolicy"""
enum AggregatedPolicyScalarFields {
  """defines how the policy arrives at a decision, the options are:"""
  decisionStrategy
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type HypiResultEdge {
  hypi: Hypi
  node: HypiRootAggregate!
  cursor: ID!
}

"""All fields defined by StripeBillingThreshold"""
enum StripeBillingThresholdFields {
  hypi
  usage_gte
  amount_gte
  reset_billing_cycle_anchor
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePaymentMethodDetailsInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeChargeInput {
  hypi: HypiInput
  id: String
  amount: Float
  balance_transaction: StripeCustomerBalanceTransactionInput
  billing_details: StripeBillingDetailsInput
  currency: String
  description: String
  disputed: Boolean
  invoice: StripeInvoiceInput
  metadata: Json
  payment_intent: StripePaymentIntentInput
  payment_method_details: StripePaymentMethodInput
  receipt_email: String
  refund: Boolean
  shipping: StripeShippingInfoInput
  statement_descriptor: String
  statement_descriptor_suffix: String
  status: StripeChargeStatus
  object: String
  amount_refunded: Int
  application: String
  application_fee: String
  application_fee_amount: Int
  calculated_statement_descriptor: String
  captured: Boolean
  created: DateTime
  failure_code: String
  failure_message: String
  live_mode: Boolean
  on_behalf_of: String
  fraud_details: StripeFraudDetailsInput
  order: StripeOrderInput
  outcome: StripeChargeOutcomeInput
  paid: Boolean
  payment_method: String
  receipt_number: String
  receipt_url: String
  refunds: [StripeRefundInput!]
  review: StripeReviewInput
  source_transfer: String
  transfer: StripeTransferInput
  transfer_data: StripeTransferDataInput
  transfer_group: String
}

input StripeMandateInputOpt {
  hypi: HypiInputOpt
  id: String
  customer_acceptance: StripeCustomerAcceptanceInputOpt
  payment_method: StripePaymentMethodInputOpt
  payment_method_details: StripePaymentMethodDetailsInputOpt
  status: StripeMandateStatus
  type: StripeMandateType
  object: String
  livemode: Boolean
  multi_use: String
  single_use: String
}

"""All fields defined by StripeThesholdReason"""
enum StripeThesholdReasonFields {
  hypi
  amount_gte
  item_reasons
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeTaxAmount"""
enum StripeTaxAmountScalarFields {
  amount
  inclusive
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

enum StripeMandateType {
  multi_use
  single_use
}

"""All fields defined by StripeOxxoDisplayDetails"""
enum StripeOxxoDisplayDetailsFields {
  hypi
  expires_after
  hosted_voucher_url
  number
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input BruteForceDetectionOptionsGroupByOptions {
  """The field by which to to group the matching data"""
  field: BruteForceDetectionOptionsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input AccountInputOpt {
  hypi: HypiInputOpt
  emails: [EmailInputOpt]
  verified: Boolean
  enabled: Boolean
  phones: [PhoneInputOpt]
  username: String
  password: PasswordInputOpt
  owner: PersonInputOpt
  groups: [GroupInputOpt]
  roles: [RoleInputOpt]
  attempts: [LoginAttemptInputOpt]
  remoteLogins: [RemoteLoginInputOpt]
}

input AccountPolicyInputOpt {
  hypi: HypiInputOpt
  accounts: [AccountInputOpt]
  name: String
  logic: AuthLogic
}

type StripeInvoiceItemAggs {
  id: AggOtherScalar
  amount: AggInt
  currency: AggOtherScalar
  description: AggOtherScalar
  metadata: AggOtherScalar
  proration: AggOtherScalar
  object: AggOtherScalar
  date: AggInt
  discountable: AggOtherScalar
  livemode: AggOtherScalar
  quantity: AggInt
  unit_amount: AggInt
  unit_amount_decimal: AggFloat
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by WorkflowSession"""
enum WorkflowSessionFields {
  hypi
  data
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeTransferInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeCardPresentInputOpt {
  hypi: HypiInputOpt
  brand: String
  cardholder_name: String
  country: String
  emv_auth_data: String
  exp_month: Int
  exp_year: Int
  fingerprint: String
  funding: StripeFunding
  generated_card: String
  last4: String
  network: StripeNetwork
  read_method: StripeReadMethod
  receipt: StripeReceiptInputOpt
}

input GraphQLRefInputOpt {
  hypi: HypiInputOpt
  type: OpType
  field: String
  selection: String
}

input PredictionDataGroupByOptions {
  """The field by which to to group the matching data"""
  field: PredictionDataScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeBacsDebitGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeBacsDebitScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input BruteForceDetectionOptionsInputOpt {
  hypi: HypiInputOpt
  maxLoginFailures: Int
  waitIncrements: Int
  waitIncrementsUnit: TimeUnit
  quickLoginCheckMillis: Int
  minQuickLoginWait: Int
  minQuickLoginWaitUnit: TimeUnit
  maxWait: Int
  maxWaitUnit: TimeUnit
  failureReset: Int
  failureResetUnit: TimeUnit
}

type StripeSubscriptionPhase {
  hypi: Hypi
  end_date: Int
  start_date: Int
  add_invoice_items: StripeInvoiceItem
  billing_cycle_anchor: StripeBillingCycleAnchor
  billing_thresholds: StripeBillingThreshold
  collection_method: StripeCollectionMethod
  coupon: StripeCoupon
  default_payment_method: StripePaymentMethod
  invoice_settings: StripeInvoiceSettings
  items: StripeSubscriptionItem
  proration_behavior: StripeProrationBehavior
  trial_end: Int
  default_tax_rates(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxRate!]
}

type ServerlessResponseAggs {
  path: AggOtherScalar
  headers: AggOtherScalar
  multiPart: AggOtherScalar
  method: AggOtherScalar
  chunked: AggOtherScalar
  queryString: AggOtherScalar
  body: AggOtherScalar
  cookies: AggOtherScalar
  attributes: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePackageDimensionsInputOpt {
  hypi: HypiInputOpt
  height: Float
  length: Float
  weight: Float
  width: Float
}

type Role {
  hypi: Hypi
  name: String!
  accounts(arcql: String, first: Int, after: String, last: Int, before: String): [Account!]
}

type RolePolicy implements Policy {
  hypi: Hypi
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  roles(arcql: String, first: Int, after: String, last: Int, before: String): [Role!]!
}

"""All numeric fields defined by Workflow"""
enum WorkflowNumericFields {
  repeatN
}

"""All fields defined by Password"""
enum PasswordFields {
  hypi

  """
   password is never returned
   further, the @secret directive enforces this, queries can be use to perform comparison against the field but it is never returned
   
  """
  value
  expired
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePriceRecurrenceInputOpt {
  hypi: HypiInputOpt
  aggregate_usage: StripeAggregateUsage
  interval: StripeBillingFrequency
  interval_count: Int
  usage_type: StripeUsageType
}

input StripeChargeOutcomeMaths {
  risk_score: MathInputInt
}

input StripeChargeInputOpt {
  hypi: HypiInputOpt
  id: String
  amount: Float
  balance_transaction: StripeCustomerBalanceTransactionInputOpt
  billing_details: StripeBillingDetailsInputOpt
  currency: String
  description: String
  disputed: Boolean
  invoice: StripeInvoiceInputOpt
  metadata: Json
  payment_intent: StripePaymentIntentInputOpt
  payment_method_details: StripePaymentMethodInputOpt
  receipt_email: String
  refund: Boolean
  shipping: StripeShippingInfoInputOpt
  statement_descriptor: String
  statement_descriptor_suffix: String
  status: StripeChargeStatus
  object: String
  amount_refunded: Int
  application: String
  application_fee: String
  application_fee_amount: Int
  calculated_statement_descriptor: String
  captured: Boolean
  created: DateTime
  failure_code: String
  failure_message: String
  live_mode: Boolean
  on_behalf_of: String
  fraud_details: StripeFraudDetailsInputOpt
  order: StripeOrderInputOpt
  outcome: StripeChargeOutcomeInputOpt
  paid: Boolean
  payment_method: String
  receipt_number: String
  receipt_url: String
  refunds: [StripeRefundInputOpt]
  review: StripeReviewInputOpt
  source_transfer: String
  transfer: StripeTransferInputOpt
  transfer_data: StripeTransferDataInputOpt
  transfer_group: String
}

input StripeRedirectToUrlGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeRedirectToUrlScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePriceInput {
  hypi: HypiInput
  id: String
  active: Boolean
  currency: String
  metadata: Json
  nickname: String
  product: StripeProductInput
  recurring: StripePriceRecurrenceInput
  type: StripePriceType
  unit_amount: Int
  object: String
  billing_scheme: StripeBillingScheme
  created: Int
  live_mode: Boolean
  lookup_key: String
  tiers: [StripeTierInput]
  tiers_mode: StripeTierMode
  transform_quantity: StripeTransformQuantityInput
  unit_amount_decimal: String
}

"""All numeric fields defined by Coordinate"""
enum CoordinateNumericFields {
  x
  y
}

input WebhookPayload {
  url: URLInput!
  headers: Json!
  body: String
}

"""Scalar fields defined by StripePromotionCode"""
enum StripePromotionCodeScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by InvoiceItem"""
enum InvoiceItemFields {
  hypi
  name
  description

  """
   If provided this specifies the type that the GraphQL item is for.
   When used in a price plan's inclusion, this can limit operations on a per type basis
   For example, if the value is Account and allowed amount is 10, then attempting to create an 11th Account will fail
  """
  type
  quantity
  unit

  """
  If provided then apply VAT to this invoice item even if there is a global invoice item
  """
  vat

  """
  Valid for credit and discount units. If provided the quantity of credit or discount is taken as a percentage rather than an absolute value.
  """
  is_percentage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All numeric fields defined by Gauge"""
enum GaugeNumericFields {
  value
}

"""Measures a value at a point in time"""
type Gauge {
  hypi: Hypi

  """
  A name which uniquely identifies this counter in an instance. Must be a letter followed by 0 or more letters, numbers or underscores
  """
  name: String!

  """A human friendly display label for the counter"""
  label: String

  """
  The current value of this gauge, set, increase or decrease as you see fit
  """
  value: Float!
  tags(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
}

type AddressAggs {
  door: AggOtherScalar
  street: AggOtherScalar
  town: AggOtherScalar
  county: AggOtherScalar
  city: AggOtherScalar
  postCode: AggOtherScalar
  from: AggOtherScalar
  to: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

enum StripeTransformRounding {
  UP
  DOWN
}

type StripeCheckoutSessionAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeSource"""
enum StripeSourceFields {
  hypi
  id
  object
  client_secret
  reusable
  livemode
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""
==============IaM models==============
union Entity = Account | Organisation #todo unions not yet supported
"""
type Language {
  hypi: Hypi
  family: String
  isoName: String
  nativeName: String
  iso6391Code: String
  iso6392TCode: String
  iso6392BCode: String
  iso6393Code: String
}

input InvoiceInput {
  hypi: HypiInput
  buyer: AccountInput
  seller: AccountInput
  due_date: DateTime
  notes: String
  vat_amount: Float
  items: [InvoiceItemInput!]
}

input ImageInput {
  hypi: HypiInput
  name: String!
  file: FileInput!
  description: String
  location: GeoInput
}

"""Scalar fields defined by StripeReference"""
enum StripeReferenceScalarFields {
  entity
  key
  value
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type PricePlanAggs {
  billing_frequency: AggOtherScalar
  default_card: AggOtherScalar
  valid_from: AggOtherScalar
  valid_to: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by Currency"""
enum CurrencyFields {
  hypi
  name
  code
  symbol
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripePaymentIntentAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  amount: AggInt
  amount_capturable: AggInt
  amount_received: AggInt
  client_secret: AggOtherScalar
  currency: AggOtherScalar
  description: AggOtherScalar
  metadata: AggOtherScalar
  receipt_email: AggOtherScalar
  setup_future_usage: AggOtherScalar
  statement_descriptor: AggOtherScalar
  statement_descriptor_suffix: AggOtherScalar
  status: AggOtherScalar
  canceled_at: AggInt
  cncellation_reason: AggOtherScalar
  capture_method: AggOtherScalar
  confirmation_method: AggOtherScalar
  created: AggInt
  livemode: AggOtherScalar
  review: AggOtherScalar
  payment_method_types: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input RecommendationModelInputOpt {
  hypi: HypiInputOpt
  env: LearningEnvironmentInputOpt
  trainer: RecommendationTrainerInputOpt
  type: String
  ratingFieldName: String
  subjectFieldName: String
  objectFieldName: String
  arcql: String
  name: String
  description: String
  label: String
}

input StripeEventInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

type PersonName {
  hypi: Hypi
  title: String
  firstName: String
  lastName: String
  from: DateTime
  to: DateTime
}

type EmailAggs {
  value: AggOtherScalar
  type: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input OrganisationInputOpt {
  hypi: HypiInputOpt
  name: String
  logo: ImageInputOpt
  addresses: [AddressInputOpt]
  incorporated: DateTime
  phones: [PhoneInputOpt]
  emails: [EmailInputOpt]
  members: [AccountInputOpt]
  subsidiaries: [OrganisationInputOpt]
}

type StripeReceiptAggs {
  account_type: AggOtherScalar
  application_cryptogram: AggOtherScalar
  application_preferred_name: AggOtherScalar
  authorization_code: AggOtherScalar
  authorization_response_code: AggOtherScalar
  cardholder_verification_method: AggOtherScalar
  dedicated_file_name: AggOtherScalar
  terminal_verification_results: AggOtherScalar
  transaction_status_information: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by ClientPolicy"""
enum ClientPolicyFields {
  hypi
  name

  """Positive` or `Negative"""
  logic
  clients
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripeCharge"""
enum StripeChargeFields {
  hypi

  """Unique identifier for the object."""
  id

  """
  Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or equivalent in charge currency. The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
  """
  amount

  """
  ID of the balance transaction that describes the impact of this charge on your account balance (not including refunds or disputes).
  """
  balance_transaction

  """
  Billing information associated with the payment method at the time of the transaction.
  """
  billing_details

  """
  Three-letter ISO currency code, in lowercase. Must be a supported currency.
  """
  currency

  """
  An arbitrary string attached to the object. Often useful for displaying to users.
  """
  description

  """Whether the charge has been disputed."""
  disputed

  """
  ID of the invoice this charge is for if one exists.
  In stripe this is the invoice ID, in Hypi it links directly to the Invoice object
  """
  invoice

  """
  Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
  """
  metadata

  """
  In Stripe this is the ID of the PaymentIntent associated with this charge, if one exists.
  In Hypi this links directly to the object
  """
  payment_intent

  """Details about the payment method at the time of the transaction."""
  payment_method_details

  """
  This is the email address that the receipt for this charge was sent to.
  """
  receipt_email

  """
  Whether the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.
  """
  refund
  shipping

  """
  For card charges, use statement_descriptor_suffix instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
  """
  statement_descriptor

  """
  Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
  """
  statement_descriptor_suffix

  """The status of the payment is either succeeded, pending, or failed."""
  status
  object

  """
  Amount in cents refunded (can be less than the amount attribute on the charge if a partial refund was issued).
  """
  amount_refunded

  """ID of the Connect application that created the charge."""
  application

  """
  The application fee (if any) for the charge. See the Connect documentation for details.
  """
  application_fee

  """The amount of the application fee (if any) requested for the charge."""
  application_fee_amount

  """
  The full statement descriptor that is passed to card networks, and that is displayed on your customers’ credit card and bank statements. Allows you to see what the statement descriptor looks like after the static and dynamic portions are combined.
  """
  calculated_statement_descriptor

  """
  If the charge was created without capturing, this Boolean represents whether it is still uncaptured or has since been captured.
  """
  captured

  """
  Time at which the object was created. Measured in seconds since the Unix epoch.
  """
  created

  """
  Error code explaining reason for charge failure if available (see the errors section for a list of codes).
  """
  failure_code

  """
  Message to user further explaining reason for charge failure if available.
  """
  failure_message

  """
  Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  """
  live_mode

  """
  The account (if any) the charge was made on behalf of without triggering an automatic transfer. See the Connect documentation for details.
  """
  on_behalf_of

  """Information on fraud assessments for the charge."""
  fraud_details

  """ID of the order this charge is for if one exists."""
  order

  """
  Details about whether the payment was accepted, and why. See understanding declines for details.
  """
  outcome
  paid
  payment_method
  receipt_number
  receipt_url
  review

  """
  The transfer ID which created this charge. Only present if the charge came from another Stripe account.
  """
  source_transfer

  """
  ID of the transfer to the destination account (only applicable if the charge was created using the destination parameter).
  """
  transfer

  """
  An optional dictionary including the account to automatically transfer to as part of a destination charge. See the Connect documentation for details.
  """
  transfer_data

  """
  A string that identifies this transaction as part of a group. See the Connect documentation for details.
  """
  transfer_group
  refunds
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input LoginAttemptInput {
  hypi: HypiInput
  successful: Boolean
  errorCode: String
}

input StripeCouponInput {
  hypi: HypiInput
  id: String
  object: String
}

input PermissionGroupByOptions {
  """The field by which to to group the matching data"""
  field: PermissionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input GroupPolicyInput {
  hypi: HypiInput
  groups: [GroupInput!]
  name: String!
  logic: AuthLogic
}

input StripeCustomerInput {
  hypi: HypiInput
  id: String
  object: String
  address: StripeAddressInput
  description: String
  email: String
  metadata: Json
  name: String
  phone: String
  shipping: StripeShippingInfoInput
  balance: Int
  created: Int
  currency: String
  default_source: StripeSourceInput
  delinquent: Boolean
  discount: StripeDiscountInput
  invoice_prefix: String
  invoice_settings: StripeInvoiceSettingsInput
  livemode: Boolean
  next_invoice_sequence: Int
  preferred_locales: [String!]
  source: String
  sources: [StripeSourceInput!]
  subscriptions: [StripeSubscriptionInput!]
  tax_exempt: String
  tax_ids: [StripeTaxIdInput!]
}

input StripeInvoiceInput {
  hypi: HypiInput
  id: String
  auto_advance: Boolean
  charge: StripeChargeInput
  collection_method: StripeCollectionMethod
  currency: String
  customer: StripeCustomerInput
  description: String
  hosted_invoice_url: String
  lines: [StripeInvoiceLineItemInput!]
  metadata: Json
  payment_intent: StripePaymentIntentInput
  period_end: Int
  period_start: Int
  status: StripeInvoiceStatus
  subscription: StripeSubscriptionInput
  total: Int
  object: String
  account_country: String
  account_name: String
  account_tax_ids: [StripeTaxIdInput!]
  amount_due: Int
  amount_paid: Int
  amount_remaining: Int
  attempt_count: Int
  attempted: Boolean
  billing_reason: String
  created: Int
  custom_fields: [PairInput!]
  customer_address: StripeAddressInput
  customer_email: String
  customer_name: String
  customer_phone: String
  customer_shipping: StripeShippingInfoInput
  customer_tax_exempt: String
  customer_tax_ids: [StripeTaxIdInput!]
  default_payment_method: StripePaymentMethodInput
  default_source: StripeSourceInput
  default_tax_rates: [StripeTaxRateInput!]
  discount: StripeDiscountInput
  discounts: [StripeDiscountInput!]
  due_date: Int
  ending_balance: Int
  footer: String
  invoice_pdf: String
  livemode: Boolean
  next_payment_attempt: Int
  number: String
  paid: Boolean
  post_payment_credit_notes_amount: Int
  pre_payment_credit_notes_amount: Int
  receipt_number: String
  starting_balance: Int
  statement_descriptor: String
  status_transitions: StripeStatusTransitionsInput
  subscription_proration_date: Int
  subtotal: Int
  tax: Int
  threshold_reason: StripeThesholdReasonInput
  total_discount_amounts: [StripeDiscountAmountInput!]
  total_tax_amounts: [StripeTaxAmountInput!]
  webhooks_delivered_at: Int
}

input StripeUsageRecordInputOpt {
  hypi: HypiInputOpt
  id: String
  quantity: Int
  subscription_item: StripeSubscriptionItemInputOpt
  timestamp: Int
  object: String
  livemode: Boolean
}

enum StripeOutcomeType {
  AUTHORIZED
  MANUAL_REVIEW
  ISSUER_DECLINED
  BLOCKED
  INVALID
}

input PredictionDataInputOpt {
  hypi: HypiInputOpt
  modelName: String
  data: [ObjectSubjectRatingTripletInputOpt]
}

input AggregatedPolicyInput {
  hypi: HypiInput
  policies: [PolicyInput!]!
  decisionStrategy: DecisionStrategy
  name: String!
  logic: AuthLogic
}

"""Scalar fields defined by StripeOxxoDisplayDetails"""
enum StripeOxxoDisplayDetailsScalarFields {
  expires_after
  hosted_voucher_url
  number
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeBankAccountAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePaymentOptionInput {
  country: StripeSofortCountry
  hypi: HypiInput
  id: String
  object: String
}

input StripeProductGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeProductScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeNextAction"""
enum StripeNextActionFields {
  hypi
  alipay_handle_redirect
  oxxo_display_details
  redirect_to_url
  type
  id
  use_stripe_sdk
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeRefundInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

type Address {
  hypi: Hypi
  door: String
  street: String
  town: String
  county: String
  city: String
  country: Country
  postCode: String

  """  country: Country"""
  from: DateTime
  to: DateTime
}

"""Scalar fields defined by WebhookResponse"""
enum WebhookResponseScalarFields {
  status
  headers
  body
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by Script"""
enum ScriptScalarFields {
  type
  name
  body
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeSubscriptionUpdateInput {
  hypi: HypiInput
  billing_cycle_anchor: Int
  expires_at: Int
  trial_end: Int
  trial_from_plan: Boolean
  subscription_items: [StripeSubscriptionItemInput!]
}

input OAuthProviderInput {
  hypi: HypiInput
  clientId: String!
  clientSecret: String!
  clientAuthenticationMethod: ClientAuthenticationMethod
  authorizationGrantType: AuthorizationGrantType
  redirectUriTemplate: String
  scopes: [String!]
  authorizationUri: String
  tokenUri: String
  userInfoUri: String
  userInfoAuthenticationMethod: AuthenticationMethod
  userNameAttributeName: UserNameAttributeName
  jwkSetUri: String
  configurationMetadata: [PairInput!]
  clientName: String
  hypiSuccessRedirectUri: String
  hypiFailureRedirectUri: String
}

type Image {
  hypi: Hypi
  name: String!
  file: File!
  description: String
  location: Geo
}

input StripePackageDimensionsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePackageDimensionsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""DateTime scalar"""
scalar DateTime

input StripeFraudDetailsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeFraudDetailsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeTaxId"""
enum StripeTaxIdFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeTaxAmountInput {
  hypi: HypiInput
  amount: Int
  inclusive: Boolean
  tax_rate: StripeTaxRateInput
}

type StripeMandateAggs {
  id: AggOtherScalar
  status: AggOtherScalar
  type: AggOtherScalar
  object: AggOtherScalar
  livemode: AggOtherScalar
  multi_use: AggOtherScalar
  single_use: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
A Stripe API Charge to a card.
https://stripe.com/docs/api/charges

To charge a credit or a debit card, you create a Charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique, random ID.
"""
type StripeCharge {
  hypi: Hypi

  """Unique identifier for the object."""
  id: String

  """
  Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or equivalent in charge currency. The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
  """
  amount: Float

  """
  ID of the balance transaction that describes the impact of this charge on your account balance (not including refunds or disputes).
  """
  balance_transaction: StripeCustomerBalanceTransaction

  """
  Billing information associated with the payment method at the time of the transaction.
  """
  billing_details: StripeBillingDetails

  """
  Three-letter ISO currency code, in lowercase. Must be a supported currency.
  """
  currency: String

  """
  An arbitrary string attached to the object. Often useful for displaying to users.
  """
  description: String

  """Whether the charge has been disputed."""
  disputed: Boolean

  """
  ID of the invoice this charge is for if one exists.
  In stripe this is the invoice ID, in Hypi it links directly to the Invoice object
  """
  invoice: StripeInvoice

  """
  Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
  """
  metadata: Json

  """
  In Stripe this is the ID of the PaymentIntent associated with this charge, if one exists.
  In Hypi this links directly to the object
  """
  payment_intent: StripePaymentIntent

  """Details about the payment method at the time of the transaction."""
  payment_method_details: StripePaymentMethod

  """
  This is the email address that the receipt for this charge was sent to.
  """
  receipt_email: String

  """
  Whether the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.
  """
  refund: Boolean
  shipping: StripeShippingInfo

  """
  For card charges, use statement_descriptor_suffix instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
  """
  statement_descriptor: String

  """
  Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
  """
  statement_descriptor_suffix: String

  """The status of the payment is either succeeded, pending, or failed."""
  status: StripeChargeStatus
  object: String

  """
  Amount in cents refunded (can be less than the amount attribute on the charge if a partial refund was issued).
  """
  amount_refunded: Int

  """ID of the Connect application that created the charge."""
  application: String

  """
  The application fee (if any) for the charge. See the Connect documentation for details.
  """
  application_fee: String

  """The amount of the application fee (if any) requested for the charge."""
  application_fee_amount: Int

  """
  The full statement descriptor that is passed to card networks, and that is displayed on your customers’ credit card and bank statements. Allows you to see what the statement descriptor looks like after the static and dynamic portions are combined.
  """
  calculated_statement_descriptor: String

  """
  If the charge was created without capturing, this Boolean represents whether it is still uncaptured or has since been captured.
  """
  captured: Boolean

  """
  Time at which the object was created. Measured in seconds since the Unix epoch.
  """
  created: DateTime

  """
  Error code explaining reason for charge failure if available (see the errors section for a list of codes).
  """
  failure_code: String

  """
  Message to user further explaining reason for charge failure if available.
  """
  failure_message: String

  """
  Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  """
  live_mode: Boolean

  """
  The account (if any) the charge was made on behalf of without triggering an automatic transfer. See the Connect documentation for details.
  """
  on_behalf_of: String

  """Information on fraud assessments for the charge."""
  fraud_details: StripeFraudDetails

  """ID of the order this charge is for if one exists."""
  order: StripeOrder

  """
  Details about whether the payment was accepted, and why. See understanding declines for details.
  """
  outcome: StripeChargeOutcome
  paid: Boolean
  payment_method: String
  receipt_number: String
  receipt_url: String
  review: StripeReview

  """
  The transfer ID which created this charge. Only present if the charge came from another Stripe account.
  """
  source_transfer: String

  """
  ID of the transfer to the destination account (only applicable if the charge was created using the destination parameter).
  """
  transfer: StripeTransfer

  """
  An optional dictionary including the account to automatically transfer to as part of a destination charge. See the Connect documentation for details.
  """
  transfer_data: StripeTransferData

  """
  A string that identifies this transaction as part of a group. See the Connect documentation for details.
  """
  transfer_group: String
  refunds(arcql: String, first: Int, after: String, last: Int, before: String): [StripeRefund!]
}

type WebhookAggs {
  name: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  query_type: AggOtherScalar
  query_field: AggOtherScalar
  query_selection: AggOtherScalar
}

input CoordinateInputOpt {
  hypi: HypiInputOpt
  x: Float
  y: Float
}

input ProductInputOpt {
  hypi: HypiInputOpt
  title: String
  description: String
  price: Float
}

type StripeInvoiceSettings {
  hypi: Hypi
  days_until_due: Int
}

"""Scalar fields defined by StripeInvoiceItem"""
enum StripeInvoiceItemScalarFields {
  id
  amount
  currency
  description
  metadata
  proration
  object
  date
  discountable
  livemode
  quantity
  unit_amount
  unit_amount_decimal
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
One of Hypi's supported Scripting languages. Currently:
1. Groovy
2. JavaScript

Or full serverless functions via KNative, support for OpenWhisk is to come in a future release
"""
enum TanType {
  Groovy

  """https://velocity.apache.org/engine/2.2/user-guide.html"""
  Velocity

  """
  Any OpenFaaS function can be used. See a python example at https://docs.openfaas.com/tutorials/first-python-function/
  """
  OpenWhisk
  OpenFaaS
}

input ScriptInputOpt {
  hypi: HypiInputOpt
  type: TanType
  name: String
  body: String
}

"""Scalar fields defined by Country"""
enum CountryScalarFields {
  name
  stateName
  sovereignty
  alpha2code
  alpha3code
  numericCode
  subdivisionCodeLinks
  internetCCTLD
  continent
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripePriceRecurrenceMaths {
  interval_count: MathInputInt
}

"""Scalar fields defined by StorageCounter"""
enum StorageCounterScalarFields {
  type
  field
  size
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripePaymentMethod"""
enum StripePaymentMethodScalarFields {
  id
  object
  metadata
  type
  alipay
  bancontact
  card
  created
  eps
  giropay
  interac_present
  livemode
  oxxo
  p24
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeAliPayHandleRedirect"""
enum StripeAliPayHandleRedirectScalarFields {
  native_data
  native_url
  return_url
  url
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeTierGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTierScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeSubscriptionSchedule"""
enum StripeSubscriptionScheduleFields {
  hypi
  id
  object
  current_phase
  customer
  metadata
  status
  subscription
  canceled_at
  completed_at
  created
  default_settings
  end_behavior
  livemode
  released_at
  released_subscription
  phases
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

enum StripeConfirmationMethod {
  automatic
  manual
}

"""
Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships.
https://stripe.com/docs/api/subscription_items
"""
type StripeSubscriptionItem {
  hypi: Hypi
  id: String
  object: String
  metadata: Json
  price: StripePrice
  plan: StripePlan
  quantity: Int
  subscription: StripeSubscription
  billing_thresholds: StripeBillingThreshold
  created: Int
  tax_rates(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxRate!]
}

input PricePlanInclusionInput {
  hypi: HypiInput
  item: InvoiceItemInput
  allow_overage: Boolean
  allowed_overage_amount: Float
  allowed_overage_is_percentage: Boolean
}

input StripeTaxIdGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTaxIdScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type URLAggs {
  path: AggOtherScalar
  queryParams: AggOtherScalar
  port: AggInt
  host: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
The precedence of the operations follows BODMAS. https://en.wikipedia.org/wiki/Order_of_operations
For clarity if all fields are specified the precedence is:
1. Divsion
2. Multiplication
3. Subtraction
4. Addition
"""
input MathInputFloat {
  div: Float
  times: Float
  minus: Float
  plus: Float
  hypi: HypiInput!
}

type StripeDiscountAmount {
  hypi: Hypi
  amount: Int
  discount: StripeDiscount
}

"""
 Specifies a set of utility-objects helpful at runtime but optional for learning algorithm
 parallelism learning in bagging model .
"""
type LearningEnvironment {
  hypi: Hypi

  """Specifies a seed for random number generator."""
  rngSeed: Int

  """
  Specifies the behaviour of processes in ML-algorithms that can may be parallelized such as parallel learning in
  bagging, learning submodels for One-vs-All model, Cross-Validation etc.
  """
  parallelism: Int

  """
  Specify partition data time-to-live in seconds (-1 for an infinite lifetime).
  """
  dataTtl: Int
}

input StripeChargeGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeChargeScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeChargeOutcomeInputOpt {
  hypi: HypiInputOpt
  network_status: StripeNetworkStatus
  reason: String
  risk_level: String
  risk_score: Int
  rule: String
  seller_message: String
  type: StripeOutcomeType
  paid: Boolean
  payment_method: StripePaymentMethodInputOpt
  receipt_number: String
  receipt_url: String
  refunds: [StripeRefundInputOpt]
  review: String
}

"""Scalar fields defined by StripeError"""
enum StripeErrorScalarFields {
  code
  decline_code
  doc_url
  message
  param
  type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeInvoiceLineItemInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input StripeInvoiceInputOpt {
  hypi: HypiInputOpt
  id: String
  auto_advance: Boolean
  charge: StripeChargeInputOpt
  collection_method: StripeCollectionMethod
  currency: String
  customer: StripeCustomerInputOpt
  description: String
  hosted_invoice_url: String
  lines: [StripeInvoiceLineItemInputOpt]
  metadata: Json
  payment_intent: StripePaymentIntentInputOpt
  period_end: Int
  period_start: Int
  status: StripeInvoiceStatus
  subscription: StripeSubscriptionInputOpt
  total: Int
  object: String
  account_country: String
  account_name: String
  account_tax_ids: [StripeTaxIdInputOpt]
  amount_due: Int
  amount_paid: Int
  amount_remaining: Int
  attempt_count: Int
  attempted: Boolean
  billing_reason: String
  created: Int
  custom_fields: [PairInputOpt]
  customer_address: StripeAddressInputOpt
  customer_email: String
  customer_name: String
  customer_phone: String
  customer_shipping: StripeShippingInfoInputOpt
  customer_tax_exempt: String
  customer_tax_ids: [StripeTaxIdInputOpt]
  default_payment_method: StripePaymentMethodInputOpt
  default_source: StripeSourceInputOpt
  default_tax_rates: [StripeTaxRateInputOpt]
  discount: StripeDiscountInputOpt
  discounts: [StripeDiscountInputOpt]
  due_date: Int
  ending_balance: Int
  footer: String
  invoice_pdf: String
  livemode: Boolean
  next_payment_attempt: Int
  number: String
  paid: Boolean
  post_payment_credit_notes_amount: Int
  pre_payment_credit_notes_amount: Int
  receipt_number: String
  starting_balance: Int
  statement_descriptor: String
  status_transitions: StripeStatusTransitionsInputOpt
  subscription_proration_date: Int
  subtotal: Int
  tax: Int
  threshold_reason: StripeThesholdReasonInputOpt
  total_discount_amounts: [StripeDiscountAmountInputOpt]
  total_tax_amounts: [StripeTaxAmountInputOpt]
  webhooks_delivered_at: Int
}

input WorkflowConditionalInputOpt {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInputOpt
  repeatN: Int
  steps: [WorkflowStepInputOpt]
  cronSchedule: String
  repeatIf: GraphQLRefInputOpt
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInputOpt
  evaluateIf: GraphQLRefInputOpt
  order: Int
}

"""Scalar fields defined by StripeItemReason"""
enum StripeItemReasonScalarFields {
  usage_gte
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeItemReasonInput {
  hypi: HypiInput
  line_item_ids: [StripeInvoiceLineItemInput!]
  usage_gte: Int
}

"""Scalar fields defined by RolePolicy"""
enum RolePolicyScalarFields {
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input AggregatedPolicyInputOpt {
  hypi: HypiInputOpt
  policies: [PolicyInputOpt]
  decisionStrategy: DecisionStrategy
  name: String
  logic: AuthLogic
}

enum StripeTierMode {
  graduated
  volume
}

input StripeSubscriptionScheduleInput {
  hypi: HypiInput
  id: String
  object: String
  current_phase: StripeSubscriptionPhaseInput
  customer: StripeCustomerInput
  metadata: Json
  phases: [StripeSubscriptionPhaseInput!]
  status: StripeSubscriptionScheduleStatus
  subscription: StripeSubscriptionInput
  canceled_at: Int
  completed_at: Int
  created: Int
  default_settings: StripeSubscriptionScheduleSettingsInput
  end_behavior: StripeSubscriptionScheduleBehavior
  livemode: Boolean
  released_at: Int
  released_subscription: StripeSubscriptionInput
}

type StripeCustomerPortalAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeDispute"""
enum StripeDisputeFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripePackageDimensionsAggs {
  height: AggFloat
  length: AggFloat
  weight: AggFloat
  width: AggFloat
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeCustomerAcceptanceInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeShippingInfoGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeShippingInfoScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input WorkflowInput {
  hypi: HypiInput
  name: String!
  steps: [WorkflowStepInput!]
  cronSchedule: String
  execAs: String
  async: Boolean
  parallel: Boolean
  maxExecutionTime: String
  repeatN: Int
  evaluateIf: GraphQLRefInput
  repeatIf: GraphQLRefInput
}

input CountryGroupByOptions {
  """The field by which to to group the matching data"""
  field: CountryScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePaymentMethodDetailsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePaymentMethodDetailsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePlanInput {
  hypi: HypiInput
  id: String
  object: String
  active: Boolean
  billing_scheme: StripeBillingScheme
  created: Int
  currency: String
  interval: StripeInterval
  interval_count: Int
  livemode: Boolean
  metadata: Json
  product: String
  tiers_mode: StripeTierMode
  usage_type: StripeUsageType
}

enum StripeInvoiceStatus {
  draft
  open
  paid
  uncollectible
  void
}

"""All numeric fields defined by StripeCardPresent"""
enum StripeCardPresentNumericFields {
  exp_month
  exp_year
}

"""All fields defined by GroupPolicy"""
enum GroupPolicyFields {
  hypi
  name

  """Positive` or `Negative"""
  logic
  groups
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

interface HttpResponse {
  hypi: Hypi
  headers: Json
  status: Int
  rawPayload: String
}

input StorageCounterInput {
  hypi: HypiInput
  type: String!
  field: String!
  size: Int!
}

input StripeInvoiceItemGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeInvoiceItemScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeItemReasonMaths {
  usage_gte: MathInputInt
}

type LoginAttemptAggs {
  successful: AggOtherScalar
  errorCode: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input EmailVerificationInputOpt {
  hypi: HypiInputOpt
  email: EmailInputOpt
  redirectTo: String
  code: String
  from: String
  subject: String
  templateName: String
  htmlMessage: String
  plainTextMessage: String
  meta: Json
  confirmed: Boolean
}

input StripeSebaDebitInputOpt {
  hypi: HypiInputOpt
  bank_code: String
  branch_code: String
  country: String
  fingerprint: String
  last4: String
}

input WebhookResponseInput {
  hypi: HypiInput
  status: Int
  headers: Json
  body: Json
}

"""Scalar fields defined by Webhook"""
enum WebhookScalarFields {
  """
  The name by which this web hook is referenced in the URL, if missing the webhook is only adressable by ID
  """
  name
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_type

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_field

  """
   This refers to a GraphQL function.
   The function must have a graphql argument defined as `(payload: WebhookPayload): WebhookPayload`
   The function can trigger a workflow or operate on the payload itself.
   
  """
  query_selection
}

"""Scalar fields defined by EmailSendingAttempt"""
enum EmailSendingAttemptScalarFields {
  headers
  body
  status
  statusMessage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeEvent"""
enum StripeEventFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input NotificationGroupByOptions {
  """The field by which to to group the matching data"""
  field: NotificationScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StripeReview"""
enum StripeReviewFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripePackageDimensions"""
enum StripePackageDimensionsScalarFields {
  height
  length
  weight
  width
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All numeric fields defined by BruteForceDetectionOptions"""
enum BruteForceDetectionOptionsNumericFields {
  maxLoginFailures
  waitIncrements
  quickLoginCheckMillis
  minQuickLoginWait
  maxWait
  failureReset
}

"""Scalar fields defined by URL"""
enum URLScalarFields {
  path
  queryParams
  port
  host
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by LogMessage"""
enum LogMessageScalarFields {
  level
  message
  stackTrace

  """Optional, may not be a stacktrace"""
  releaseId

  """This is optional, we can have system messages that aren't from an app"""
  type

  """
  The name of the GraphQL type that the log is for, this is also optional
  """
  workflow
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeRefundAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

enum StripeAggregateUsage {
  """for summing up all usage during a period"""
  sum

  """for using the last usage record reported within a period"""
  last_during_period

  """for using the last usage record ever (across period bounds)"""
  last_ever

  """
  which uses the usage record with the maximum reported usage during a period
  """
  max
}

input StripeCustomerBalanceTransactionInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

enum StripeIdealBank {
  abn_amro
  asn_bank
  bunq
  handelsbanken
  ing
  knab
  moneyou
  rabobank
  regiobank
  sns_bank
  triodos_bank
  van_lanschot
}

"""Scalar fields defined by EmailTemplate"""
enum EmailTemplateScalarFields {
  """
   Name of the template being created. The name can contain alpha-numeric characters, digits and next symbols: .-_~
   
  """
  name
  description
  template
  comment
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All numeric fields defined by StripeThesholdReason"""
enum StripeThesholdReasonNumericFields {
  amount_gte
}

type EmailSendingAttempt {
  hypi: Hypi
  headers: Json
  body: Json
  status: EmailEventType
  statusMessage: String
}

type StripeCustomerAcceptance {
  hypi: Hypi
  id: String
  object: String
}

"""All fields defined by NotificationCtx"""
enum NotificationCtxFields {
  hypi

  """The type that the notification applies to"""
  type
  targetAccount
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

interface WorkflowTimed {
  hypi: Hypi

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime: String
}

"""All numeric fields defined by StripeProduct"""
enum StripeProductNumericFields {
  created
  updated
}

"""
A session describes the instantiation of the customer portal for a particular customer. By visiting the session's URL, the customer can manage their subscriptions and billing details. For security reasons, sessions are short-lived and will expire if the customer does not visit the URL. Create sessions on-demand when customers intend to manage their subscriptions and billing details.
https://stripe.com/docs/api/customer_portal
"""
type StripeCustomerPortal {
  hypi: Hypi
  id: String
  object: String
}

"""
Issue a credit note to adjust an invoice's amount after the invoice is finalized.
https://stripe.com/docs/api/credit_notes
"""
type StripeCreditNote {
  hypi: Hypi
  id: String
  object: String
}

input StripeTransferGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeTransferScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StripeTransformQuantity"""
enum StripeTransformQuantityNumericFields {
  divide_by
}

type GroupAggs {
  name: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeDiscountAmountInput {
  hypi: HypiInput
  amount: Int
  discount: StripeDiscountInput
}

type TimePolicyAggs {
  from: AggOtherScalar
  to: AggOtherScalar
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeItemReasonAggs {
  usage_gte: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeReference"""
enum StripeReferenceFields {
  hypi
  entity
  key
  value
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by Image"""
enum ImageFields {
  hypi
  name
  file
  description
  location
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type GeoEnvelopeAggs {
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input LearningEnvironmentMaths {
  rngSeed: MathInputInt
  parallelism: MathInputInt
  dataTtl: MathInputInt
}

interface StripePaymentOption {
  hypi: Hypi
  id: String
  object: String
}

input EmailInput {
  hypi: HypiInput
  value: String!
  type: String
}

input EmailSendingAttemptInput {
  hypi: HypiInput
  headers: Json
  body: Json
  status: EmailEventType
  statusMessage: String
}

"""All fields defined by GraphQLRef"""
enum GraphQLRefFields {
  hypi
  type
  field

  """
   If present this is a set of GraphQL fields that will be selected from the results of the function referenced.
   For example if the type returned by field is "T" and T is the object
   type T {
   a: Int
   b: T2
   }
   type T2 {
   c: String
   }
   then this field can be the selection string:
   a b{c}
   i.e. the GraphQL selection you would use if manually selecting fields from T and T2 WITHOUT any curly braces at the start/end - i.e. no enclosing curlies.
   If not provided, the platform will select hypi{id} meaning the result of this function call will have ONLY the hypi.id field
   
  """
  selection
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeEventGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeEventScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input AuthClientInput {
  hypi: HypiInput
  name: String!
  secret: String!
}

type PricePlanInclusionAggs {
  allow_overage: AggOtherScalar
  allowed_overage_amount: AggFloat
  allowed_overage_is_percentage: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeFraudDetails"""
enum StripeFraudDetailsFields {
  hypi

  """Assessments from Stripe. If set, the value is fraudulent."""
  stripe_report

  """
  Assessments reported by you. If set, possible values of are safe and fraudulent.
  """
  user_report
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripeUsageRecord"""
enum StripeUsageRecordFields {
  hypi
  id
  quantity
  subscription_item
  timestamp
  object
  livemode
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by RecommendationModel"""
enum RecommendationModelScalarFields {
  type
  ratingFieldName
  subjectFieldName
  objectFieldName
  arcql
  name
  description
  label
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeCustomer"""
enum StripeCustomerScalarFields {
  id
  object
  description
  email
  metadata
  name
  phone
  balance
  created
  currency
  delinquent
  invoice_prefix
  livemode
  next_invoice_sequence
  source
  tax_exempt
  preferred_locales
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type RemoteLogin {
  hypi: Hypi
  type: String
  email: String
  remoteId: String
  otherAttributes: Json
}

input StripeIdealInput {
  hypi: HypiInput
  bank: StripeIdealBank
  bic: String
}

input EmailMessageInput {
  hypi: HypiInput
  from: EmailInput!
  to: [EmailInput!]!
  cc: [EmailInput!]
  bcc: [EmailInput!]
  subject: String!
  template: String
  text: String
  html: String
  attachment: [FileInput!]
  inline: [FileInput!]
  tags: [String]
  deliveryTime: DateTime
  requireTls: Boolean
  skipVerification: Boolean
  headers: Json
  variables: Json
  recipientVariables: Json
  responses: [EmailSendingAttemptInput!]
}

input ABACPolicyGroupByOptions {
  """The field by which to to group the matching data"""
  field: ABACPolicyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeOrderInput {
  hypi: HypiInput
  id: String
  object: String
}

"""
Indicates the type should only be evaluated IFF the refrenced function is defined AND executing it returns true.
Any other state results in the evaluation of the conditional e.g.
if evaluateIf is not defined, the conditional is executed.
if evaluateIf is defined but returns anything other than the boolean value true the conditional is executed
"""
interface WorkflowConditional {
  hypi: Hypi
  evaluateIf: GraphQLRef
}

input StripePayoutGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePayoutScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeOxxoDisplayDetailsInputOpt {
  hypi: HypiInputOpt
  expires_after: Int
  hosted_voucher_url: String
  number: String
}

input StripeSebaDebitInput {
  hypi: HypiInput
  bank_code: String
  branch_code: String
  country: String
  fingerprint: String
  last4: String
}

input KMeanCLusteringModelInputOpt {
  hypi: HypiInputOpt
  typeName: String
  arcql: String
  name: String
  description: String
  label: String
}

"""All fields defined by StripeReceipt"""
enum StripeReceiptFields {
  hypi
  account_type
  application_cryptogram
  application_preferred_name
  authorization_code
  authorization_response_code
  cardholder_verification_method
  dedicated_file_name
  terminal_verification_results
  transaction_status_information
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input ScriptGroupByOptions {
  """The field by which to to group the matching data"""
  field: ScriptScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeOxxoDisplayDetailsMaths {
  expires_after: MathInputInt
}

type RealmAggs {
  name: AggOtherScalar
  displayName: AggOtherScalar
  allowRegistrations: AggOtherScalar
  verifyEmail: AggOtherScalar
  referrer: AggOtherScalar
  remoteLoginId: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input ABACTagInput {
  hypi: HypiInput
  key: String!
  value: String
}

"""All fields defined by StripeSubscriptionItem"""
enum StripeSubscriptionItemFields {
  hypi
  id
  object
  metadata
  price
  plan
  quantity
  subscription
  billing_thresholds
  created
  tax_rates
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input RealmPolicyInputOpt {
  hypi: HypiInputOpt
  realms: [RealmLinkInputOpt]
  name: String
  logic: AuthLogic
}

type EmailVerificationAggs {
  redirectTo: AggOtherScalar
  code: AggOtherScalar
  from: AggOtherScalar
  subject: AggOtherScalar
  templateName: AggOtherScalar
  htmlMessage: AggOtherScalar
  plainTextMessage: AggOtherScalar
  meta: AggOtherScalar
  confirmed: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  email_value: AggOtherScalar
  email_type: AggOtherScalar
}

"""Scalar fields defined by GeoEnvelope"""
enum GeoEnvelopeScalarFields {
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input RealmLinkGroupByOptions {
  """The field by which to to group the matching data"""
  field: RealmLinkScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type GraphQLRefAggs {
  type: AggOtherScalar
  field: AggOtherScalar
  selection: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by AccessToken"""
enum AccessTokenScalarFields {
  sessionToken
  sessionExpires
  errorCode
  errorMsg
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeCreditNoteGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCreditNoteScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type ABACTagAggs {
  key: AggOtherScalar
  value: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

interface WorkflowExecutableAs {
  hypi: Hypi

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs: String
}

input LoginAttemptInputOpt {
  hypi: HypiInputOpt
  successful: Boolean
  errorCode: String
}

input StripeCustomerMaths {
  balance: MathInputInt
  created: MathInputInt
  next_invoice_sequence: MathInputInt
}

"""All numeric fields defined by StripeCharge"""
enum StripeChargeNumericFields {
  amount
  amount_refunded
  application_fee_amount
}

"""Scalar fields defined by RemoteLogin"""
enum RemoteLoginScalarFields {
  type
  email
  remoteId
  otherAttributes
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeRefund"""
enum StripeRefundFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by EmailSendingAttempt"""
enum EmailSendingAttemptFields {
  hypi
  headers
  body
  status
  statusMessage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by LoginAttempt"""
enum LoginAttemptScalarFields {
  successful
  errorCode
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by Email"""
enum EmailFields {
  hypi
  value
  type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type GeoEnvelope {
  hypi: Hypi
  p1: Coordinate!
  p2: Coordinate!
}

interface StripeAction {
  hypi: Hypi
  id: String
  object: String
  use_stripe_sdk: String
  redirect_to_url: StripeRedirectToUrl
}

input StripeUsageRecordMaths {
  quantity: MathInputInt
  timestamp: MathInputInt
}

"""Scalar fields defined by StripeProduct"""
enum StripeProductScalarFields {
  id
  active
  description
  metadata
  name
  object
  caption
  created
  livemode
  url
  updated
  unit_label
  statement_descriptor
  shippable
  attributes
  deactivate_on
  images
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
"""
enum StripeUsageType {
  metered
  licensed
}

type GaugeAggs {
  name: AggOtherScalar
  label: AggOtherScalar
  value: AggFloat
  tags: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Creates a reference to a GraphQL function in an app instance."""
type GraphQLRef {
  hypi: Hypi
  type: OpType!
  field: String!

  """
   If present this is a set of GraphQL fields that will be selected from the results of the function referenced.
   For example if the type returned by field is "T" and T is the object
   type T {
   a: Int
   b: T2
   }
   type T2 {
   c: String
   }
   then this field can be the selection string:
   a b{c}
   i.e. the GraphQL selection you would use if manually selecting fields from T and T2 WITHOUT any curly braces at the start/end - i.e. no enclosing curlies.
   If not provided, the platform will select hypi{id} meaning the result of this function call will have ONLY the hypi.id field
   
  """
  selection: String
}

input PasswordReminderGroupByOptions {
  """The field by which to to group the matching data"""
  field: PasswordReminderScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input FileInputOpt {
  hypi: HypiInputOpt
  name: String
  directory: String
  path: String
  isDirectory: Boolean
  status: FileStatus
  url: URLInputOpt
  children: [FileInputOpt]
  type: String
  size: Long
  extension: String
  isStared: Boolean
  isSharable: Boolean
  content: String
}

type LogMessageAggs {
  level: AggOtherScalar
  message: AggOtherScalar
  stackTrace: AggOtherScalar
  releaseId: AggOtherScalar
  type: AggOtherScalar
  workflow: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripePaymentIntent"""
enum StripePaymentIntentFields {
  hypi
  id
  object
  amount
  amount_capturable
  amount_received
  client_secret
  currency
  customer
  description
  last_payment_error
  metadata
  next_action
  payment_method
  receipt_email
  setup_future_usage
  shipping
  statement_descriptor
  statement_descriptor_suffix
  status
  canceled_at
  cncellation_reason
  capture_method
  confirmation_method
  created
  invoice
  livemode
  payment_method_options
  review
  charges
  payment_method_types
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by RealmPolicy"""
enum RealmPolicyScalarFields {
  name

  """Positive` or `Negative"""
  logic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeCouponGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCouponScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeTaxIdInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

input GaugeGroupByOptions {
  """The field by which to to group the matching data"""
  field: GaugeScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by StripeCustomerPortal"""
enum StripeCustomerPortalScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeIntervalObject"""
enum StripeIntervalObjectScalarFields {
  interval
  interval_count
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripePaymentMethodInput {
  hypi: HypiInput
  id: String
  object: String
  billing_details: StripeBillingDetailsInput
  customer: StripeCustomerInput
  metadata: Json
  type: StripePaymentMethds
  alipay: String
  au_becs_debit: StripeAuBecsDebitInput
  bacs_debit: StripeBacsDebitInput
  bancontact: String
  card: String
  card_present: StripeCardPresentInput
  created: Int
  eps: String
  fpx: StripeFpxInput
  giropay: String
  ideal: StripeIdealInput
  interac_present: String
  livemode: Boolean
  oxxo: String
  p24: String
  sepa_debit: StripeSebaDebitInput
  sofort: StripeSofortInput
}

type StripePauseCollection {
  hypi: Hypi
  behavior: StripePauseCollectionBehavior
  resumes_at: Int
}

input WorkflowTimedInputOpt {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInputOpt
  repeatN: Int
  steps: [WorkflowStepInputOpt]
  cronSchedule: String
  repeatIf: GraphQLRefInputOpt
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInputOpt
  evaluateIf: GraphQLRefInputOpt
  order: Int
}

type StripeSetupIntent {
  hypi: Hypi
  id: String
  object: String
  client_secret: String
  customer: StripeCustomer
  description: String
  last_setup_error: StripeError
  metadata: Json
  next_action: StripeNextAction
  payment_method: StripePaymentMethod
  status: String
  cncellation_reason: String
  created: Int
  livemode: Boolean
  payment_method_options: StripePaymentOption
  usage: StripeUsage
  mandate: StripeMandate
  single_use_mandate: StripeMandate
  payment_method_types(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
}

input PairInput {
  hypi: HypiInput
  key: String
  value: String
}

input StripeInvoiceItemInput {
  hypi: HypiInput
  id: String
  amount: Int
  currency: String
  customer: StripeCustomerInput
  description: String
  metadata: Json
  period: StripePeriodInput
  price: StripePriceInput
  proration: Boolean
  object: String
  date: Int
  discountable: Boolean
  discounts: [StripeDiscountInput!]
  invoice: StripeInvoiceInput
  livemode: Boolean
  quantity: Int
  subscription: StripeSubscriptionInput
  subscription_item: StripeSubscriptionItemInput
  tax_rates: [StripeTaxRateInput!]
  unit_amount: Int
  unit_amount_decimal: Float
}

type Permission {
  hypi: Hypi
  name: String!

  """defines how the policy arrives at a decision, defaults to Unanimous"""
  decisionStrategy: DecisionStrategy

  """The type that this permission applies to"""
  type: String!

  """
   If present then the scopes in this permission will have the given policies applied to this resource.
   This can be used for example to prevent mutation on a resource by a user, group etc
   
  """
  resource: String

  """Query, Mutation or Subscription"""
  operationType: OpType!

  """
  If true, this permission grants/denies access to all accounts (including anonymous account)
  """
  includeAllAccounts: Boolean
  policies(arcql: String, first: Int, after: String, last: Int, before: String): [Policy!]
  scopes(arcql: String, first: Int, after: String, last: Int, before: String): [String!]!
  operations(arcql: String, first: Int, after: String, last: Int, before: String): [String]!
}

"""
A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. You can retrieve individual payouts, as well as list all payouts. Payouts are made on varying schedules, depending on your country and industry.
https://stripe.com/docs/api/payouts
"""
type StripePayout {
  hypi: Hypi
  id: String
  object: String
}

"""Time units used in Auth* types"""
enum TimeUnit {
  SECONDS
  MINUTES
  HOURS
  DAYS
}

"""Scalar fields defined by StripeSebaDebit"""
enum StripeSebaDebitScalarFields {
  bank_code
  branch_code
  country
  fingerprint
  last4
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by TimePolicy"""
enum TimePolicyFields {
  hypi

  """
  (yyyy-MM-dd hh:mm:ss) can be used for example to ensure a file is not viewable before the given date
  """
  from

  """can be used to ensure a file is not viewable after a given date"""
  to
  name

  """Positive` or `Negative"""
  logic
  clients
  roles
  groups
  accounts
  realms
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeDiscountAmountMaths {
  amount: MathInputInt
}

input LearningEnvironmentGroupByOptions {
  """The field by which to to group the matching data"""
  field: LearningEnvironmentScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by StripePaymentMethodDetails"""
enum StripePaymentMethodDetailsScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeReviewInput {
  hypi: HypiInput
  id: String
  object: String
}

"""Scalar fields defined by Address"""
enum AddressScalarFields {
  door
  street
  town
  county
  city
  postCode

  """  country: Country"""
  from
  to
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input WorkflowStepGroupByOptions {
  """The field by which to to group the matching data"""
  field: WorkflowStepScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by Group"""
enum GroupScalarFields {
  """
  A unique name identifying this group, implicitly sets the path of the group to /<name> whihc can be referenced in wild card permissions
  """
  name
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
A workflow defines a sequence of steps that execute in a defined order (you set the order field on each step).
It is one way in which Hypi allows you to do composition, so similarities can be drawn to function composition with some specifics thrown in for Hypi and GraphQL.

If two steps have the same order their execution order is undefined with relation to each other.
Every step has a GraphQL function that is executed for that step.

When a Workflow is executed it creates a WorkflowSession. The result of each step in the workflow is added to the session.

The first step can have any parameters you want. For the other steps there are some rules that define how the system maps
parameters to the function in these steps. These rules are:

1. Any step (including the first step) can have a parameter "params: Json" i.e. name = params and type is Json.
This params is a map of the arguments passed to the first function in the Workflow. For example if the function was defined as
step1(a: Int, b: Json, c: MyType): T
in this case the "params" Json object would be have the fields a, b and c set to the values the function was executed with.
Normally, this is used in the first step but can be used in any step that wants access to this data.

2. Any step can have a parameter "session: WorkflowSession" - this is the current workflow's session and contains the results of all steps before the current one.
You can identify the results for a specific step by finding the result using the step's name in the session's data array.

3. Except the first step, a parameter "previous: T" where T is the result type of the previous step can be used.
In this case, the platform will use the output of the previous function for this parameter.
Note that if the type is not the same as the last step's output type then the workflow will fail if the field is not optional.
If the field is optional then the platform will not provide it and it would therefore be null if you try to use it.

4. Except the first step, pass-through is possible. This is where the parameters from the first step are passed through
to other steps by name and type. i.e. given
step1(a: Int, b: String): String
step2(a: Int): ID
In this case, the variable "a" in both step1 and step2 will have the same value that step1 was executed with.
Incidentally, this is the same as getting "a" from the "params" Json.
"""
type Workflow implements WorkflowAsync & WorkflowTimed & WorkflowRepeatable & WorkflowConditional & WorkflowParallel & WorkflowExecutableAs {
  hypi: Hypi
  name: String!

  """
  If present, this is a cron schedule to automatically execute this Workflow
  The syntax as defined at https://www.manpagez.com/man/5/crontab/
  NOTE: The special strings @hourly, @daily etc are NOT supported
  """
  cronSchedule: String

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs: String
  async: Boolean

  """
  If present AND true, all steps in this block are executed at the same time.
  """
  parallel: Boolean

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime: String
  repeatN: Int
  evaluateIf: GraphQLRef
  repeatIf: GraphQLRef
  steps(arcql: String, first: Int, after: String, last: Int, before: String): [WorkflowStep!]
}

input URLGroupByOptions {
  """The field by which to to group the matching data"""
  field: URLScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by PricePlanAllowance"""
enum PricePlanAllowanceFields {
  hypi

  """Time period in which this allowance is given"""
  unit

  """
  Globally control overage allowance - overridden by per inclusion overage settings.
  """
  allow_overage

  """If overage is allowed, how much is allowed?"""
  allowed_overage_amount

  """
  If overage is allowed and an amount is specified, is the amount a percentage?
  """
  allowed_overage_is_percentage
  accessible_to
  inclusions
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePlanGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePlanScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input PredictionDataInput {
  hypi: HypiInput
  modelName: String!
  data: [ObjectSubjectRatingTripletInput!]!
}

input StripeReferenceInputOpt {
  hypi: HypiInputOpt
  entity: String
  key: String
  value: String
}

"""
Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Products help you track inventory or provisioning, and prices help you track payment terms. Different physical goods or levels of service should be represented by products, and pricing options should be represented by prices. This approach lets you change prices without having to change your provisioning scheme.

For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.
https://stripe.com/docs/api/prices
https://stripe.com/docs/api/prices/object
"""
type StripePrice {
  hypi: Hypi

  """Unique identifier for the object."""
  id: String

  """Whether the price can be used for new purchases."""
  active: Boolean

  """
  Three letter ISO currency code (https://www.iso.org/iso-4217-currency-codes.html). Must be a supported currency (https://stripe.com/docs/currencies)
  """
  currency: String

  """
  Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
  """
  metadata: Json

  """A brief description of the plan, hidden from customers."""
  nickname: String

  """
  In Stripe this is the ID of the product this price is associated with.
  In Hypi it links directly to the price object
  """
  product: StripeProduct

  """The recurring components of a price such as interval and usage_type."""
  recurring: StripePriceRecurrence
  type: StripePriceType

  """
  The unit amount in cents (or local currency equivalent) to be charged, represented as a whole integer if possible.
  """
  unit_amount: Int

  """
  String representing the object’s type. Objects of the same type share the same value.
  """
  object: String

  """
  Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
  """
  billing_scheme: StripeBillingScheme
  created: Int

  """
  Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  """
  live_mode: Boolean

  """A lookup key used to retrieve prices dynamically from a static string."""
  lookup_key: String

  """
  Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price. In graduated tiering, pricing can change as the quantity grows.
  """
  tiers_mode: StripeTierMode

  """
  Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with tiers.
  """
  transform_quantity: StripeTransformQuantity

  """
  The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.
  """
  unit_amount_decimal: String
  tiers(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTier]
}

type StripePeriod {
  hypi: Hypi
  start: Int
  end: Int
}

input MLModelInputOpt {
  arcql: String
  subjectFieldName: String
  objectFieldName: String
  trainer: RecommendationTrainerInputOpt
  name: String
  typeName: String
  description: String
  hypi: HypiInputOpt
  label: String
  env: LearningEnvironmentInputOpt
  type: String
  ratingFieldName: String
}

type StripeTaxIdAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePriceMaths {
  unit_amount: MathInputInt
  created: MathInputInt
}

"""All fields defined by StripeItemReason"""
enum StripeItemReasonFields {
  hypi
  usage_gte
  line_item_ids
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input BruteForceDetectionOptionsMaths {
  maxLoginFailures: MathInputInt
  waitIncrements: MathInputInt
  quickLoginCheckMillis: MathInputInt
  minQuickLoginWait: MathInputInt
  maxWait: MathInputInt
  failureReset: MathInputInt
}

"""Scalar fields defined by StripeShippingInfo"""
enum StripeShippingInfoScalarFields {
  """
  The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc.
  """
  carrier

  """Recipient name."""
  name

  """Recipient phone (including extension)."""
  phone

  """
  The tracking number for a physical product, obtained from the delivery service. If multiple tracking numbers were generated for this purchase, please separate them with commas.
  """
  tracking_number
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeSebaDebitAggs {
  bank_code: AggOtherScalar
  branch_code: AggOtherScalar
  country: AggOtherScalar
  fingerprint: AggOtherScalar
  last4: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input OrganisationGroupByOptions {
  """The field by which to to group the matching data"""
  field: OrganisationScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeSubscriptionItemAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  metadata: AggOtherScalar
  quantity: AggInt
  created: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type PredictionData {
  hypi: Hypi
  modelName: String!
  data(arcql: String, first: Int, after: String, last: Int, before: String): [ObjectSubjectRatingTriplet!]!
}

enum StripeFunding {
  credit
  debit
  prepaid
  unknown
}

"""Scalar fields defined by LearningEnvironment"""
enum LearningEnvironmentScalarFields {
  """Specifies a seed for random number generator."""
  rngSeed

  """
  Specifies the behaviour of processes in ML-algorithms that can may be parallelized such as parallel learning in
  bagging, learning submodels for One-vs-All model, Cross-Validation etc.
  """
  parallelism

  """
  Specify partition data time-to-live in seconds (-1 for an infinite lifetime).
  """
  dataTtl
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeReferenceAggs {
  entity: AggOtherScalar
  key: AggOtherScalar
  value: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input AuthClientGroupByOptions {
  """The field by which to to group the matching data"""
  field: AuthClientScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""
A Promotion Code represents a customer-redeemable code for a coupon. It can be used to create multiple codes for a single coupon.
https://stripe.com/docs/api/promotion_codes
"""
type StripePromotionCode {
  hypi: Hypi
  id: String
  object: String
}

input MLModelInput {
  arcql: String
  subjectFieldName: String
  objectFieldName: String
  trainer: RecommendationTrainerInput
  name: String!
  typeName: String
  description: String
  hypi: HypiInput
  label: String
  env: LearningEnvironmentInput
  type: String
  ratingFieldName: String
}

input LanguageGroupByOptions {
  """The field by which to to group the matching data"""
  field: LanguageScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by ServerlessResponse"""
enum ServerlessResponseFields {
  hypi
  path
  headers
  multiPart
  method
  chunked
  queryString
  body
  cookies
  files
  attributes
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by WorkflowStep"""
enum WorkflowStepFields {
  hypi

  """A name that can be used to reference or trigger this step"""
  name

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn
  order

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs
  async

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime
  repeatN
  evaluateIf
  repeatIf
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_hypi

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_type

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_field

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_selection
  evaluateIf_hypi
  evaluateIf_type
  evaluateIf_field
  evaluateIf_selection
  repeatIf_hypi
  repeatIf_type
  repeatIf_field
  repeatIf_selection
}

"""Scalar fields defined by StripeSubscriptionSchedule"""
enum StripeSubscriptionScheduleScalarFields {
  id
  object
  metadata
  status
  canceled_at
  completed_at
  created
  end_behavior
  livemode
  released_at
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input RecommendationTrainerMaths {
  maxIterations: MathInputInt
  minMdlImprovement: MathInputFloat
  batchSize: MathInputInt
  learningRate: MathInputInt
}

enum StripePauseCollectionBehavior {
  keep_as_draft
  mark_uncollectible
  void
}

type StripeBillingDetailsAggs {
  email: AggOtherScalar
  name: AggOtherScalar
  phone: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input RequestTemplateInputOpt {
  hypi: HypiInputOpt
  name: String
  request: String
  response: String
}

"""All fields defined by StripeAddress"""
enum StripeAddressFields {
  hypi

  """Address line 1 (e.g., street, PO Box, or company name)."""
  line1

  """Address line 2 (e.g., apartment, suite, unit, or building)."""
  line2

  """City, district, suburb, town, or village."""
  city

  """Two-letter country code (ISO 3166-1 alpha-2)."""
  country

  """State, county, province, or region."""
  state

  """ZIP or postal code."""
  postal_code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripeSebaDebit"""
enum StripeSebaDebitFields {
  hypi
  bank_code
  branch_code
  country
  fingerprint
  last4
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripePaymentMethodDetails {
  hypi: Hypi
  id: String
  object: String
}

"""All fields defined by StripeSofort"""
enum StripeSofortFields {
  hypi
  country
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input CoordinateGroupByOptions {
  """The field by which to to group the matching data"""
  field: CoordinateScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input LearningEnvironmentInput {
  hypi: HypiInput
  rngSeed: Int
  parallelism: Int
  dataTtl: Int
}

type PricePlanAllowance {
  hypi: Hypi

  """Time period in which this allowance is given"""
  unit: TimeUnit

  """
  Globally control overage allowance - overridden by per inclusion overage settings.
  """
  allow_overage: Boolean

  """If overage is allowed, how much is allowed?"""
  allowed_overage_amount: Float

  """
  If overage is allowed and an amount is specified, is the amount a percentage?
  """
  allowed_overage_is_percentage: Boolean
  accessible_to(arcql: String, first: Int, after: String, last: Int, before: String): [Account]
  inclusions(arcql: String, first: Int, after: String, last: Int, before: String): [PricePlanInclusion!]
}

"""Scalar fields defined by ObjectSubjectRatingTriplet"""
enum ObjectSubjectRatingTripletScalarFields {
  subjectId
  objectId
  rating
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeAliPayHandleRedirectInput {
  hypi: HypiInput
  native_data: String
  native_url: String
  return_url: String
  url: String
}

input CounterInput {
  hypi: HypiInput
  name: String!
  label: String
  tags: [String!]
  value: Float!
}

"""Shipping information for the charge."""
type StripeShippingInfo {
  hypi: Hypi

  """Shipping address."""
  address: StripeAddress

  """
  The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc.
  """
  carrier: String

  """Recipient name."""
  name: String

  """Recipient phone (including extension)."""
  phone: String

  """
  The tracking number for a physical product, obtained from the delivery service. If multiple tracking numbers were generated for this purchase, please separate them with commas.
  """
  tracking_number: String
}

"""Scalar fields defined by Product"""
enum ProductScalarFields {
  title
  description
  price
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripePaymentIntent"""
enum StripePaymentIntentScalarFields {
  id
  object
  amount
  amount_capturable
  amount_received
  client_secret
  currency
  description
  metadata
  receipt_email
  setup_future_usage
  statement_descriptor
  statement_descriptor_suffix
  status
  canceled_at
  cncellation_reason
  capture_method
  confirmation_method
  created
  livemode
  review
  payment_method_types
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by URL"""
enum URLFields {
  hypi
  path
  queryParams
  port
  host
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePauseCollectionInput {
  hypi: HypiInput
  behavior: StripePauseCollectionBehavior
  resumes_at: Int
}

"""
Sometimes you want to add a charge or credit to a customer, but actually charge or credit the customer's card only at the end of a regular billing cycle. This is useful for combining several charges (to minimize per-transaction fees), or for having Stripe tabulate your usage-based billing totals.
https://stripe.com/docs/api/invoiceitems
"""
type StripeInvoiceItem {
  hypi: Hypi
  id: String
  amount: Int
  currency: String
  customer: StripeCustomer
  description: String
  metadata: Json
  period: StripePeriod
  price: StripePrice
  proration: Boolean
  object: String
  date: Int
  discountable: Boolean
  invoice: StripeInvoice
  livemode: Boolean
  quantity: Int
  subscription: StripeSubscription
  subscription_item: StripeSubscriptionItem
  unit_amount: Int
  unit_amount_decimal: Float
  discounts(arcql: String, first: Int, after: String, last: Int, before: String): [StripeDiscount!]
  tax_rates(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxRate!]
}

type KMeanCLusteringModel implements MLModel {
  hypi: Hypi
  typeName: String!
  arcql: String
  name: String!
  description: String
  label: String
}

input EmailMessageInputOpt {
  hypi: HypiInputOpt
  from: EmailInputOpt
  to: [EmailInputOpt]
  cc: [EmailInputOpt]
  bcc: [EmailInputOpt]
  subject: String
  template: String
  text: String
  html: String
  attachment: [FileInputOpt]
  inline: [FileInputOpt]
  tags: [String]
  deliveryTime: DateTime
  requireTls: Boolean
  skipVerification: Boolean
  headers: Json
  variables: Json
  recipientVariables: Json
  responses: [EmailSendingAttemptInputOpt]
}

enum StripeReadMethod {
  contact_emv
  contactless_emv
  magnetic_stripe_track2
  magnetic_stripe_fallback
  contactless_magstripe_mode
}

input StripeInvoiceItemInputOpt {
  hypi: HypiInputOpt
  id: String
  amount: Int
  currency: String
  customer: StripeCustomerInputOpt
  description: String
  metadata: Json
  period: StripePeriodInputOpt
  price: StripePriceInputOpt
  proration: Boolean
  object: String
  date: Int
  discountable: Boolean
  discounts: [StripeDiscountInputOpt]
  invoice: StripeInvoiceInputOpt
  livemode: Boolean
  quantity: Int
  subscription: StripeSubscriptionInputOpt
  subscription_item: StripeSubscriptionItemInputOpt
  tax_rates: [StripeTaxRateInputOpt]
  unit_amount: Int
  unit_amount_decimal: Float
}

input CoordinateMaths {
  x: MathInputFloat
  y: MathInputFloat
}

"""All fields defined by StripeSubscription"""
enum StripeSubscriptionFields {
  hypi
  id
  object
  cancel_at_period_end
  current_period_end
  current_period_start
  customer
  default_payment_method
  latest_invoice
  metadata
  pending_setup_intent
  pending_update
  status
  billing_cycle_anchor
  billing_thresholds
  cancel_at
  canceled_at
  collection_method
  created
  days_until_due
  default_source
  discount
  ended_at
  livemode
  next_pending_invoice_item_invoice
  pause_collection
  pending_invoice_item_interval
  schedule
  start_date
  trial_end
  trial_start
  items
  default_tax_rates
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

enum HashAlgorithm {
  SHA3
  BCRYPT

  """
   PKCS i.e. Public Key Cryptography Standards. When used Hypi will encrypt/decrypt the contents using a public/private key pair.
   So the data is encrypted at rest and decrypted whilst in use.
   See https://en.wikipedia.org/wiki/PKCS, specifically Password-based Encryption Standard
   
  """
  PKCS5
}

input StripeDiscountGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeDiscountScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input PricePlanInput {
  hypi: HypiInput
  allowance: PricePlanAllowanceInput
  bill_to: AccountInput
  billing_frequency: TimeUnit
  default_card: String
  invoices: [InvoiceInput]
  valid_from: DateTime
  valid_to: DateTime
}

type TrainingInstanceAggs {
  status: AggOtherScalar
  errors: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""
A row is created for every resource. It cannot be created or modified by end users.
The ID of each entry is a hash of the resource ID, type and field.
When the resource is deleted, the entry is deleted.
"""
type StorageCounter {
  hypi: Hypi
  type: String!
  field: String!
  size: Int!
}

input StripeErrorInputOpt {
  hypi: HypiInputOpt
  charge: StripeChargeInputOpt
  code: String
  decline_code: String
  doc_url: String
  message: String
  param: String
  payment_method: StripePaymentMethodInputOpt
  type: String
}

"""All numeric fields defined by StripePaymentMethod"""
enum StripePaymentMethodNumericFields {
  created
}

input StripeActionInputOpt {
  oxxo_display_details: StripeOxxoDisplayDetailsInputOpt
  redirect_to_url: StripeRedirectToUrlInputOpt
  alipay_handle_redirect: StripeAliPayHandleRedirectInputOpt
  hypi: HypiInputOpt
  id: String
  type: StripeNextActionType
  use_stripe_sdk: String
  object: String
}

"""All numeric fields defined by StripeDiscountAmount"""
enum StripeDiscountAmountNumericFields {
  amount
}

enum StripeSubscriptionScheduleStatus {
  not_started
  active
  completed
  released
  canceled
}

input PricePlanInclusionGroupByOptions {
  """The field by which to to group the matching data"""
  field: PricePlanInclusionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input TimePolicyInput {
  hypi: HypiInput
  from: DateTime
  to: DateTime
  clients: [AuthClientInput!]
  roles: [RoleInput!]
  groups: [GroupInput!]
  accounts: [AccountInput!]
  realms: [RealmLinkInput!]
  name: String!
  logic: AuthLogic
}

"""All fields defined by Product"""
enum ProductFields {
  hypi
  title
  description
  price
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

enum StripeSofortCountry {
  AT

  """ Austria"""
  BE

  """ Belgium"""
  DE

  """ Germany"""
  ES

  """ Spain"""
  IT

  """ Italy"""
  NL
}

input WorkflowInputOpt {
  hypi: HypiInputOpt
  name: String
  steps: [WorkflowStepInputOpt]
  cronSchedule: String
  execAs: String
  async: Boolean
  parallel: Boolean
  maxExecutionTime: String
  repeatN: Int
  evaluateIf: GraphQLRefInputOpt
  repeatIf: GraphQLRefInputOpt
}

"""
The decision strategy dictates how the policies associated with a given permission are evaluated and how a final decision is obtained.
'Affirmative' means that at least one policy must evaluate to a positive decision in order for the final decision to be also positive.
'Unanimous' means that all policies must evaluate to a positive decision in order for the final decision to be also positive.
'Consensus' means that the number of positive decisions must be greater than the number of negative decisions.
If the number of positive and negative is the same, the final decision will be negative.
"""
enum DecisionStrategy {
  """
  There MUST be at least one policy AND all policies listed must be positive for this policy to result in a positive decision
  """
  Unanimous

  """
  at least one policy listed must be positive for this policy to result in a positive decision
  """
  Affirmative

  """
  The number of policies that are positive must be greater than those that are negative e.g. if 5 policies are included, at least 3 must be positive for this policy to be positive
  """
  Consensus
}

"""
You can add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer.
https://stripe.com/docs/api/customer_tax_ids
"""
type StripeTaxId {
  hypi: Hypi
  id: String
  object: String
}

"""All fields defined by Counter"""
enum CounterFields {
  hypi

  """
  A name which uniquely identifies this counter in an instance. Must be a letter followed by 0 or more letters, numbers or underscores
  """
  name

  """A human friendly display label for the counter"""
  label

  """
  The value of the counter. Semantically this is intended to be monotonically increasing but this is not currently enforced
  See the Gauge type if you want to arbitrarily increase/decrease/set value on a type
  """
  value
  tags
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripePeriodAggs {
  start: AggInt
  end: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeBillingDetailsInputOpt {
  hypi: HypiInputOpt
  address: StripeAddressInputOpt
  email: String
  name: String
  phone: String
}

input StripeBillingThresholdMaths {
  usage_gte: MathInputInt
  amount_gte: MathInputInt
}

"""All fields defined by Role"""
enum RoleFields {
  hypi
  name
  accounts
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeReceiptGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeReceiptScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input GroupInput {
  hypi: HypiInput
  name: String!
  accounts: [AccountInput!]
  children: [GroupInput!]
  organisations: [OrganisationInput!]
}

"""
Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers.
https://stripe.com/docs/api/sources
"""
type StripeSource {
  hypi: Hypi
  id: String
  object: String
  client_secret: String
  reusable: Boolean
  livemode: Boolean
}

type RoleAggs {
  name: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeTransferData"""
enum StripeTransferDataFields {
  hypi
  amount
  destination
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeNextAction implements StripeAction {
  hypi: Hypi
  alipay_handle_redirect: StripeAliPayHandleRedirect
  oxxo_display_details: StripeOxxoDisplayDetails
  redirect_to_url: StripeRedirectToUrl
  type: StripeNextActionType
  id: String
  use_stripe_sdk: String
  object: String
}

input StripeSubscriptionScheduleSettingsInput {
  hypi: HypiInput
  billing_cycle_anchor: StripeBillingCycleAnchor
  billing_thresholds: StripeBillingThresholdInput
  collection_method: StripeCollectionMethod
  default_payment_method: StripePaymentMethodInput
  invoice_settings: StripeInvoiceSettingsInput
}

"""All numeric fields defined by StripeCustomer"""
enum StripeCustomerNumericFields {
  balance
  created
  next_invoice_sequence
}

input StripeInvoiceSettingsInputOpt {
  hypi: HypiInputOpt
  days_until_due: Int
}

input WorkflowExecutableAsInput {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInput
  repeatN: Int
  steps: [WorkflowStepInput!]
  cronSchedule: String
  repeatIf: GraphQLRefInput
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInput
  evaluateIf: GraphQLRefInput
  order: Int
}

input StripeBacsDebitInputOpt {
  hypi: HypiInputOpt
  fingerprint: String
  last4: String
  sort_code: String
}

"""
Defines a Hypi template that can be parameterised
https://documentation.Hypi.com/en/latest/api-templates.html#store-new-template
"""
type EmailTemplate {
  hypi: Hypi

  """
   Name of the template being created. The name can contain alpha-numeric characters, digits and next symbols: .-_~
   
  """
  name: String
  description: String
  template: String
  comment: String
}

"""All numeric fields defined by StripeOxxoDisplayDetails"""
enum StripeOxxoDisplayDetailsNumericFields {
  expires_after
}

"""All fields defined by AggOtherScalar"""
enum AggOtherScalarFields {
  hypi

  """The value of the aggregated field for each group"""
  groupValues
  count
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags

  """The value of the aggregated field for each group"""
  groupValues_hypi

  """The value of the aggregated field for each group"""
  groupValues_key

  """The value of the aggregated field for each group"""
  groupValues_value
}

input StripeTierMaths {
  flat_amount: MathInputInt
  flat_amount_decimal: MathInputFloat
  unit_amount: MathInputInt
  unit_amount_decimal: MathInputFloat
}

type WorkflowSessionAggs {
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeSubscriptionItem"""
enum StripeSubscriptionItemScalarFields {
  id
  object
  metadata
  quantity
  created
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""
An object injected into ALL types as the field "hypi"
"""
type Hypi {
  """
  An ID automatically generated by the platform for new objects.
  If provided and the ID does not exist, the provided ID is used instead of a generated one and a new entry is inserted
  If provided and the ID already exists then the existing object is updated.
  """
  id: ID

  """
  When you work with interface fields, Hypi is unable to distinguish which implementation you intend to use
  automatically, you must set this field to the name of the implementation of the interface e.g.
  If creating an AccountPolicy which implements the Policy interface, this field should be set to AccountPolicy
  """
  impl: String

  """The ISO8601 date of when the object was created"""
  created: DateTime

  """The ISO8601 date of when the object was last modified"""
  updated: DateTime

  """
  The ISO8601 date of when the object was trashed (if it is currently trashed, null otherwise)
  """
  trashed: DateTime

  """The ID of the account which created the object"""
  createdBy: ID

  """The ID of the app instance which created and owns the object"""
  instanceId: String
  tags(arcql: String, first: Int, after: String, last: Int, before: String): [ABACTag!]
}

input RoleInputOpt {
  hypi: HypiInputOpt
  name: String
  accounts: [AccountInputOpt]
}

type PersonNameAggs {
  title: AggOtherScalar
  firstName: AggOtherScalar
  lastName: AggOtherScalar
  from: AggOtherScalar
  to: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by HypiEnv"""
enum HypiEnvScalarFields {
  apiHost
  websocketHost
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeChargeOutcome"""
enum StripeChargeOutcomeFields {
  hypi
  network_status

  """
  An enumerated value providing a more detailed explanation of the outcome’s type. Charges blocked by Radar’s default block rule have the value highest_risk_level. Charges placed in review by Radar’s default review rule have the value elevated_risk_level.
  """
  reason

  """
  Stripe’s evaluation of the riskiness of the payment. Possible values for evaluated payments are normal, elevated, highest. For non-card payments, and card-based payments predating the public assignment of risk levels, this field will have the value not_assessed. In the event of an error in the evaluation, this field will have the value unknown.
  """
  risk_level

  """
  Stripe’s evaluation of the riskiness of the payment. Possible values for evaluated payments are between 0 and 100. For non-card payments, card-based payments predating the public assignment of risk scores, or in the event of an error during evaluation, this field will not be present. This field is only available with Radar for Fraud Teams.
  """
  risk_score

  """The ID of the Radar rule that matched the payment, if applicable."""
  rule

  """
  A human-readable description of the outcome type and reason, designed for you (the recipient of the payment), not your customer.
  """
  seller_message

  """
  Possible values are authorized, manual_review, issuer_declined, blocked, and invalid.
  """
  type

  """
  true if the charge succeeded, or was successfully authorized for later capture.
  """
  paid

  """
  In Stripe ID of the payment method used in this charge. In Hypi it directly links to the object
  """
  payment_method

  """
  This is the transaction number that appears on email receipts sent for this charge. This attribute will be null until a receipt has been sent.
  """
  receipt_number

  """
  This is the URL to view the receipt for this charge. The receipt is kept up-to-date to the latest state of the charge, including any refunds. If the charge is for an Invoice, the receipt will be stylized as an Invoice receipt.
  """
  receipt_url
  review
  refunds
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type GroupPolicyAggs {
  name: AggOtherScalar
  logic: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeCustomer"""
enum StripeCustomerFields {
  hypi
  id
  object
  address
  description
  email
  metadata
  name
  phone
  shipping
  balance
  created
  currency
  default_source
  delinquent
  discount
  invoice_prefix
  invoice_settings
  livemode
  next_invoice_sequence
  source
  tax_exempt
  preferred_locales
  sources
  subscriptions
  tax_ids
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type RequestTemplateAggs {
  name: AggOtherScalar
  request: AggOtherScalar
  response: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type LearningEnvironmentAggs {
  rngSeed: AggInt
  parallelism: AggInt
  dataTtl: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeOxxoDisplayDetailsGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeOxxoDisplayDetailsScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type WorkflowAggs {
  name: AggOtherScalar
  cronSchedule: AggOtherScalar
  execAs: AggOtherScalar
  async: AggOtherScalar
  parallel: AggOtherScalar
  maxExecutionTime: AggOtherScalar
  repeatN: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  evaluateIf_type: AggOtherScalar
  evaluateIf_field: AggOtherScalar
  evaluateIf_selection: AggOtherScalar
  repeatIf_type: AggOtherScalar
  repeatIf_field: AggOtherScalar
  repeatIf_selection: AggOtherScalar
}

""" namespace for containing authz objects and their relationships."""
type Realm {
  hypi: Hypi

  """
  the name identifying the organisation and becomes the URL by which it is accessed e.g. alpha-corp.hypi.app, where alpha-corp is name
  If not provided one will be automatically generated
  """
  name: String
  logo: Image

  """The name displayed in the user interface"""
  displayName: String

  """If true users can register without an admin creating their account"""
  allowRegistrations: Boolean

  """if true users must verify their email before they're allowed to login"""
  verifyEmail: Boolean

  """
  Optionally defines some options to help detect and protect against brute force login attempts
  """
  bruteForceDetection: BruteForceDetectionOptions
  referrer: String
  remoteLoginId: String
  organisations(arcql: String, first: Int, after: String, last: Int, before: String): [Organisation!]!
}

"""Scalar fields defined by WorkflowSession"""
enum WorkflowSessionScalarFields {
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type Pair {
  hypi: Hypi
  key: String
  value: String
}

input LanguageInput {
  hypi: HypiInput
  family: String
  isoName: String
  nativeName: String
  iso6391Code: String
  iso6392TCode: String
  iso6392BCode: String
  iso6393Code: String
}

"""All numeric fields defined by StripeSetupIntent"""
enum StripeSetupIntentNumericFields {
  created
}

"""All fields defined by PricePlanInclusion"""
enum PricePlanInclusionFields {
  hypi
  item
  allow_overage

  """If overage is allowed, how much is allowed?"""
  allowed_overage_amount

  """
  If overage is allowed and an amount is specified, is the amount a percentage?
  """
  allowed_overage_is_percentage
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeCreditNoteInput {
  hypi: HypiInput
  id: String
  object: String
}

input StripeStatusTransitionsInput {
  hypi: HypiInput
  finalized_at: Int
  marked_uncollectible_at: Int
  paid_at: Int
  voided_at: Int
}

"""All fields defined by AuthClient"""
enum AuthClientFields {
  hypi
  name
  secret
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by ABACPolicy"""
enum ABACPolicyScalarFields {
  from
  to

  """
   The instance the policy applies to. By default the same instance in which it exists.
   A `Platform Admin` can set it to *, all other users get permission denied if this is not the same as their current instance.
   
  """
  givenInstance

  """e.g. Account or *"""
  givenType

  """Exactly one of Query|Mutation|Subscription|*"""
  givenOperation

  """The exact function name or wildcard e.g. find|upsert|*"""
  givenFn

  """
  The prefix that any function can begin with e.g. find will match findX, findY, findOther
  """
  givenFnPrefix
  whenResourceTagKeyEq
  whenResourceTagKeyPrefix
  whenResourceTagValueEq
  whenResourceTagValuePrefix

  """Policy applies when the account ID is equal to this"""
  assertAccountIdEq

  """Policy applies when the account username starts with this"""
  assertAccountUsernamePrefix

  """When set, the account MUST have a tag whose key is equal to this"""
  assertAccountTagKeyEq

  """When set, the account MUST have a tag whose key is starts with this"""
  assertAccountTagKeyPrefix

  """When set, the account MUST have a tag whose value is equal to this"""
  assertAccountTagValEq

  """When set, the account MUST have a tag whose value is starts with this"""
  assertAccountTagValPrefix

  """
  Resource owner can set the boundary to RESOURCE (or anyone that has permission to do so)
  System Admin for the instance can set the boundary to INSTANCE
  Platform Admin can set the boundary to PLATFORM
  PLATFORM|INSTANCE|RESOURCE
  """
  boundary

  """
  If provided, this is a comma separate list of field paths that are allowed by this policy
  e.g. a,b.c allows access to a and all sub-fields below it as well as to the field c under the parent field b. No other field under b is allowed
  If the policy is allowing read access, only these fields can be seen. If it is write acces, only these fields can be modified.
  """
  allowedFields
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type NotificationAggs {
  message: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  ctx_type: AggOtherScalar
  ctx_targetAccount: AggOtherScalar
}

type BruteForceDetectionOptionsAggs {
  maxLoginFailures: AggInt
  waitIncrements: AggInt
  waitIncrementsUnit: AggOtherScalar
  quickLoginCheckMillis: AggInt
  minQuickLoginWait: AggInt
  minQuickLoginWaitUnit: AggOtherScalar
  maxWait: AggInt
  maxWaitUnit: AggOtherScalar
  failureReset: AggInt
  failureResetUnit: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeDiscountAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type RemoteLoginAggs {
  type: AggOtherScalar
  email: AggOtherScalar
  remoteId: AggOtherScalar
  otherAttributes: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type PricePlanAllowanceAggs {
  unit: AggOtherScalar
  allow_overage: AggOtherScalar
  allowed_overage_amount: AggFloat
  allowed_overage_is_percentage: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type StripeRedirectToUrl {
  hypi: Hypi
  return_url: String
  url: String
}

"""All fields defined by StripeCheckoutSession"""
enum StripeCheckoutSessionFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeBillingThreshold"""
enum StripeBillingThresholdScalarFields {
  usage_gte
  amount_gte
  reset_billing_cycle_anchor
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by Password"""
enum PasswordScalarFields {
  """
   password is never returned
   further, the @secret directive enforces this, queries can be use to perform comparison against the field but it is never returned
   
  """
  value
  expired
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input PricePlanInclusionMaths {
  allowed_overage_amount: MathInputFloat
}

input OAuthProviderInputOpt {
  hypi: HypiInputOpt
  clientId: String
  clientSecret: String
  clientAuthenticationMethod: ClientAuthenticationMethod
  authorizationGrantType: AuthorizationGrantType
  redirectUriTemplate: String
  scopes: [String]
  authorizationUri: String
  tokenUri: String
  userInfoUri: String
  userInfoAuthenticationMethod: AuthenticationMethod
  userNameAttributeName: UserNameAttributeName
  jwkSetUri: String
  configurationMetadata: [PairInputOpt]
  clientName: String
  hypiSuccessRedirectUri: String
  hypiFailureRedirectUri: String
}

type Account {
  hypi: Hypi
  verified: Boolean
  enabled: Boolean
  username: String!
  password: Password!
  owner: Person
  emails(arcql: String, first: Int, after: String, last: Int, before: String): [Email!]
  phones(arcql: String, first: Int, after: String, last: Int, before: String): [Phone!]
  groups(arcql: String, first: Int, after: String, last: Int, before: String): [Group!]
  roles(arcql: String, first: Int, after: String, last: Int, before: String): [Role!]
  attempts(arcql: String, first: Int, after: String, last: Int, before: String): [LoginAttempt!]
  remoteLogins(arcql: String, first: Int, after: String, last: Int, before: String): [RemoteLogin!]
}

enum AuthLogic {
  """Access will be granted"""
  Positive

  """Access will be denied"""
  Negative
}

input StripeNextActionInputOpt {
  hypi: HypiInputOpt
  alipay_handle_redirect: StripeAliPayHandleRedirectInputOpt
  oxxo_display_details: StripeOxxoDisplayDetailsInputOpt
  redirect_to_url: StripeRedirectToUrlInputOpt
  type: StripeNextActionType
  id: String
  use_stripe_sdk: String
  object: String
}

input PricePlanAllowanceGroupByOptions {
  """The field by which to to group the matching data"""
  field: PricePlanAllowanceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeFpxInputOpt {
  hypi: HypiInputOpt
  bank: StripeFpxBank
}

"""All numeric fields defined by StripeTransferData"""
enum StripeTransferDataNumericFields {
  amount
}

input WorkflowRepeatableInput {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInput
  repeatN: Int
  steps: [WorkflowStepInput!]
  cronSchedule: String
  repeatIf: GraphQLRefInput
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInput
  evaluateIf: GraphQLRefInput
  order: Int
}

input WebhookResponseGroupByOptions {
  """The field by which to to group the matching data"""
  field: WebhookResponseScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StripePriceRecurrence"""
enum StripePriceRecurrenceNumericFields {
  interval_count
}

input PermissionInputOpt {
  hypi: HypiInputOpt
  name: String
  policies: [PolicyInputOpt]
  decisionStrategy: DecisionStrategy
  type: String
  scopes: [String]
  resource: String
  operationType: OpType
  operations: [String]
  includeAllAccounts: Boolean
}

type StripeRedirectToUrlAggs {
  return_url: AggOtherScalar
  url: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input WorkflowSessionInput {
  hypi: HypiInput
  data: [WorkflowStepDataInput!]
}

"""Scalar fields defined by WorkflowStep"""
enum WorkflowStepScalarFields {
  """A name that can be used to reference or trigger this step"""
  name
  order

  """
  An ArcQL query to find the account e.g. hypi.id = 'user123' to find by id or username = 'blah' to find by username
  If present, execution of the steps in the Workflow will be done as this account
  If not specified, it defaults to the account making the request
  """
  execAs
  async

  """
   Specifies the the max time an async task should be allowed to execute. When this time has elapsed the task will be killed.
   The format is ISO8601 durations https://en.wikipedia.org/wiki/ISO_8601#Durations
   e.g. P1M is 1 month and PT1M is 1 minute
   
  """
  maxExecutionTime
  repeatN
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_type

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_field

  """
  The function to execute for this step, the data returned by the step can subsequently be used in other steps
  """
  fn_selection
  evaluateIf_type
  evaluateIf_field
  evaluateIf_selection
  repeatIf_type
  repeatIf_field
  repeatIf_selection
}

input RolePolicyInputOpt {
  hypi: HypiInputOpt
  roles: [RoleInputOpt]
  name: String
  logic: AuthLogic
}

type EmailTemplateAggs {
  name: AggOtherScalar
  description: AggOtherScalar
  template: AggOtherScalar
  comment: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeSubscriptionItemMaths {
  quantity: MathInputInt
  created: MathInputInt
}

"""Scalar fields defined by StripeEvent"""
enum StripeEventScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeSetupIntent"""
enum StripeSetupIntentFields {
  hypi
  id
  object
  client_secret
  customer
  description
  last_setup_error
  metadata
  next_action
  payment_method
  status
  cncellation_reason
  created
  livemode
  payment_method_options
  usage
  mandate
  single_use_mandate
  payment_method_types
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by StripeAuBecsDebit"""
enum StripeAuBecsDebitScalarFields {
  bsb_number
  fingerprint
  last4
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeAliPayHandleRedirect"""
enum StripeAliPayHandleRedirectFields {
  hypi
  native_data
  native_url
  return_url
  url
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input GaugeInput {
  hypi: HypiInput
  name: String!
  label: String
  tags: [String!]
  value: Float!
}

input RecommendationModelGroupByOptions {
  """The field by which to to group the matching data"""
  field: RecommendationModelScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by EmailVerification"""
enum EmailVerificationFields {
  hypi
  email

  """
  After the link is clicked from the email, redirect the browser to this URL passing a token in the URL i.e. token=jwt.token.here which can be used get the value in the meta field
  """
  redirectTo

  """
  The verification code that is included in the email sent. Generated by the server, if provided the provided value is ignored
  """
  code

  """
  Optionally, the email from which the email will be sent. You MUST have a Hypi email app configured to send from this address
  """
  from

  """
  Optionally, the subject of the email, this is a velocity template - Hypi provides a default such as "Please verify your email to <realm>"
  """
  subject
  templateName

  """
   The HTML contents of the email. This is a Velocity template that will be rendered before being sent.
   The available variables and their types are:
   instance: AppId - You app instance ID
   parent - a map representing the current EmailVerification object
   value - the value of the htmlMessage field
   env: HypiEnv
   
  """
  htmlMessage

  """
  A plain text version of the email - see this is a velocity template, see htmlMessage for available variables
  """
  plainTextMessage

  """
  Any additional meta data you want to store. For example, you could collect all of the information needed to create the Account
  """
  meta

  """Set by system, cannot be provided"""
  confirmed
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
  email_hypi
  email_value
  email_type
}

"""All fields defined by ABACTag"""
enum ABACTagFields {
  hypi
  key

  """If provided then policy assertion can be made against it"""
  value
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by AggregatedPolicy"""
enum AggregatedPolicyFields {
  hypi

  """defines how the policy arrives at a decision, the options are:"""
  decisionStrategy
  name

  """Positive` or `Negative"""
  logic
  policies
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripePauseCollectionAggs {
  behavior: AggOtherScalar
  resumes_at: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeUsageRecordInput {
  hypi: HypiInput
  id: String
  quantity: Int
  subscription_item: StripeSubscriptionItemInput
  timestamp: Int
  object: String
  livemode: Boolean
}

type StripeStatusTransitions {
  hypi: Hypi
  finalized_at: Int
  marked_uncollectible_at: Int
  paid_at: Int
  voided_at: Int
}

type StripeErrorAggs {
  code: AggOtherScalar
  decline_code: AggOtherScalar
  doc_url: AggOtherScalar
  message: AggOtherScalar
  param: AggOtherScalar
  type: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type BruteForceDetectionOptions {
  hypi: Hypi
  maxLoginFailures: Int!

  """How long the user ust wait when maxLoginFailures have been reached"""
  waitIncrements: Int
  waitIncrementsUnit: TimeUnit

  """
  If login failures occurr too quickly, lock out the user, this sets number of milliseconds that determine "quickly"
  """
  quickLoginCheckMillis: Int

  """How long to wait after a quick failure lock out"""
  minQuickLoginWait: Int
  minQuickLoginWaitUnit: TimeUnit

  """max time a user will be locked out for"""
  maxWait: Int
  maxWaitUnit: TimeUnit

  """When failure count is reset"""
  failureReset: Int
  failureResetUnit: TimeUnit
}

"""Scalar fields defined by Email"""
enum EmailScalarFields {
  value
  type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input GroupGroupByOptions {
  """The field by which to to group the matching data"""
  field: GroupScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""
Customer objects allow you to perform recurring charges, and to track multiple charges, that are associated with the same customer. The API allows you to create, delete, and update your customers. You can retrieve individual customers as well as a list of all your customers.
https://stripe.com/docs/api/customers
"""
type StripeCustomer {
  hypi: Hypi
  id: String
  object: String
  address: StripeAddress
  description: String
  email: String
  metadata: Json
  name: String
  phone: String
  shipping: StripeShippingInfo
  balance: Int
  created: Int
  currency: String
  default_source: StripeSource
  delinquent: Boolean
  discount: StripeDiscount
  invoice_prefix: String
  invoice_settings: StripeInvoiceSettings
  livemode: Boolean
  next_invoice_sequence: Int
  source: String
  tax_exempt: String
  preferred_locales(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
  sources(arcql: String, first: Int, after: String, last: Int, before: String): [StripeSource!]
  subscriptions(arcql: String, first: Int, after: String, last: Int, before: String): [StripeSubscription!]
  tax_ids(arcql: String, first: Int, after: String, last: Int, before: String): [StripeTaxId!]
}

enum StripeSubscriptionScheduleBehavior {
  release
  cancel
}

"""Scalar fields defined by Video"""
enum VideoScalarFields {
  name
  description
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""All fields defined by StripeFpx"""
enum StripeFpxFields {
  hypi
  bank
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All numeric fields defined by StripeUsageRecord"""
enum StripeUsageRecordNumericFields {
  quantity
  timestamp
}

type TrainingInstance {
  hypi: Hypi
  model: MLModel!
  status: TrainingStatus!
  errors(arcql: String, first: Int, after: String, last: Int, before: String): [String!]
}

"""Scalar fields defined by StripeInvoiceSettings"""
enum StripeInvoiceSettingsScalarFields {
  days_until_due
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeTransformQuantityInputOpt {
  hypi: HypiInputOpt
  divide_by: Int
  round: StripeTransformRounding
}

"""
Based on http://www.tsusiatsoftware.net/
See Geometry Model at http://www.tsusiatsoftware.net/jts/jtsfeatures.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/Geometry.html
Defines a rectangular region of the 2D coordinate plane. It is often used to represent the bounding box of a Geometry, e.g. the minimum and maximum x and y values of the Coordinates.
todo define specific subtypes of Geo and supporting types
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/PrecisionModel.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/Point.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/MultiPoint.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/LineString.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/MultiLineString.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/Polygon.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/MultiPolygon.html
http://www.tsusiatsoftware.net/jts/javadoc/com/vividsolutions/jts/geom/GeometryCollection.html
"""
interface Geo {
  hypi: Hypi
  envelope: GeoEnvelope
  srid: Int
}

type GroupPolicy implements Policy {
  hypi: Hypi
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
  groups(arcql: String, first: Int, after: String, last: Int, before: String): [Group!]
}

"""All numeric fields defined by Invoice"""
enum InvoiceNumericFields {
  vat_amount
}

"""Scalar fields defined by Image"""
enum ImageScalarFields {
  name
  description
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeDispute"""
enum StripeDisputeScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeThesholdReasonMaths {
  amount_gte: MathInputInt
}

type StripeTierAggs {
  flat_amount: AggInt
  flat_amount_decimal: AggFloat
  unit_amount: AggInt
  unit_amount_decimal: AggFloat
  up_to: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type CounterAggs {
  name: AggOtherScalar
  label: AggOtherScalar
  value: AggFloat
  tags: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input ObjectSubjectRatingTripletGroupByOptions {
  """The field by which to to group the matching data"""
  field: ObjectSubjectRatingTripletScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input KMeanCLusteringModelGroupByOptions {
  """The field by which to to group the matching data"""
  field: KMeanCLusteringModelScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePlanMaths {
  created: MathInputInt
  interval_count: MathInputInt
}

"""A list of all types in the app which can created or updated directly"""
enum HypiMutationType {
  Product
  PageInfo
  HypiResultEdge
  HypiFilterConnection
  HypiEnv
  Pair
  AggInt
  AggFloat
  AggOtherScalar
  Script

  """Defines the templates that should be applied to a given HTTP request"""
  RequestTemplate
  NotificationCtx
  Notification
  URL
  Currency
  Coordinate
  GeoEnvelope
  Language
  Address
  PersonName
  Phone
  Email
  Password
  RemoteLogin
  LoginAttempt
  BruteForceDetectionOptions
  OAuth2AuthorizedClient

  """
  A client defines an agent that acts on behalf of a user/subject.
  Currently implicitly created by Hypi.
  """
  AuthClient
  ABACPolicy
  ABACTag
  Image
  EmailVerification

  """
  Defines a Hypi template that can be parameterised
  https://documentation.Hypi.com/en/latest/api-templates.html#store-new-template
  """
  EmailTemplate
  EmailSendingAttempt

  """
  To reset an Account's password, create a `PasswordReminder`.
  
  This will generate a code in the `code` field that can be referenced using $!{parent.code} in the `htmlMessage` or `plainTextMessage` fields.
  
  This will send an email to the email in the `to` field. In the message you should provide a link to a URL where the user can enter their new password.
  Include the code in this URL e.g. https://my-app.com/reset-password?code=$!{parent.code}.
  
  When the user gets to this page, you will have the password reset code in the URL query string. Get this code from the URL
  and when the user enter their new password, make a POST request to the Hypi API e.g.
  POST <hypi-domain>/email/reset/<domain> - where <domain> is app instance domain.
  
  In the body of the request send a JSON like this:
  {"code": "<the-code-from-the-URL>", "password": "<the-user's-new-password>"}
  
  Hypi will change the user's password and return HTTP status 200.
  """
  PasswordReminder

  """
  Defines a web hook that can be used to trigger Hypi GraphQL functions on a given app.
  The account specified in the web hook must have access to the app/instance and must be authorised to call the functions specified.
  """
  Webhook

  """
  If the query or mutation functions in the Webhook definition returns this then it controls what the server responds with
  For example, the GraphQL function can return a 301 or 302 status and a Location header to an external URL to cause a redirect.
  """
  WebhookResponse
  LogMessage

  """Creates a reference to a GraphQL function in an app instance."""
  GraphQLRef
  WorkflowStepData
  WorkflowStep
  AccessToken

  """
  A row is created for every resource. It cannot be created or modified by end users.
  The ID of each entry is a hash of the resource ID, type and field.
  When the resource is deleted, the entry is deleted.
  """
  StorageCounter
  PermissionDescription
  Hypi

  """
  Identifies a given country according to ISO3166
  https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes
  See also https://www.iso.org/obp/ui/#search and
  https://unicode-org.github.io/cldr-staging/charts/37/supplemental/territory_information.html
  """
  Country
  Account
  Person
  Organisation
  OAuthProvider

  """ namespace for containing authz objects and their relationships."""
  Realm

  """Defines a collection for subjects, roles, policies and permissions."""
  Group
  Role
  RolePolicy
  ClientPolicy
  TimePolicy
  AggregatedPolicy
  GroupPolicy
  AccountPolicy
  RealmPolicy
  RealmLink
  Permission
  File
  Video

  """
  Creates a new outbound message.
  Note that it automatically send unless the autoSend field is false
  """
  EmailMessage

  """
  A workflow defines a sequence of steps that execute in a defined order (you set the order field on each step).
  It is one way in which Hypi allows you to do composition, so similarities can be drawn to function composition with some specifics thrown in for Hypi and GraphQL.
  
  If two steps have the same order their execution order is undefined with relation to each other.
  Every step has a GraphQL function that is executed for that step.
  
  When a Workflow is executed it creates a WorkflowSession. The result of each step in the workflow is added to the session.
  
  The first step can have any parameters you want. For the other steps there are some rules that define how the system maps
  parameters to the function in these steps. These rules are:
  
  1. Any step (including the first step) can have a parameter "params: Json" i.e. name = params and type is Json.
  This params is a map of the arguments passed to the first function in the Workflow. For example if the function was defined as
  step1(a: Int, b: Json, c: MyType): T
  in this case the "params" Json object would be have the fields a, b and c set to the values the function was executed with.
  Normally, this is used in the first step but can be used in any step that wants access to this data.
  
  2. Any step can have a parameter "session: WorkflowSession" - this is the current workflow's session and contains the results of all steps before the current one.
  You can identify the results for a specific step by finding the result using the step's name in the session's data array.
  
  3. Except the first step, a parameter "previous: T" where T is the result type of the previous step can be used.
  In this case, the platform will use the output of the previous function for this parameter.
  Note that if the type is not the same as the last step's output type then the workflow will fail if the field is not optional.
  If the field is optional then the platform will not provide it and it would therefore be null if you try to use it.
  
  4. Except the first step, pass-through is possible. This is where the parameters from the first step are passed through
  to other steps by name and type. i.e. given
  step1(a: Int, b: String): String
  step2(a: Int): ID
  In this case, the variable "a" in both step1 and step2 will have the same value that step1 was executed with.
  Incidentally, this is the same as getting "a" from the "params" Json.
  """
  Workflow
  WorkflowSession
  Counter
  Gauge
  ServerlessResponse
  LearningEnvironment
  RecommendationModel
  KMeanCLusteringModel
  RecommendationTrainer
  ObjectSubjectRatingTriplet
  PredictionData
  TrainingInstance
  InvoiceItem
  PricePlanInclusion
  StripeOrder
  StripeReview
  StripeTransfer
  StripeTransferData
  StripeFraudDetails
  StripeShippingInfo
  StripeBillingDetails
  StripeAddress

  """
  A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate.
  https://stripe.com/docs/disputes
  """
  StripeDispute

  """
  Events are our way of letting you know when something interesting happens in your account. When an interesting event occurs, we create a new Event object. For example, when a charge succeeds, we create a charge.succeeded event; and when an invoice payment attempt fails, we create an invoice.payment_failed event. Note that many API requests may cause multiple events to be created. For example, if you create a new subscription for a customer, you will receive both a customer.subscription.created event and a charge.succeeded event.
  
  Events occur when the state of another API resource changes. The state of that resource at the time of the change is embedded in the event's data field. For example, a charge.succeeded event will contain a charge, and an invoice.payment_failed event will contain an invoice.
  https://stripe.com/docs/api/events
  """
  StripeEvent

  """ Mandate is a record of the permission a customer has given you to debit their payment method.
  """
  StripeMandate
  StripePaymentMethodDetails
  StripeCustomerAcceptance

  """
  A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. You can retrieve individual payouts, as well as list all payouts. Payouts are made on varying schedules, depending on your country and industry.
  https://stripe.com/docs/api/payouts
  """
  StripePayout
  StripePackageDimensions
  StripeTransformQuantity
  StripeTier
  StripePriceRecurrence

  """
  Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.
  https://stripe.com/docs/api/refunds
  """
  StripeRefund

  """
  PaymentMethod objects represent your customer's payment instruments. They can be used with PaymentIntents to collect payments or saved to Customer objects to store instrument details for future payments.
  https://stripe.com/docs/api/payment_methods
  """
  StripePaymentMethod
  StripeSebaDebit
  StripeIdeal
  StripeFpx
  StripeCardPresent
  StripeReceipt
  StripeBacsDebit
  StripeAuBecsDebit

  """
  These bank accounts are payment methods on Customer objects.
  
  On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well, and are documented in the links above.
  https://stripe.com/docs/api/customer_bank_accounts
  """
  StripeBankAccount

  """
  Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers.
  https://stripe.com/docs/api/sources
  """
  StripeSource

  """
  A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges.
  https://stripe.com/docs/api/coupons
  """
  StripeCoupon

  """
  Issue a credit note to adjust an invoice's amount after the invoice is finalized.
  https://stripe.com/docs/api/credit_notes
  """
  StripeCreditNote

  """
  Each customer has a balance value, which denotes a debit or credit that's automatically applied to their next invoice upon finalization. You may modify the value directly by using the update customer API, or by creating a Customer Balance Transaction, which increments or decrements the customer's balance by the specified amount.
  https://stripe.com/docs/api/customer_balance_transactions
  """
  StripeCustomerBalanceTransaction

  """
  A session describes the instantiation of the customer portal for a particular customer. By visiting the session's URL, the customer can manage their subscriptions and billing details. For security reasons, sessions are short-lived and will expire if the customer does not visit the URL. Create sessions on-demand when customers intend to manage their subscriptions and billing details.
  https://stripe.com/docs/api/customer_portal
  """
  StripeCustomerPortal

  """
  You can add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer.
  https://stripe.com/docs/api/customer_tax_ids
  """
  StripeTaxId

  """
  A discount represents the actual application of a coupon to a particular customer. It contains information about when the discount began and when it will end.
  https://stripe.com/docs/api/discounts
  """
  StripeDiscount
  StripeTaxAmount
  StripeDiscountAmount
  StripeStatusTransitions

  """https://stripe.com/docs/api/invoices/line_item"""
  StripeInvoiceLineItem
  StripePeriod

  """
  A Promotion Code represents a customer-redeemable code for a coupon. It can be used to create multiple codes for a single coupon.
  https://stripe.com/docs/api/promotion_codes
  """
  StripePromotionCode
  StripeIntervalObject
  StripePauseCollection
  StripePlan
  StripeBillingThreshold
  StripeSubscriptionScheduleSettings
  StripeInvoiceSettings

  """
  Tax rates can be applied to invoices, subscriptions and Checkout Sessions to collect tax.
  
  https://stripe.com/docs/api/tax_rates
  """
  StripeTaxRate

  """
  Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices.
  https://stripe.com/docs/api/usage_records
  """
  StripeUsageRecord

  """
  A Checkout Session represents your customer's session as they pay for one-time purchases or subscriptions through Checkout. We recommend creating a new Session each time your customer attempts to pay.
  
  Once payment is successful, the Checkout Session will contain a reference to the Customer, and either the successful PaymentIntent or an active Subscription.
  
  You can create a Checkout Session on your server and pass its ID to the client to begin Checkout.
  
  https://stripe.com/docs/api/checkout/sessions
  """
  StripeCheckoutSession
  StripeError
  StripeNextAction
  StripeAliPayHandleRedirect
  StripeOxxoDisplayDetails
  StripeRedirectToUrl
  StripeSofort
  StripeReference

  """"""
  Invoice
  PricePlanAllowance
  PricePlan

  """
  A Stripe API Charge to a card.
  https://stripe.com/docs/api/charges
  
  To charge a credit or a debit card, you create a Charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique, random ID.
  """
  StripeCharge
  StripeChargeOutcome

  """
  Customer objects allow you to perform recurring charges, and to track multiple charges, that are associated with the same customer. The API allows you to create, delete, and update your customers. You can retrieve individual customers as well as a list of all your customers.
  https://stripe.com/docs/api/customers
  """
  StripeCustomer

  """
  Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Checkout and Subscriptions.
  https://stripe.com/docs/api/products
  """
  StripeProduct

  """
  Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Products help you track inventory or provisioning, and prices help you track payment terms. Different physical goods or levels of service should be represented by products, and pricing options should be represented by prices. This approach lets you change prices without having to change your provisioning scheme.
  
  For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.
  https://stripe.com/docs/api/prices
  https://stripe.com/docs/api/prices/object
  """
  StripePrice

  """
  Invoices are statements of amounts owed by a customer, and are either generated one-off, or generated periodically from a subscription.
  
  They contain invoice items, and proration adjustments that may be caused by subscription upgrades/downgrades (if necessary).
  
  If your invoice is configured to be billed through automatic charges, Stripe automatically finalizes your invoice and attempts payment. Note that finalizing the invoice, when automatic, does not happen immediately as the invoice is created. Stripe waits until one hour after the last webhook was successfully sent (or the last webhook timed out after failing). If you (and the platforms you may have connected to) have no webhooks configured, Stripe waits one hour after creation to finalize the invoice.
  
  If your invoice is configured to be billed by sending an email, then based on your email settings, Stripe will email the invoice to your customer and await payment. These emails can contain a link to a hosted page to pay the invoice.
  
  Stripe applies any customer credit on the account before determining the amount due for the invoice (i.e., the amount that will be actually charged). If the amount due for the invoice is less than Stripe's minimum allowed charge per currency, the invoice is automatically marked paid, and we add the amount due to the customer's running account balance which is applied to the next invoice.
  
  https://stripe.com/docs/api/invoices
  """
  StripeInvoice
  StripeThesholdReason
  StripeItemReason

  """
  Sometimes you want to add a charge or credit to a customer, but actually charge or credit the customer's card only at the end of a regular billing cycle. This is useful for combining several charges (to minimize per-transaction fees), or for having Stripe tabulate your usage-based billing totals.
  https://stripe.com/docs/api/invoiceitems
  """
  StripeInvoiceItem

  """
  Subscriptions allow you to charge a customer on a recurring basis.
  
  https://stripe.com/docs/api/subscriptions
  """
  StripeSubscription
  StripeSubscriptionUpdate

  """
  Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships.
  https://stripe.com/docs/api/subscription_items
  """
  StripeSubscriptionItem

  """
  A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.
  
  https://stripe.com/docs/api/subscription_schedules
  """
  StripeSubscriptionSchedule
  StripeSubscriptionPhase

  """
  A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session.
  
  A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge.
  https://stripe.com/docs/api/payment_intents
  """
  StripePaymentIntent
  StripeSetupIntent
}

input StripeReferenceGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeReferenceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input WorkflowConditionalInput {
  execAs: String
  maxExecutionTime: String
  fn: GraphQLRefInput
  repeatN: Int
  steps: [WorkflowStepInput!]
  cronSchedule: String
  repeatIf: GraphQLRefInput
  async: Boolean
  parallel: Boolean
  name: String
  hypi: HypiInput
  evaluateIf: GraphQLRefInput
  order: Int
}

input StripeNextActionInput {
  hypi: HypiInput
  alipay_handle_redirect: StripeAliPayHandleRedirectInput
  oxxo_display_details: StripeOxxoDisplayDetailsInput
  redirect_to_url: StripeRedirectToUrlInput
  type: StripeNextActionType
  id: String
  use_stripe_sdk: String
  object: String
}

input StripeSebaDebitGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSebaDebitScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeChargeOutcome {
  hypi: Hypi
  network_status: StripeNetworkStatus

  """
  An enumerated value providing a more detailed explanation of the outcome’s type. Charges blocked by Radar’s default block rule have the value highest_risk_level. Charges placed in review by Radar’s default review rule have the value elevated_risk_level.
  """
  reason: String

  """
  Stripe’s evaluation of the riskiness of the payment. Possible values for evaluated payments are normal, elevated, highest. For non-card payments, and card-based payments predating the public assignment of risk levels, this field will have the value not_assessed. In the event of an error in the evaluation, this field will have the value unknown.
  """
  risk_level: String

  """
  Stripe’s evaluation of the riskiness of the payment. Possible values for evaluated payments are between 0 and 100. For non-card payments, card-based payments predating the public assignment of risk scores, or in the event of an error during evaluation, this field will not be present. This field is only available with Radar for Fraud Teams.
  """
  risk_score: Int

  """The ID of the Radar rule that matched the payment, if applicable."""
  rule: String

  """
  A human-readable description of the outcome type and reason, designed for you (the recipient of the payment), not your customer.
  """
  seller_message: String

  """
  Possible values are authorized, manual_review, issuer_declined, blocked, and invalid.
  """
  type: StripeOutcomeType

  """
  true if the charge succeeded, or was successfully authorized for later capture.
  """
  paid: Boolean

  """
  In Stripe ID of the payment method used in this charge. In Hypi it directly links to the object
  """
  payment_method: StripePaymentMethod

  """
  This is the transaction number that appears on email receipts sent for this charge. This attribute will be null until a receipt has been sent.
  """
  receipt_number: String

  """
  This is the URL to view the receipt for this charge. The receipt is kept up-to-date to the latest state of the charge, including any refunds. If the charge is for an Invoice, the receipt will be stylized as an Invoice receipt.
  """
  receipt_url: String
  review: String
  refunds(arcql: String, first: Int, after: String, last: Int, before: String): [StripeRefund]
}

input ABACTagGroupByOptions {
  """The field by which to to group the matching data"""
  field: ABACTagScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

type StripeAuBecsDebitAggs {
  bsb_number: AggOtherScalar
  fingerprint: AggOtherScalar
  last4: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeActionInput {
  oxxo_display_details: StripeOxxoDisplayDetailsInput
  redirect_to_url: StripeRedirectToUrlInput
  alipay_handle_redirect: StripeAliPayHandleRedirectInput
  hypi: HypiInput
  id: String
  type: StripeNextActionType
  use_stripe_sdk: String
  object: String
}

"""A list of types on which mathematical mutations can be performed on"""
input HypiMathType {
  Product: [ProductMaths!]
  URL: [URLMaths!]
  Coordinate: [CoordinateMaths!]
  BruteForceDetectionOptions: [BruteForceDetectionOptionsMaths!]
  WebhookResponse: [WebhookResponseMaths!]
  WorkflowStep: [WorkflowStepMaths!]
  StorageCounter: [StorageCounterMaths!]
  Workflow: [WorkflowMaths!]
  Counter: [CounterMaths!]
  Gauge: [GaugeMaths!]
  LearningEnvironment: [LearningEnvironmentMaths!]
  RecommendationTrainer: [RecommendationTrainerMaths!]
  ObjectSubjectRatingTriplet: [ObjectSubjectRatingTripletMaths!]
  InvoiceItem: [InvoiceItemMaths!]
  PricePlanInclusion: [PricePlanInclusionMaths!]
  StripeTransferData: [StripeTransferDataMaths!]
  StripePackageDimensions: [StripePackageDimensionsMaths!]
  StripeTransformQuantity: [StripeTransformQuantityMaths!]
  StripeTier: [StripeTierMaths!]
  StripePriceRecurrence: [StripePriceRecurrenceMaths!]
  StripePaymentMethod: [StripePaymentMethodMaths!]
  StripeCardPresent: [StripeCardPresentMaths!]
  StripeTaxAmount: [StripeTaxAmountMaths!]
  StripeDiscountAmount: [StripeDiscountAmountMaths!]
  StripeStatusTransitions: [StripeStatusTransitionsMaths!]
  StripePeriod: [StripePeriodMaths!]
  StripeIntervalObject: [StripeIntervalObjectMaths!]
  StripePauseCollection: [StripePauseCollectionMaths!]
  StripePlan: [StripePlanMaths!]
  StripeBillingThreshold: [StripeBillingThresholdMaths!]
  StripeInvoiceSettings: [StripeInvoiceSettingsMaths!]
  StripeUsageRecord: [StripeUsageRecordMaths!]
  StripeOxxoDisplayDetails: [StripeOxxoDisplayDetailsMaths!]
  Invoice: [InvoiceMaths!]
  PricePlanAllowance: [PricePlanAllowanceMaths!]
  StripeCharge: [StripeChargeMaths!]
  StripeChargeOutcome: [StripeChargeOutcomeMaths!]
  StripeCustomer: [StripeCustomerMaths!]
  StripeProduct: [StripeProductMaths!]
  StripePrice: [StripePriceMaths!]
  StripeInvoice: [StripeInvoiceMaths!]
  StripeThesholdReason: [StripeThesholdReasonMaths!]
  StripeItemReason: [StripeItemReasonMaths!]
  StripeInvoiceItem: [StripeInvoiceItemMaths!]
  StripeSubscription: [StripeSubscriptionMaths!]
  StripeSubscriptionUpdate: [StripeSubscriptionUpdateMaths!]
  StripeSubscriptionItem: [StripeSubscriptionItemMaths!]
  StripeSubscriptionSchedule: [StripeSubscriptionScheduleMaths!]
  StripeSubscriptionPhase: [StripeSubscriptionPhaseMaths!]
  StripePaymentIntent: [StripePaymentIntentMaths!]
  StripeSetupIntent: [StripeSetupIntentMaths!]
}

enum StripeBillingCycleAnchor {
  phase_start
  automatic
}

type PasswordAggs {
  value: AggOtherScalar
  expired: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type OAuthProviderAggs {
  clientId: AggOtherScalar
  clientSecret: AggOtherScalar
  clientAuthenticationMethod: AggOtherScalar
  authorizationGrantType: AggOtherScalar
  redirectUriTemplate: AggOtherScalar
  authorizationUri: AggOtherScalar
  tokenUri: AggOtherScalar
  userInfoUri: AggOtherScalar
  userInfoAuthenticationMethod: AggOtherScalar
  userNameAttributeName: AggOtherScalar
  jwkSetUri: AggOtherScalar
  clientName: AggOtherScalar
  hypiSuccessRedirectUri: AggOtherScalar
  hypiFailureRedirectUri: AggOtherScalar
  scopes: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeCreditNote"""
enum StripeCreditNoteFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePaymentIntentInput {
  hypi: HypiInput
  id: String
  object: String
  amount: Int
  amount_capturable: Int
  amount_received: Int
  charges: [StripeChargeInput!]
  client_secret: String
  currency: String
  customer: StripeCustomerInput
  description: String
  last_payment_error: StripeErrorInput
  metadata: Json
  next_action: StripeNextActionInput
  payment_method: StripePaymentMethodInput
  payment_method_types: [String!]
  receipt_email: String
  setup_future_usage: StripeUsage
  shipping: StripeShippingInfoInput
  statement_descriptor: String
  statement_descriptor_suffix: String
  status: String
  canceled_at: Int
  cncellation_reason: String
  capture_method: StripeCaptureMethod
  confirmation_method: StripeConfirmationMethod
  created: Int
  invoice: StripeInvoiceInput
  livemode: Boolean
  payment_method_options: StripePaymentOptionInput
  review: String
}

type StripeSubscriptionUpdateAggs {
  billing_cycle_anchor: AggInt
  expires_at: AggInt
  trial_end: AggInt
  trial_from_plan: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripePauseCollection"""
enum StripePauseCollectionScalarFields {
  behavior
  resumes_at
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input PricePlanAllowanceMaths {
  allowed_overage_amount: MathInputFloat
}

"""Scalar fields defined by StripeOrder"""
enum StripeOrderScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input InvoiceItemMaths {
  quantity: MathInputFloat
  vat: MathInputFloat
}

type StripeReceipt {
  hypi: Hypi
  account_type: StripeAccountType
  application_cryptogram: String
  application_preferred_name: String
  authorization_code: String
  authorization_response_code: String
  cardholder_verification_method: String
  dedicated_file_name: String
  terminal_verification_results: String
  transaction_status_information: String
}

input WebhookInput {
  hypi: HypiInput
  name: String
  as: AccountInput
  query: GraphQLRefInput!
}

"""All fields defined by Invoice"""
enum InvoiceFields {
  hypi
  buyer
  seller
  due_date
  notes
  vat_amount
  items
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by Language"""
enum LanguageFields {
  hypi
  family
  isoName
  nativeName
  iso6391Code
  iso6392TCode
  iso6392BCode
  iso6393Code
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""Scalar fields defined by AggInt"""
enum AggIntScalarFields {
  avg
  count
  max
  min
  sum
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId

  """The value of the aggregated field for each group"""
  groupValues_key

  """The value of the aggregated field for each group"""
  groupValues_value
}

input StripeSetupIntentInput {
  hypi: HypiInput
  id: String
  object: String
  client_secret: String
  customer: StripeCustomerInput
  description: String
  last_setup_error: StripeErrorInput
  metadata: Json
  next_action: StripeNextActionInput
  payment_method: StripePaymentMethodInput
  payment_method_types: [String!]
  status: String
  cncellation_reason: String
  created: Int
  livemode: Boolean
  payment_method_options: StripePaymentOptionInput
  usage: StripeUsage
  mandate: StripeMandateInput
  single_use_mandate: StripeMandateInput
}

interface Policy {
  hypi: Hypi
  name: String!

  """Positive` or `Negative"""
  logic: AuthLogic
}

type StripeShippingInfoAggs {
  carrier: AggOtherScalar
  name: AggOtherScalar
  phone: AggOtherScalar
  tracking_number: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

type ScriptAggs {
  type: AggOtherScalar
  name: AggOtherScalar
  body: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeRedirectToUrl"""
enum StripeRedirectToUrlFields {
  hypi
  return_url
  url
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripeIntervalObjectGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeIntervalObjectScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input PricePlanInclusionInputOpt {
  hypi: HypiInputOpt
  item: InvoiceItemInputOpt
  allow_overage: Boolean
  allowed_overage_amount: Float
  allowed_overage_is_percentage: Boolean
}

input WorkflowStepMaths {
  order: MathInputInt
  repeatN: MathInputInt
}

type PricePlanInclusion {
  hypi: Hypi
  item: InvoiceItem
  allow_overage: Boolean

  """If overage is allowed, how much is allowed?"""
  allowed_overage_amount: Float

  """
  If overage is allowed and an amount is specified, is the amount a percentage?
  """
  allowed_overage_is_percentage: Boolean
}

"""All fields defined by KMeanCLusteringModel"""
enum KMeanCLusteringModelFields {
  hypi
  typeName
  arcql
  name
  description
  label
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All numeric fields defined by StripeTaxAmount"""
enum StripeTaxAmountNumericFields {
  amount
}

enum StripeCollectionMethod {
  charge_automatically
  send_invoice
}

"""All fields defined by Script"""
enum ScriptFields {
  hypi
  type
  name
  body
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type AccessToken {
  hypi: Hypi
  sessionToken: String
  sessionExpires: Long
  errorCode: String
  errorMsg: String
}

type PersonAggs {
  dob: AggOtherScalar
  gender: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeUsageRecordGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeUsageRecordScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by StripeTier"""
enum StripeTierNumericFields {
  flat_amount
  flat_amount_decimal
  unit_amount
  unit_amount_decimal
}

enum StripeNextActionType {
  redirect_to_url
  use_stripe_sdk
}

type Script {
  hypi: Hypi
  type: TanType!
  name: String!
  body: String!
}

"""
Creates a new outbound message.
Note that it automatically send unless the autoSend field is false
"""
type EmailMessage {
  hypi: Hypi
  from: Email!
  subject: String!

  """
  Name of the template to use, if present then the given template is used and text/html etc fields in this message are not used
  """
  template: String
  text: String
  html: String

  """
   Schedule sending in the future
   
  """
  deliveryTime: DateTime

  """
   If set to True or yes this requires the message only be sent over a TLS connection. If a TLS connection can not be established, we will not deliver the message.
   If set to False or no, we will still try and upgrade the connection, if that fails the message will be delivered over a plaintext SMTP connection.
   
  """
  requireTls: Boolean

  """
   If set to True or yes, the certificate and hostname will not be verified when trying to establish a TLS connection and Hypi will accept any certificate during delivery.
  
   If set to False or no, Hypi will verify the certificate and hostname. If either one can not be verified, a TLS connection will not be established.
  
   The default is False.
   
  """
  skipVerification: Boolean

  """
   allows to append a custom MIME header to the message (X-My-Header in this case). For example, h:Reply-To to specify Reply-To address.
   
  """
  headers: Json

  """
   prefix followed by an arbitrary name allows to attach a custom JSON data to the message. See Attaching Data to Messages for more information.
   
  """
  variables: Json

  """
   A valid JSON-encoded dictionary, where key is a plain recipient address and value is a dictionary with variables that can be referenced in the message body.
   
  """
  recipientVariables: Json
  to(arcql: String, first: Int, after: String, last: Int, before: String): [Email!]!
  cc(arcql: String, first: Int, after: String, last: Int, before: String): [Email!]
  bcc(arcql: String, first: Int, after: String, last: Int, before: String): [Email!]
  attachment(arcql: String, first: Int, after: String, last: Int, before: String): [File!]
  inline(arcql: String, first: Int, after: String, last: Int, before: String): [File!]
  tags(arcql: String, first: Int, after: String, last: Int, before: String): [String]
  responses(arcql: String, first: Int, after: String, last: Int, before: String): [EmailSendingAttempt!]
}

type StripePromotionCodeAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input WorkflowStepDataInputOpt {
  hypi: HypiInputOpt
  stepName: String
  stepResult: Any
}

input EmailInputOpt {
  hypi: HypiInputOpt
  value: String
  type: String
}

input StripeInvoiceSettingsMaths {
  days_until_due: MathInputInt
}

input StripeAuBecsDebitInputOpt {
  hypi: HypiInputOpt
  bsb_number: String
  fingerprint: String
  last4: String
}

"""All fields defined by RecommendationModel"""
enum RecommendationModelFields {
  hypi
  env
  trainer
  type
  ratingFieldName
  subjectFieldName
  objectFieldName
  arcql
  name
  description
  label
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input StripePriceRecurrenceGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePriceRecurrenceScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All numeric fields defined by RecommendationTrainer"""
enum RecommendationTrainerNumericFields {
  maxIterations
  minMdlImprovement
  batchSize
  learningRate
}

type StripeTier {
  hypi: Hypi

  """Price for the entire tier."""
  flat_amount: Int

  """
  Same as flat_amount, but contains a decimal value with at most 12 decimal places.
  """
  flat_amount_decimal: Float

  """Per unit price for units relevant to the tier."""
  unit_amount: Int

  """
  Same as unit_amount, but contains a decimal value with at most 12 decimal places.
  """
  unit_amount_decimal: Float

  """Up to and including to this quantity will be contained in the tier."""
  up_to: String
}

type StripeBillingThresholdAggs {
  usage_gte: AggInt
  amount_gte: AggInt
  reset_billing_cycle_anchor: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripePaymentMethodDetailsInputOpt {
  hypi: HypiInputOpt
  id: String
  object: String
}

"""All fields defined by OAuthProvider"""
enum OAuthProviderFields {
  hypi

  """ instanceId-(hypi.id = registrationId)"""
  clientId
  clientSecret
  clientAuthenticationMethod
  authorizationGrantType
  redirectUriTemplate
  authorizationUri
  tokenUri
  userInfoUri
  userInfoAuthenticationMethod
  userNameAttributeName
  jwkSetUri
  clientName
  hypiSuccessRedirectUri
  hypiFailureRedirectUri
  scopes
  configurationMetadata
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type PasswordReminderAggs {
  valid: AggOtherScalar
  code: AggOtherScalar
  from: AggOtherScalar
  subject: AggOtherScalar
  htmlMessage: AggOtherScalar
  plainTextMessage: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
  to_value: AggOtherScalar
  to_type: AggOtherScalar
}

input StorageCounterMaths {
  size: MathInputInt
}

input RealmLinkInputOpt {
  hypi: HypiInputOpt
  name: String
  accounts: [AccountInputOpt]
}

"""Scalar fields defined by AggFloat"""
enum AggFloatScalarFields {
  avg
  count
  max
  min
  sum
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId

  """The value of the aggregated field for each group"""
  groupValues_key

  """The value of the aggregated field for each group"""
  groupValues_value
}

type InvoiceAggs {
  due_date: AggOtherScalar
  notes: AggOtherScalar
  vat_amount: AggFloat
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input URLMaths {
  port: MathInputInt
}

"""All fields defined by StripeIdeal"""
enum StripeIdealFields {
  hypi
  bank
  bic
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input InvoiceMaths {
  vat_amount: MathInputFloat
}

input CurrencyGroupByOptions {
  """The field by which to to group the matching data"""
  field: CurrencyScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePauseCollectionGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripePauseCollectionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeSubscriptionMaths {
  current_period_end: MathInputInt
  current_period_start: MathInputInt
  billing_cycle_anchor: MathInputInt
  cancel_at: MathInputInt
  canceled_at: MathInputInt
  created: MathInputInt
  days_until_due: MathInputInt
  ended_at: MathInputInt
  next_pending_invoice_item_invoice: MathInputInt
  start_date: MathInputInt
  trial_end: MathInputInt
  trial_start: MathInputInt
}

"""Scalar fields defined by EmailVerification"""
enum EmailVerificationScalarFields {
  """
  After the link is clicked from the email, redirect the browser to this URL passing a token in the URL i.e. token=jwt.token.here which can be used get the value in the meta field
  """
  redirectTo

  """
  The verification code that is included in the email sent. Generated by the server, if provided the provided value is ignored
  """
  code

  """
  Optionally, the email from which the email will be sent. You MUST have a Hypi email app configured to send from this address
  """
  from

  """
  Optionally, the subject of the email, this is a velocity template - Hypi provides a default such as "Please verify your email to <realm>"
  """
  subject
  templateName

  """
   The HTML contents of the email. This is a Velocity template that will be rendered before being sent.
   The available variables and their types are:
   instance: AppId - You app instance ID
   parent - a map representing the current EmailVerification object
   value - the value of the htmlMessage field
   env: HypiEnv
   
  """
  htmlMessage

  """
  A plain text version of the email - see this is a velocity template, see htmlMessage for available variables
  """
  plainTextMessage

  """
  Any additional meta data you want to store. For example, you could collect all of the information needed to create the Account
  """
  meta

  """Set by system, cannot be provided"""
  confirmed
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  email_value
  email_type
}

type StripeError {
  hypi: Hypi
  charge: StripeCharge
  code: String
  decline_code: String
  doc_url: String
  message: String
  param: String
  payment_method: StripePaymentMethod
  type: String
}

type StripeProductAggs {
  id: AggOtherScalar
  active: AggOtherScalar
  description: AggOtherScalar
  metadata: AggOtherScalar
  name: AggOtherScalar
  object: AggOtherScalar
  caption: AggOtherScalar
  created: AggInt
  livemode: AggOtherScalar
  url: AggOtherScalar
  updated: AggInt
  unit_label: AggOtherScalar
  statement_descriptor: AggOtherScalar
  shippable: AggOtherScalar
  attributes: AggOtherScalar
  deactivate_on: AggOtherScalar
  images: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""Scalar fields defined by StripeCreditNote"""
enum StripeCreditNoteScalarFields {
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input OAuth2AuthorizedClientInput {
  hypi: HypiInput
  clientRegistrationId: String
  principalName: String
  accessToken: String
  refreshToken: String
}

"""All fields defined by StripeTaxRate"""
enum StripeTaxRateFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input PricePlanGroupByOptions {
  """The field by which to to group the matching data"""
  field: PricePlanScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""Scalar fields defined by StripeSource"""
enum StripeSourceScalarFields {
  id
  object
  client_secret
  reusable
  livemode
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

type StripeAliPayHandleRedirectAggs {
  native_data: AggOtherScalar
  native_url: AggOtherScalar
  return_url: AggOtherScalar
  url: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input AccountPolicyInput {
  hypi: HypiInput
  accounts: [AccountInput!]
  name: String!
  logic: AuthLogic
}

type StripeOrderAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeSofortInput {
  hypi: HypiInput
  country: StripeSofortCountry!
  id: String
  object: String
}

enum InvoiceItemUnit {
  SECOND
  MINUTE
  HOUR
  DAY
  WEEK
  MONTH
  YEAR
  MEGABYTES
  GIGABYTES
  TERABYTES
  PETABYTES
  INBOUND_REQUESTS
  OUTBOUND_REQUESTS
  CPU_TIME
  RAM_MB
  RAM_GB
  DISK_MB
  DISK_GB
  DISK_TB
  DISK_PB

  """Anything that isn't covered by this list"""
  PRODUCT

  """A discount being applied to the invoice"""
  DISCOUNT

  """A credit being applied to the invoice"""
  CREDIT

  """VAT being applied to all invoice items in the invoice"""
  VAT
}

input StripePeriodInput {
  hypi: HypiInput
  start: Int
  end: Int
}

"""Scalar fields defined by StripePlan"""
enum StripePlanScalarFields {
  id
  object
  active
  billing_scheme
  created
  currency
  interval
  interval_count
  livemode
  metadata
  product
  tiers_mode
  usage_type
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

"""Scalar fields defined by StripeSubscription"""
enum StripeSubscriptionScalarFields {
  id
  object
  cancel_at_period_end
  current_period_end
  current_period_start
  metadata
  status
  billing_cycle_anchor
  cancel_at
  canceled_at
  collection_method
  created
  days_until_due
  ended_at
  livemode
  next_pending_invoice_item_invoice
  start_date
  trial_end
  trial_start
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
}

input StripeCustomerBalanceTransactionGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeCustomerBalanceTransactionScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripeEventInput {
  hypi: HypiInput
  id: String
  object: String
}

"""All fields defined by StripeCustomerPortal"""
enum StripeCustomerPortalFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input ObjectSubjectRatingTripletInput {
  hypi: HypiInput
  subjectId: Int!
  objectId: Int!
  rating: Float
}

"""
A Checkout Session represents your customer's session as they pay for one-time purchases or subscriptions through Checkout. We recommend creating a new Session each time your customer attempts to pay.

Once payment is successful, the Checkout Session will contain a reference to the Customer, and either the successful PaymentIntent or an active Subscription.

You can create a Checkout Session on your server and pass its ID to the client to begin Checkout.

https://stripe.com/docs/api/checkout/sessions
"""
type StripeCheckoutSession {
  hypi: Hypi
  id: String
  object: String
}

enum AggOrder {
  ASC
  DESC
}

type StripeDisputeAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

"""All fields defined by StripeIntervalObject"""
enum StripeIntervalObjectFields {
  hypi
  interval
  interval_count
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

input RemoteLoginGroupByOptions {
  """The field by which to to group the matching data"""
  field: RemoteLoginScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

"""All fields defined by StorageCounter"""
enum StorageCounterFields {
  hypi
  type
  field
  size
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

"""All fields defined by StripeCustomerBalanceTransaction"""
enum StripeCustomerBalanceTransactionFields {
  hypi
  id
  object
  hypi_id
  hypi_impl
  hypi_created
  hypi_updated
  hypi_trashed
  hypi_createdBy
  hypi_instanceId
  hypi_hypi_hidden_tags
  hypi_tags
}

type StripeFpxAggs {
  bank: AggOtherScalar
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input EmailVerificationInput {
  hypi: HypiInput
  email: EmailInput!
  redirectTo: String!
  code: String
  from: String
  subject: String
  templateName: String
  htmlMessage: String
  plainTextMessage: String
  meta: Json
  confirmed: Boolean
}

type StripeTransfer {
  hypi: Hypi
  id: String
  object: String
}

input AddressInputOpt {
  hypi: HypiInputOpt
  door: String
  street: String
  town: String
  county: String
  city: String
  country: CountryInputOpt
  postCode: String
  from: DateTime
  to: DateTime
}

input WorkflowParallelInput {
  execAs: String
  async: Boolean
  parallel: Boolean
  name: String
  maxExecutionTime: String
  repeatN: Int
  hypi: HypiInput
  steps: [WorkflowStepInput!]
  evaluateIf: GraphQLRefInput
  cronSchedule: String
  repeatIf: GraphQLRefInput
}

input StripeCustomerPortalInput {
  hypi: HypiInput
  id: String
  object: String
}

type StripeSubscriptionScheduleAggs {
  id: AggOtherScalar
  object: AggOtherScalar
  metadata: AggOtherScalar
  status: AggOtherScalar
  canceled_at: AggInt
  completed_at: AggInt
  created: AggInt
  end_behavior: AggOtherScalar
  livemode: AggOtherScalar
  released_at: AggInt
  hypi_id: AggOtherScalar
  hypi_impl: AggOtherScalar
  hypi_created: AggOtherScalar
  hypi_updated: AggOtherScalar
  hypi_trashed: AggOtherScalar
  hypi_createdBy: AggOtherScalar
  hypi_instanceId: AggOtherScalar
}

input StripeSubscriptionItemGroupByOptions {
  """The field by which to to group the matching data"""
  field: StripeSubscriptionItemScalarFields!

  """
  If provided, the aggregated data will be ordered by this field and any other field which specifies this field, in the order they're defined
  """
  order: AggOrder

  """
  Applies only to DateTime fields. If provided then the date is grouped to this granularity e.g. if MINUTES then the grouping will be per minute
  """
  dateGranularity: TimeUnit
}

input StripePriceInputOpt {
  hypi: HypiInputOpt
  id: String
  active: Boolean
  currency: String
  metadata: Json
  nickname: String
  product: StripeProductInputOpt
  recurring: StripePriceRecurrenceInputOpt
  type: StripePriceType
  unit_amount: Int
  object: String
  billing_scheme: StripeBillingScheme
  created: Int
  live_mode: Boolean
  lookup_key: String
  tiers: [StripeTierInputOpt]
  tiers_mode: StripeTierMode
  transform_quantity: StripeTransformQuantityInputOpt
  unit_amount_decimal: String
}
